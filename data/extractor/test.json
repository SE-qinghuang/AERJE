{"text": "on every recursion step ,  issue a repaint() call and sleep for a few hundred milliseconds", "tokens": ["on", "every", "recursion", "step", ",", "", "issue", "a", "repaint()", "call", "and", "sleep", "for", "a", "few", "hundred", "milliseconds", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "to create the file you will have to use the method createfile()", "tokens": ["to", "create", "the", "file", "you", "will", "have", "to", "use", "the", "method", "createfile()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> createfile() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "createfile()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "createfile()", "label": "API", "asoc": []}]}
{"text": "when adding the objects to a set or map  .", "tokens": ["when", "adding", "the", "objects", "to", "a", "set", "or", "map", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> set <extra_id_0> function similarity <extra_id_5> map <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "set"}, {"type": "API", "offset": [8], "text": "map"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [6], "text": "set"}, {"type": "API", "offset": [8], "text": "map"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "set", "label": "API", "asoc": [["function similarity", "map"]]}, {"span": "map", "label": "API", "asoc": []}]}
{"text": "but i would choose 64-bit integer column types for simplicity and for direct compatibility with the java.time.instant class ?", "tokens": ["but", "i", "would", "choose", "64-bit", "integer", "column", "types", "for", "simplicity", "and", "for", "direct", "compatibility", "with", "the", "java.time.instant", "class", "?", "", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.time.instant <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "java.time.instant"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.time.instant", "label": "API", "asoc": []}]}
{"text": "however ,  in most cases it's easier to use an java.util.concurrent.executorservice", "tokens": ["however", ",", "", "in", "most", "cases", "it's", "easier", "to", "use", "an", "java.util.concurrent.executorservice", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.concurrent.executorservice <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "java.util.concurrent.executorservice"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.concurrent.executorservice", "label": "API", "asoc": []}]}
{"text": "then ,  you can use string.split(string) and integer.parseint(string) with something like output is", "tokens": ["then", ",", "", "you", "can", "use", "string.split(string)", "and", "integer.parseint(string)", "with", "something", "like", "output", "is", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.split(string) <extra_id_0> function collaboration <extra_id_5> integer.parseint(string) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> integer.parseint(string) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "string.split(string)"}, {"type": "API", "offset": [8], "text": "integer.parseint(string)"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [6], "text": "string.split(string)"}, {"type": "API", "offset": [8], "text": "integer.parseint(string)"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "string.split(string)", "label": "API", "asoc": [["function collaboration", "integer.parseint(string)"]]}, {"span": "integer.parseint(string)", "label": "API", "asoc": []}]}
{"text": "it compiles only because equals() accepts object ,  not a string", "tokens": ["it", "compiles", "only", "because", "equals()", "accepts", "object", ",", "", "not", "a", "string", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "equals()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": []}]}
{"text": "you can export a secretkey using the getencoded() method", "tokens": ["you", "can", "export", "a", "secretkey", "using", "the", "getencoded()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getencoded() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "getencoded()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getencoded()", "label": "API", "asoc": []}]}
{"text": "this way you skip future odd behaviours if java decides to return directories with a slash in the end or if your directory string comes from somewhere else than java.io.file", "tokens": ["this", "way", "you", "skip", "future", "odd", "behaviours", "if", "java", "decides", "to", "return", "directories", "with", "a", "slash", "in", "the", "end", "or", "if", "your", "directory", "string", "comes", "from", "somewhere", "else", "than", "java.io.file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.io.file <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [29], "text": "java.io.file"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.io.file", "label": "API", "asoc": []}]}
{"text": "you can also call system.gc() to suggest that the garbage collector run immediately", "tokens": ["you", "can", "also", "call", "system.gc()", "to", "suggest", "that", "the", "garbage", "collector", "run", "immediately", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.gc() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.gc()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.gc()", "label": "API", "asoc": []}]}
{"text": "create a bullet ,  or change the location of the bullet ,  or whatever) ,  and then call repaint()", "tokens": ["create", "a", "bullet", ",", "", "or", "change", "the", "location", "of", "the", "bullet", ",", "", "or", "whatever)", ",", "", "and", "then", "call", "repaint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "to preserve insertion order ,  instead use java.util.linkedhashmap (javadoc)", "tokens": ["to", "preserve", "insertion", "order", ",", "", "instead", "use", "java.util.linkedhashmap", "(javadoc)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.linkedhashmap <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "java.util.linkedhashmap"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.linkedhashmap", "label": "API", "asoc": []}]}
{"text": "for example ,  this is a perfectly valid clone() implementation", "tokens": ["for", "example", ",", "", "this", "is", "a", "perfectly", "valid", "clone()", "implementation", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> clone() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "clone()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "clone()", "label": "API", "asoc": []}]}
{"text": "normal ways would be integer.tostring(i) or string.valueof(i)", "tokens": ["normal", "ways", "would", "be", "integer.tostring(i)", "or", "string.valueof(i)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> integer.tostring(i) <extra_id_0> function similarity <extra_id_5> string.valueof(i) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> string.valueof(i) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "integer.tostring(i)"}, {"type": "API", "offset": [6], "text": "string.valueof(i)"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [4], "text": "integer.tostring(i)"}, {"type": "API", "offset": [6], "text": "string.valueof(i)"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "integer.tostring(i)", "label": "API", "asoc": [["function similarity", "string.valueof(i)"]]}, {"span": "string.valueof(i)", "label": "API", "asoc": []}]}
{"text": "however ,  you can treat it as a java.nio.file.path", "tokens": ["however", ",", "", "you", "can", "treat", "it", "as", "a", "java.nio.file.path", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.nio.file.path <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "java.nio.file.path"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.nio.file.path", "label": "API", "asoc": []}]}
{"text": "replace() doesn't change the string you call it on - it returns a new string with the changes", "tokens": ["replace()", "doesn't", "change", "the", "string", "you", "call", "it", "on", "-", "it", "returns", "a", "new", "string", "with", "the", "changes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "replace()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replace()", "label": "API", "asoc": []}]}
{"text": "to sort the whole array ,  just call arrays.sort(p)", "tokens": ["to", "sort", "the", "whole", "array", ",", "", "just", "call", "arrays.sort(p)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort(p) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "arrays.sort(p)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort(p)", "label": "API", "asoc": []}]}
{"text": "my experience with larger files sizes has been that java.nio is faster than java.io", "tokens": ["my", "experience", "with", "larger", "files", "sizes", "has", "been", "that", "java.nio", "is", "faster", "than", "java.io", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.nio <extra_id_0> efficiency comparison <extra_id_5> java.io <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> java.io <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "java.nio"}, {"type": "API", "offset": [13], "text": "java.io"}], "relation": [{"type": "efficiency comparison", "args": [{"type": "API", "offset": [9], "text": "java.nio"}, {"type": "API", "offset": [13], "text": "java.io"}]}], "event": [], "spot": ["API"], "asoc": ["efficiency comparison"], "spot_asoc": [{"span": "java.nio", "label": "API", "asoc": [["efficiency comparison", "java.io"]]}, {"span": "java.io", "label": "API", "asoc": []}]}
{"text": "then i discovered the with() method .", "tokens": ["then", "i", "discovered", "the", "with()", "method", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> with() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "with()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "with()", "label": "API", "asoc": []}]}
{"text": "java has the java.util.concurrent package ,  and there's also the fork/join framework", "tokens": ["java", "has", "the", "java.util.concurrent", "package", ",", "", "and", "there's", "also", "the", "fork/join", "framework", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.concurrent <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "java.util.concurrent"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.concurrent", "label": "API", "asoc": []}]}
{"text": "you'll find this in collection.remove methods aswell", "tokens": ["you'll", "find", "this", "in", "collection.remove", "methods", "aswell", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> collection.remove <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "collection.remove"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "collection.remove", "label": "API", "asoc": []}]}
{"text": "enum constants are encoded differently than instances of normal classes ,  so objectinputstream.readobject() can deserialize them without calling their readobject method", "tokens": ["enum", "constants", "are", "encoded", "differently", "than", "instances", "of", "normal", "classes", ",", "", "so", "objectinputstream.readobject()", "can", "deserialize", "them", "without", "calling", "their", "readobject", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> objectinputstream.readobject() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "objectinputstream.readobject()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "objectinputstream.readobject()", "label": "API", "asoc": []}]}
{"text": "it is simple enough to create your own itemwriter that does a simple system.out.println() .", "tokens": ["it", "is", "simple", "enough", "to", "create", "your", "own", "itemwriter", "that", "does", "a", "simple", "system.out.println()", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.out.println() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "system.out.println()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.out.println()", "label": "API", "asoc": []}]}
{"text": "those are not regular files nor directories nor symlinks so both file.isfile() and file.isdirectory() will return false", "tokens": ["those", "are", "not", "regular", "files", "nor", "directories", "nor", "symlinks", "so", "both", "file.isfile()", "and", "file.isdirectory()", "will", "return", "false", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.isfile() <extra_id_0> function similarity <extra_id_5> file.isdirectory() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> file.isdirectory() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "file.isfile()"}, {"type": "API", "offset": [13], "text": "file.isdirectory()"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [11], "text": "file.isfile()"}, {"type": "API", "offset": [13], "text": "file.isdirectory()"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "file.isfile()", "label": "API", "asoc": [["function similarity", "file.isdirectory()"]]}, {"span": "file.isdirectory()", "label": "API", "asoc": []}]}
{"text": "use the string.replaceall() method: hope this helps .", "tokens": ["use", "the", "string.replaceall()", "method:", "hope", "this", "helps", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.replaceall() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "string.replaceall()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.replaceall()", "label": "API", "asoc": []}]}
{"text": "readline() blocks until  the connection had been shutdown() or close() or it received a new-line \\n ,  which never is sent by the server .", "tokens": ["readline()", "blocks", "until", "", "the", "connection", "had", "been", "shutdown()", "or", "close()", "or", "it", "received", "a", "new-line", "\\n", ",", "", "which", "never", "is", "sent", "by", "the", "server", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> readline() <extra_id_0> logic constraint <extra_id_5> shutdown() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> shutdown() <extra_id_1> <extra_id_0> API <extra_id_5> close() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "readline()"}, {"type": "API", "offset": [8], "text": "shutdown()"}, {"type": "API", "offset": [10], "text": "close()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [0], "text": "readline()"}, {"type": "API", "offset": [8], "text": "shutdown()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "readline()", "label": "API", "asoc": [["logic constraint", "shutdown()"]]}, {"span": "shutdown()", "label": "API", "asoc": []}, {"span": "close()", "label": "API", "asoc": []}]}
{"text": "you need to call gettime() to get the date out of it", "tokens": ["you", "need", "to", "call", "gettime()", "to", "get", "the", "date", "out", "of", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> gettime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "gettime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "gettime()", "label": "API", "asoc": []}]}
{"text": "this approach has the advantage of not needing to explicitly initialize a java.util.random instance ,  which can be a source of confusion and error if used inappropriately", "tokens": ["this", "approach", "has", "the", "advantage", "of", "not", "needing", "to", "explicitly", "initialize", "a", "java.util.random", "instance", ",", "", "which", "can", "be", "a", "source", "of", "confusion", "and", "error", "if", "used", "inappropriately", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "java.util.random"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.random", "label": "API", "asoc": []}]}
{"text": "first of all ,  to persist a java.util.date into a database in java ,  you will have to convert it to java.sql.date", "tokens": ["first", "of", "all", ",", "", "to", "persist", "a", "java.util.date", "into", "a", "database", "in", "java", ",", "", "you", "will", "have", "to", "convert", "it", "to", "java.sql.date", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.date <extra_id_0> type conversion <extra_id_5> java.sql.date <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> java.sql.date <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "java.util.date"}, {"type": "API", "offset": [23], "text": "java.sql.date"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [8], "text": "java.util.date"}, {"type": "API", "offset": [23], "text": "java.sql.date"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "java.util.date", "label": "API", "asoc": [["type conversion", "java.sql.date"]]}, {"span": "java.sql.date", "label": "API", "asoc": []}]}
{"text": "the caching happens only if you use integer.valueof(int) ,  not if you use new integer(int)", "tokens": ["the", "caching", "happens", "only", "if", "you", "use", "integer.valueof(int)", ",", "", "not", "if", "you", "use", "new", "integer(int)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> integer.valueof(int) <extra_id_0> behavior difference <extra_id_5> integer(int) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> integer(int) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "integer.valueof(int)"}, {"type": "API", "offset": [15], "text": "integer(int)"}], "relation": [{"type": "behavior difference", "args": [{"type": "API", "offset": [7], "text": "integer.valueof(int)"}, {"type": "API", "offset": [15], "text": "integer(int)"}]}], "event": [], "spot": ["API"], "asoc": ["behavior difference"], "spot_asoc": [{"span": "integer.valueof(int)", "label": "API", "asoc": [["behavior difference", "integer(int)"]]}, {"span": "integer(int)", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to retrieve a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "retrieve", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "the argument passed to system.exit() will be used as the return value of the jvm process on most os", "tokens": ["the", "argument", "passed", "to", "system.exit()", "will", "be", "used", "as", "the", "return", "value", "of", "the", "jvm", "process", "on", "most", "os", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.exit() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.exit()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.exit()", "label": "API", "asoc": []}]}
{"text": "this is in contrast to system.nanotime() .", "tokens": ["this", "is", "in", "contrast", "to", "system.nanotime()", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.nanotime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "system.nanotime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.nanotime()", "label": "API", "asoc": []}]}
{"text": "you can write the acl info to standard output ,  and use the streams available on the java.lang.process to read the process output", "tokens": ["you", "can", "write", "the", "acl", "info", "to", "standard", "output", ",", "", "and", "use", "the", "streams", "available", "on", "the", "java.lang.process", "to", "read", "the", "process", "output", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.process <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "java.lang.process"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.process", "label": "API", "asoc": []}]}
{"text": "a static inner class: the map.entry class used by my triemap class does not need to refer to the object that created it so it can be made static to save the unnecessary reference", "tokens": ["a", "static", "inner", "class:", "the", "map.entry", "class", "used", "by", "my", "triemap", "class", "does", "not", "need", "to", "refer", "to", "the", "object", "that", "created", "it", "so", "it", "can", "be", "made", "static", "to", "save", "the", "unnecessary", "reference", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> map.entry <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "map.entry"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "map.entry", "label": "API", "asoc": []}]}
{"text": "to get a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "get", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "here is the detailed explanation of why \" random.nextint(n) is both more efficient and less biased than math.random() \"", "tokens": ["here", "is", "the", "detailed", "explanation", "of", "why", "\"", "random.nextint(n)", "is", "both", "more", "efficient", "and", "less", "biased", "than", "math.random()", "\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> random.nextint(n) <extra_id_0> efficiency comparison <extra_id_5> math.random() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> math.random() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "random.nextint(n)"}, {"type": "API", "offset": [17], "text": "math.random()"}], "relation": [{"type": "efficiency comparison", "args": [{"type": "API", "offset": [8], "text": "random.nextint(n)"}, {"type": "API", "offset": [17], "text": "math.random()"}]}], "event": [], "spot": ["API"], "asoc": ["efficiency comparison"], "spot_asoc": [{"span": "random.nextint(n)", "label": "API", "asoc": [["efficiency comparison", "math.random()"]]}, {"span": "math.random()", "label": "API", "asoc": []}]}
{"text": "once we call pow() recursively ,  it's always with positive numbers and the sign doesn't change until it reaches 0", "tokens": ["once", "we", "call", "pow()", "recursively", ",", "", "it's", "always", "with", "positive", "numbers", "and", "the", "sign", "doesn't", "change", "until", "it", "reaches", "0", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pow() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pow()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pow()", "label": "API", "asoc": []}]}
{"text": "list.contains() method uses the equals() method to evaluate if two objects are the same", "tokens": ["list.contains()", "method", "uses", "the", "equals()", "method", "to", "evaluate", "if", "two", "objects", "are", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> list.contains() <extra_id_0> logic constraint <extra_id_5> equals() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> equals() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "list.contains()"}, {"type": "API", "offset": [4], "text": "equals()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [0], "text": "list.contains()"}, {"type": "API", "offset": [4], "text": "equals()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "list.contains()", "label": "API", "asoc": [["logic constraint", "equals()"]]}, {"span": "equals()", "label": "API", "asoc": []}]}
{"text": "the action specified in stream.foreach is required to be non-interfering", "tokens": ["the", "action", "specified", "in", "stream.foreach", "is", "required", "to", "be", "non-interfering", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> stream.foreach <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "stream.foreach"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "stream.foreach", "label": "API", "asoc": []}]}
{"text": "hashset is much faster than treeset (constant-time versus log-time for most operations like add ,  remove and contains) but offers no ordering guarantees like treeset", "tokens": ["hashset", "is", "much", "faster", "than", "treeset", "(constant-time", "versus", "log-time", "for", "most", "operations", "like", "add", ",", "", "remove", "and", "contains)", "but", "offers", "no", "ordering", "guarantees", "like", "treeset", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hashset <extra_id_0> efficiency comparison <extra_id_5> treeset <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> treeset <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "hashset"}, {"type": "API", "offset": [5], "text": "treeset"}], "relation": [{"type": "efficiency comparison", "args": [{"type": "API", "offset": [0], "text": "hashset"}, {"type": "API", "offset": [5], "text": "treeset"}]}], "event": [], "spot": ["API"], "asoc": ["efficiency comparison"], "spot_asoc": [{"span": "hashset", "label": "API", "asoc": [["efficiency comparison", "treeset"]]}, {"span": "treeset", "label": "API", "asoc": []}]}
{"text": "use the list interface's listiterator() method to get a listiterator object", "tokens": ["use", "the", "list", "interface's", "listiterator()", "method", "to", "get", "a", "listiterator", "object", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> listiterator() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "listiterator()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "listiterator()", "label": "API", "asoc": []}]}
{"text": "system.exit(0) doesn't return ,  and the finally block is not executed", "tokens": ["system.exit(0)", "doesn't", "return", ",", "", "and", "the", "finally", "block", "is", "not", "executed", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.exit(0) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "system.exit(0)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.exit(0)", "label": "API", "asoc": []}]}
{"text": "this way your en masse results gathering will be optimised rather than waiting on the next slow future result in the order of calling get()", "tokens": ["this", "way", "your", "en", "masse", "results", "gathering", "will", "be", "optimised", "rather", "than", "waiting", "on", "the", "next", "slow", "future", "result", "in", "the", "order", "of", "calling", "get()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [24], "text": "get()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "get()", "label": "API", "asoc": []}]}
{"text": "you can remedy this using swingutilities.invokelater from within your run() method; e.g", "tokens": ["you", "can", "remedy", "this", "using", "swingutilities.invokelater", "from", "within", "your", "run()", "method;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> swingutilities.invokelater <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "swingutilities.invokelater"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "swingutilities.invokelater", "label": "API", "asoc": []}]}
{"text": "string is present in package java.lang which is imported by default in all java programs .", "tokens": ["string", "is", "present", "in", "package", "java.lang", "which", "is", "imported", "by", "default", "in", "all", "java", "programs", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "java.lang"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang", "label": "API", "asoc": []}]}
{"text": "converts this date object to a string of the form", "tokens": ["converts", "this", "date", "object", "to", "a", "string", "of", "the", "form", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> date <extra_id_0> type conversion <extra_id_5> string <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "date"}, {"type": "API", "offset": [6], "text": "string"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [2], "text": "date"}, {"type": "API", "offset": [6], "text": "string"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "date", "label": "API", "asoc": [["type conversion", "string"]]}, {"span": "string", "label": "API", "asoc": []}]}
{"text": "would .trim work ?  and if so ,  how would i use that ?  yes ,   trim() will work ,  it will remove leading and trailing spaces from string ,", "tokens": ["would", ".trim", "work", "?", "", "and", "if", "so", ",", "", "how", "would", "i", "use", "that", "?", "", "yes", ",", "", "", "trim()", "will", "work", ",", "", "it", "will", "remove", "leading", "and", "trailing", "spaces", "from", "string", ",", "", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> trim() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "trim()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "trim()", "label": "API", "asoc": []}]}
{"text": "i would argue that arrays.sort() is better for readability .", "tokens": ["i", "would", "argue", "that", "arrays.sort()", "is", "better", "for", "readability", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "arrays.sort()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort()", "label": "API", "asoc": []}]}
{"text": "note that every call to values() returns a newly cloned array which might impact performance in a negative way", "tokens": ["note", "that", "every", "call", "to", "values()", "returns", "a", "newly", "cloned", "array", "which", "might", "impact", "performance", "in", "a", "negative", "way", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> values() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "values()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "values()", "label": "API", "asoc": []}]}
{"text": "you might be able to do this via aspect should you not want to use the java.lang.instrument", "tokens": ["you", "might", "be", "able", "to", "do", "this", "via", "aspect", "should", "you", "not", "want", "to", "use", "the", "java.lang.instrument", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.instrument <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "java.lang.instrument"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.instrument", "label": "API", "asoc": []}]}
{"text": "you have to use the overload of collectors.tomap that accepts a merge function", "tokens": ["you", "have", "to", "use", "the", "overload", "of", "collectors.tomap", "that", "accepts", "a", "merge", "function", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> collectors.tomap <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "collectors.tomap"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "collectors.tomap", "label": "API", "asoc": []}]}
{"text": "while the following approach works and is quite fun ,  in your case it's probably much better to refactor all calls to the thread.sleep into a separate method and add the logging there", "tokens": ["while", "the", "following", "approach", "works", "and", "is", "quite", "fun", ",", "", "in", "your", "case", "it's", "probably", "much", "better", "to", "refactor", "all", "calls", "to", "the", "thread.sleep", "into", "a", "separate", "method", "and", "add", "the", "logging", "there", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [24], "text": "thread.sleep"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep", "label": "API", "asoc": []}]}
{"text": "however ,  examine this example: consider that the first signature of min() allows the call to compile whereas the second does not", "tokens": ["however", ",", "", "examine", "this", "example:", "consider", "that", "the", "first", "signature", "of", "min()", "allows", "the", "call", "to", "compile", "whereas", "the", "second", "does", "not", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> min() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "min()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "min()", "label": "API", "asoc": []}]}
{"text": "to use removeall() ,  you'll have to copy the set then use it", "tokens": ["to", "use", "removeall()", ",", "", "you'll", "have", "to", "copy", "the", "set", "then", "use", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> removeall() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "removeall()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "removeall()", "label": "API", "asoc": []}]}
{"text": "for example ,  this will cause it: in this case you must use the iterator.remove() method instead", "tokens": ["for", "example", ",", "", "this", "will", "cause", "it:", "in", "this", "case", "you", "must", "use", "the", "iterator.remove()", "method", "instead", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> iterator.remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "iterator.remove()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "iterator.remove()", "label": "API", "asoc": []}]}
{"text": "let's take the java.util.function.consumer functional interface as an example", "tokens": ["let's", "take", "the", "java.util.function.consumer", "functional", "interface", "as", "an", "example", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.function.consumer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "java.util.function.consumer"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.function.consumer", "label": "API", "asoc": []}]}
{"text": "now you can use substring() and the like on the data or search it with index ,  run regexp's on it ,  etc", "tokens": ["now", "you", "can", "use", "substring()", "and", "the", "like", "on", "the", "data", "or", "search", "it", "with", "index", ",", "", "run", "regexp's", "on", "it", ",", "", "etc", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> substring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "substring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "substring()", "label": "API", "asoc": []}]}
{"text": "i will show you few examples ,  together with hashcode() of each string and hashcode() of internal char[] value field (i will call it text to distinguish it from string)", "tokens": ["i", "will", "show", "you", "few", "examples", ",", "", "together", "with", "hashcode()", "of", "each", "string", "and", "hashcode()", "of", "internal", "char[]", "value", "field", "(i", "will", "call", "it", "text", "to", "distinguish", "it", "from", "string)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "hashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "hashcode()", "label": "API", "asoc": []}]}
{"text": "use the matcher.replaceall() method to replace all matches in the string", "tokens": ["use", "the", "matcher.replaceall()", "method", "to", "replace", "all", "matches", "in", "the", "string", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> matcher.replaceall() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "matcher.replaceall()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "matcher.replaceall()", "label": "API", "asoc": []}]}
{"text": "and then i set the color using the setcolor() function of the graphics .", "tokens": ["and", "then", "i", "set", "the", "color", "using", "the", "setcolor()", "function", "of", "the", "graphics", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> setcolor() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "setcolor()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "setcolor()", "label": "API", "asoc": []}]}
{"text": "you can do this with the setclip() method in graphics", "tokens": ["you", "can", "do", "this", "with", "the", "setclip()", "method", "in", "graphics", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> setclip() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "setclip()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "setclip()", "label": "API", "asoc": []}]}
{"text": "you have to override the default tostring() method", "tokens": ["you", "have", "to", "override", "the", "default", "tostring()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "you can remove pattern.quote() if you want to use regex ,  but i don't guarantee anything if you do that", "tokens": ["you", "can", "remove", "pattern.quote()", "if", "you", "want", "to", "use", "regex", ",", "", "but", "i", "don't", "guarantee", "anything", "if", "you", "do", "that", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pattern.quote() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pattern.quote()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pattern.quote()", "label": "API", "asoc": []}]}
{"text": "java supports it via nio and very few people are aware of ,  the class in question is abstract but that's no issue: java.nio.channels.spi.abstractinterruptiblechannel", "tokens": ["java", "supports", "it", "via", "nio", "and", "very", "few", "people", "are", "aware", "of", ",", "", "the", "class", "in", "question", "is", "abstract", "but", "that's", "no", "issue:", "java.nio.channels.spi.abstractinterruptiblechannel", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.nio.channels.spi.abstractinterruptiblechannel <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [24], "text": "java.nio.channels.spi.abstractinterruptiblechannel"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.nio.channels.spi.abstractinterruptiblechannel", "label": "API", "asoc": []}]}
{"text": "to use the pattern attribute in current version of jasper-report for date/time object you need a java.util.date class or one of it's subclasses", "tokens": ["to", "use", "the", "pattern", "attribute", "in", "current", "version", "of", "jasper-report", "for", "date/time", "object", "you", "need", "a", "java.util.date", "class", "or", "one", "of", "it's", "subclasses", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.date <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "java.util.date"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.date", "label": "API", "asoc": []}]}
{"text": "however ,  the tostring() method is still looking at the instance's version of the var variable", "tokens": ["however", ",", "", "the", "tostring()", "method", "is", "still", "looking", "at", "the", "instance's", "version", "of", "the", "var", "variable", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "now ,  let's take a look at the implementation of emptylist() : this implementation doesn't need the parameter t at all", "tokens": ["now", ",", "", "let's", "take", "a", "look", "at", "the", "implementation", "of", "emptylist()", ":", "this", "implementation", "doesn't", "need", "the", "parameter", "t", "at", "all", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> emptylist() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "emptylist()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "emptylist()", "label": "API", "asoc": []}]}
{"text": "and it does have a reachable reference until (at least) the point at which the start() call returns", "tokens": ["and", "it", "does", "have", "a", "reachable", "reference", "until", "(at", "least)", "the", "point", "at", "which", "the", "start()", "call", "returns", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> start() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "start()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "start()", "label": "API", "asoc": []}]}
{"text": "you need to call next() ; when you get the error", "tokens": ["you", "need", "to", "call", "next()", ";", "when", "you", "get", "the", "error", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "next()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "next()", "label": "API", "asoc": []}]}
{"text": "the equals() method checks for value equality ,  which means that it compares the contents of two objects .", "tokens": ["the", "equals()", "method", "checks", "for", "value", "equality", ",", "", "which", "means", "that", "it", "compares", "the", "contents", "of", "two", "objects", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "equals()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": []}]}
{"text": "everything you want to know can be found within the java.util.stream javadoc", "tokens": ["everything", "you", "want", "to", "know", "can", "be", "found", "within", "the", "java.util.stream", "javadoc", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.stream <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "java.util.stream"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.stream", "label": "API", "asoc": []}]}
{"text": "the parent container's layout or pack() may be involved", "tokens": ["the", "parent", "container's", "layout", "or", "pack()", "may", "be", "involved", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pack() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "pack()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pack()", "label": "API", "asoc": []}]}
{"text": "here is the createimage() method of gifanim", "tokens": ["here", "is", "the", "createimage()", "method", "of", "gifanim", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> createimage() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "createimage()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "createimage()", "label": "API", "asoc": []}]}
{"text": "use the arrays.sort() method: output: here the third element of the array \"is\" should be \"is\" ,  otherwise it will come in last after sorting", "tokens": ["use", "the", "arrays.sort()", "method:", "output:", "here", "the", "third", "element", "of", "the", "array", "\"is\"", "should", "be", "\"is\"", ",", "", "otherwise", "it", "will", "come", "in", "last", "after", "sorting", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "arrays.sort()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort()", "label": "API", "asoc": []}]}
{"text": "you get a java.lang.class from that by accessing its java property", "tokens": ["you", "get", "a", "java.lang.class", "from", "that", "by", "accessing", "its", "java", "property", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.class <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "java.lang.class"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.class", "label": "API", "asoc": []}]}
{"text": "the implementation in object.clone() doesn't call a constructor", "tokens": ["the", "implementation", "in", "object.clone()", "doesn't", "call", "a", "constructor", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> object.clone() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "object.clone()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "object.clone()", "label": "API", "asoc": []}]}
{"text": "here's the working code: add an import java.util.concurrent.timeunit", "tokens": ["here's", "the", "working", "code:", "add", "an", "import", "java.util.concurrent.timeunit", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.concurrent.timeunit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "java.util.concurrent.timeunit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.concurrent.timeunit", "label": "API", "asoc": []}]}
{"text": "nextline() automatically moves the scanner down after returning the current line", "tokens": ["nextline()", "automatically", "moves", "the", "scanner", "down", "after", "returning", "the", "current", "line", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextline() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "nextline()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nextline()", "label": "API", "asoc": []}]}
{"text": "math.random() returns a double value between 0 (inclusive) and 1 (exclusive)", "tokens": ["math.random()", "returns", "a", "double", "value", "between", "0", "(inclusive)", "and", "1", "(exclusive)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> math.random() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "math.random()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "math.random()", "label": "API", "asoc": []}]}
{"text": "if you look at size() method in alarmmanagerservice.batch.class ,  it never should be a null", "tokens": ["if", "you", "look", "at", "size()", "method", "in", "alarmmanagerservice.batch.class", ",", "", "it", "never", "should", "be", "a", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> size() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "size()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "size()", "label": "API", "asoc": []}]}
{"text": "you could use a randomaccessfile anywhere where you could use a datainput", "tokens": ["you", "could", "use", "a", "randomaccessfile", "anywhere", "where", "you", "could", "use", "a", "datainput", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> randomaccessfile <extra_id_0> function similarity <extra_id_5> datainput <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> datainput <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "randomaccessfile"}, {"type": "API", "offset": [11], "text": "datainput"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [4], "text": "randomaccessfile"}, {"type": "API", "offset": [11], "text": "datainput"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "randomaccessfile", "label": "API", "asoc": [["function similarity", "datainput"]]}, {"span": "datainput", "label": "API", "asoc": []}]}
{"text": "since these are iterables ,  you can call the iterator() method more than once", "tokens": ["since", "these", "are", "iterables", ",", "", "you", "can", "call", "the", "iterator()", "method", "more", "than", "once", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> iterator() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "iterator()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "iterator()", "label": "API", "asoc": []}]}
{"text": "linear time for the remove(object)", "tokens": ["linear", "time", "for", "the", "remove(object)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove(object) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "remove(object)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove(object)", "label": "API", "asoc": []}]}
{"text": "i am use the scanner method nextint() and nextline() for reading input .", "tokens": ["i", "am", "use", "the", "scanner", "method", "nextint()", "and", "nextline()", "for", "reading", "input", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextint() <extra_id_0> function collaboration <extra_id_5> nextline() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> nextline() <extra_id_1> <extra_id_0> API <extra_id_5> scanner <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "nextint()"}, {"type": "API", "offset": [8], "text": "nextline()"}, {"type": "API", "offset": [4], "text": "scanner"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [6], "text": "nextint()"}, {"type": "API", "offset": [8], "text": "nextline()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "nextint()", "label": "API", "asoc": [["function collaboration", "nextline()"]]}, {"span": "nextline()", "label": "API", "asoc": []}, {"span": "scanner", "label": "API", "asoc": []}]}
{"text": "when you pass primitive array to arrays.stream ,  the following code is invoked and when you pass primitive array to stream.of the following code is invoked hence you get different results", "tokens": ["when", "you", "pass", "primitive", "array", "to", "arrays.stream", ",", "", "the", "following", "code", "is", "invoked", "and", "when", "you", "pass", "primitive", "array", "to", "stream.of", "the", "following", "code", "is", "invoked", "hence", "you", "get", "different", "results", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.stream <extra_id_0> behavior difference <extra_id_5> stream.of <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> stream.of <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "arrays.stream"}, {"type": "API", "offset": [21], "text": "stream.of"}], "relation": [{"type": "behavior difference", "args": [{"type": "API", "offset": [6], "text": "arrays.stream"}, {"type": "API", "offset": [21], "text": "stream.of"}]}], "event": [], "spot": ["API"], "asoc": ["behavior difference"], "spot_asoc": [{"span": "arrays.stream", "label": "API", "asoc": [["behavior difference", "stream.of"]]}, {"span": "stream.of", "label": "API", "asoc": []}]}
{"text": "you need to use the java.net.url and java.net.urlconnection classes", "tokens": ["you", "need", "to", "use", "the", "java.net.url", "and", "java.net.urlconnection", "classes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.net.url <extra_id_0> function collaboration <extra_id_5> java.net.urlconnection <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> java.net.urlconnection <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "java.net.url"}, {"type": "API", "offset": [7], "text": "java.net.urlconnection"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [5], "text": "java.net.url"}, {"type": "API", "offset": [7], "text": "java.net.urlconnection"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "java.net.url", "label": "API", "asoc": [["function collaboration", "java.net.urlconnection"]]}, {"span": "java.net.urlconnection", "label": "API", "asoc": []}]}
{"text": "let's try to understand it with an example of what would happen if we override equals() without overriding hashcode() and attempt to use a map", "tokens": ["let's", "try", "to", "understand", "it", "with", "an", "example", "of", "what", "would", "happen", "if", "we", "override", "equals()", "without", "overriding", "hashcode()", "and", "attempt", "to", "use", "a", "map", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_0> logic constraint <extra_id_5> hashcode() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> hashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "equals()"}, {"type": "API", "offset": [18], "text": "hashcode()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [15], "text": "equals()"}, {"type": "API", "offset": [18], "text": "hashcode()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": [["logic constraint", "hashcode()"]]}, {"span": "hashcode()", "label": "API", "asoc": []}]}
{"text": "walkfiletree uses the files.readattributes  which turns to the current provider in play: windowsfilesystemprovider.readattributes to determine if a path is a directory", "tokens": ["walkfiletree", "uses", "the", "files.readattributes", "", "which", "turns", "to", "the", "current", "provider", "in", "play:", "windowsfilesystemprovider.readattributes", "to", "determine", "if", "a", "path", "is", "a", "directory", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> walkfiletree <extra_id_0> logic constraint <extra_id_5> files.readattributes <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> files.readattributes <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "walkfiletree"}, {"type": "API", "offset": [3], "text": "files.readattributes"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [0], "text": "walkfiletree"}, {"type": "API", "offset": [3], "text": "files.readattributes"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "walkfiletree", "label": "API", "asoc": [["logic constraint", "files.readattributes"]]}, {"span": "files.readattributes", "label": "API", "asoc": []}]}
{"text": "socket.isconnected() only tells you about the state of the socket", "tokens": ["socket.isconnected()", "only", "tells", "you", "about", "the", "state", "of", "the", "socket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> socket.isconnected() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "socket.isconnected()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "socket.isconnected()", "label": "API", "asoc": []}]}
{"text": "java.util.queue is an interface so you cannot instantiate it directly", "tokens": ["java.util.queue", "is", "an", "interface", "so", "you", "cannot", "instantiate", "it", "directly", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.queue <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "java.util.queue"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.queue", "label": "API", "asoc": []}]}
{"text": "your thread is finishing immediately because it does not have a run() method defined so it is started and finishes", "tokens": ["your", "thread", "is", "finishing", "immediately", "because", "it", "does", "not", "have", "a", "run()", "method", "defined", "so", "it", "is", "started", "and", "finishes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> run() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "run()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "run()", "label": "API", "asoc": []}]}
{"text": "enqueue() is explicitly for making an asychronous call .", "tokens": ["enqueue()", "is", "explicitly", "for", "making", "an", "asychronous", "call", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> enqueue() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "enqueue()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "enqueue()", "label": "API", "asoc": []}]}
{"text": "java.util.arrays.arraylist is a different class than java.util.arraylist .", "tokens": ["java.util.arrays.arraylist", "is", "a", "different", "class", "than", "java.util.arraylist", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.arrays.arraylist <extra_id_0> behavior difference <extra_id_5> java.util.arraylist <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> java.util.arraylist <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "java.util.arrays.arraylist"}, {"type": "API", "offset": [6], "text": "java.util.arraylist"}], "relation": [{"type": "behavior difference", "args": [{"type": "API", "offset": [0], "text": "java.util.arrays.arraylist"}, {"type": "API", "offset": [6], "text": "java.util.arraylist"}]}], "event": [], "spot": ["API"], "asoc": ["behavior difference"], "spot_asoc": [{"span": "java.util.arrays.arraylist", "label": "API", "asoc": [["behavior difference", "java.util.arraylist"]]}, {"span": "java.util.arraylist", "label": "API", "asoc": []}]}
{"text": "however ,  i think that is less likely since you experience it on arraylist.add", "tokens": ["however", ",", "", "i", "think", "that", "is", "less", "likely", "since", "you", "experience", "it", "on", "arraylist.add", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arraylist.add <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "arraylist.add"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arraylist.add", "label": "API", "asoc": []}]}
{"text": "it also gets along with only a single system call that hides behind files.readallbytes", "tokens": ["it", "also", "gets", "along", "with", "only", "a", "single", "system", "call", "that", "hides", "behind", "files.readallbytes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> files.readallbytes <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "files.readallbytes"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "files.readallbytes", "label": "API", "asoc": []}]}
{"text": "the tostring() method was designed to return a readable representation of an object ,  not a full representation", "tokens": ["the", "tostring()", "method", "was", "designed", "to", "return", "a", "readable", "representation", "of", "an", "object", ",", "", "not", "a", "full", "representation", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "but in fact findfirst() drives the whole operation ,  so it efficiently stops after finding one item", "tokens": ["but", "in", "fact", "findfirst()", "drives", "the", "whole", "operation", ",", "", "so", "it", "efficiently", "stops", "after", "finding", "one", "item", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> findfirst() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "findfirst()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "findfirst()", "label": "API", "asoc": []}]}
{"text": "supplying the second parameter as true tells the filewriter that you want to append to the end of it .", "tokens": ["supplying", "the", "second", "parameter", "as", "true", "tells", "the", "filewriter", "that", "you", "want", "to", "append", "to", "the", "end", "of", "it", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> filewriter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "filewriter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "filewriter", "label": "API", "asoc": []}]}
{"text": "if you need consistent ordering ,  you can use linkedhashmap (for insertion/access order) ,  or treemap (for comparision order)", "tokens": ["if", "you", "need", "consistent", "ordering", ",", "", "you", "can", "use", "linkedhashmap", "(for", "insertion/access", "order)", ",", "", "or", "treemap", "(for", "comparision", "order)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> linkedhashmap <extra_id_0> function similarity <extra_id_5> treemap <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> treemap <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "linkedhashmap"}, {"type": "API", "offset": [17], "text": "treemap"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [10], "text": "linkedhashmap"}, {"type": "API", "offset": [17], "text": "treemap"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "linkedhashmap", "label": "API", "asoc": [["function similarity", "treemap"]]}, {"span": "treemap", "label": "API", "asoc": []}]}
{"text": "use this function for delays if you do not use thread.interrupt() ,  as it will preserve the interrupted state of the thread .", "tokens": ["use", "this", "function", "for", "delays", "if", "you", "do", "not", "use", "thread.interrupt()", ",", "", "as", "it", "will", "preserve", "the", "interrupted", "state", "of", "the", "thread", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.interrupt() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "thread.interrupt()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.interrupt()", "label": "API", "asoc": []}]}
{"text": "use the keys() iterator to iterate over all the properties ,  and call get() for each .", "tokens": ["use", "the", "keys()", "iterator", "to", "iterate", "over", "all", "the", "properties", ",", "", "and", "call", "get()", "for", "each", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> keys() <extra_id_0> logic constraint <extra_id_5> get() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "keys()"}, {"type": "API", "offset": [14], "text": "get()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [2], "text": "keys()"}, {"type": "API", "offset": [14], "text": "get()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "keys()", "label": "API", "asoc": [["logic constraint", "get()"]]}, {"span": "get()", "label": "API", "asoc": []}]}
{"text": "you can use a java.util.set instead of an array as it is guaranteed to have only unique elements", "tokens": ["you", "can", "use", "a", "java.util.set", "instead", "of", "an", "array", "as", "it", "is", "guaranteed", "to", "have", "only", "unique", "elements", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.set <extra_id_0> function replace <extra_id_5> array <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> array <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "java.util.set"}, {"type": "API", "offset": [8], "text": "array"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [4], "text": "java.util.set"}, {"type": "API", "offset": [8], "text": "array"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "java.util.set", "label": "API", "asoc": [["function replace", "array"]]}, {"span": "array", "label": "API", "asoc": []}]}
{"text": "java.util.arrays contains a bunch of static methods", "tokens": ["java.util.arrays", "contains", "a", "bunch", "of", "static", "methods", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.arrays <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "java.util.arrays"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.arrays", "label": "API", "asoc": []}]}
{"text": "i wanted to point out that java.util.objects has a nice method for this in a broad case ,  so you can do this: which will clear out your null objects", "tokens": ["i", "wanted", "to", "point", "out", "that", "java.util.objects", "has", "a", "nice", "method", "for", "this", "in", "a", "broad", "case", ",", "", "so", "you", "can", "do", "this:", "which", "will", "clear", "out", "your", "null", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.objects <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "java.util.objects"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.objects", "label": "API", "asoc": []}]}
{"text": "the api docs for the java.lang.process class say: the created subprocess does not have its own terminal or console", "tokens": ["the", "api", "docs", "for", "the", "java.lang.process", "class", "say:", "the", "created", "subprocess", "does", "not", "have", "its", "own", "terminal", "or", "console", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.process <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "java.lang.process"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.process", "label": "API", "asoc": []}]}
{"text": "the method getgridbutton() shows how to obtain a button reference efficiently based on its grid coordinates ,  and the action listener shows that the clicked and found buttons are identical", "tokens": ["the", "method", "getgridbutton()", "shows", "how", "to", "obtain", "a", "button", "reference", "efficiently", "based", "on", "its", "grid", "coordinates", ",", "", "and", "the", "action", "listener", "shows", "that", "the", "clicked", "and", "found", "buttons", "are", "identical", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getgridbutton() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "getgridbutton()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getgridbutton()", "label": "API", "asoc": []}]}
{"text": "calling notify() puts one of the threads (if any) from the wait queue (waiting for the condition) into the blocked queue (waiting for the lock)", "tokens": ["calling", "notify()", "puts", "one", "of", "the", "threads", "(if", "any)", "from", "the", "wait", "queue", "(waiting", "for", "the", "condition)", "into", "the", "blocked", "queue", "(waiting", "for", "the", "lock)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> notify() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "notify()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "notify()", "label": "API", "asoc": []}]}
{"text": "if you really want to use hasnext() ,  or would like to ,  you could create another scanner object", "tokens": ["if", "you", "really", "want", "to", "use", "hasnext()", ",", "", "or", "would", "like", "to", ",", "", "you", "could", "create", "another", "scanner", "object", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hasnext() <extra_id_0> logic constraint <extra_id_5> scanner <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> scanner <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "hasnext()"}, {"type": "API", "offset": [19], "text": "scanner"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [6], "text": "hasnext()"}, {"type": "API", "offset": [19], "text": "scanner"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "hasnext()", "label": "API", "asoc": [["logic constraint", "scanner"]]}, {"span": "scanner", "label": "API", "asoc": []}]}
{"text": "this file contains the name of the jdbc drivers implementation of java.sql.driver", "tokens": ["this", "file", "contains", "the", "name", "of", "the", "jdbc", "drivers", "implementation", "of", "java.sql.driver", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.sql.driver <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "java.sql.driver"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.sql.driver", "label": "API", "asoc": []}]}
{"text": "that string is produced by the default object.tostring() method", "tokens": ["that", "string", "is", "produced", "by", "the", "default", "object.tostring()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> object.tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "object.tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "object.tostring()", "label": "API", "asoc": []}]}
{"text": "i recommend you check your format strings with the documentation if simpledateformat .", "tokens": ["i", "recommend", "you", "check", "your", "format", "strings", "with", "the", "documentation", "if", "simpledateformat", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> simpledateformat <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "simpledateformat"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "simpledateformat", "label": "API", "asoc": []}]}
{"text": "the reason for your problem is that following the preceding nextint() ,  you're still on the same line ,  and nextline() returns the rest of the current line", "tokens": ["the", "reason", "for", "your", "problem", "is", "that", "following", "the", "preceding", "nextint()", ",", "", "you're", "still", "on", "the", "same", "line", ",", "", "and", "nextline()", "returns", "the", "rest", "of", "the", "current", "line", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextint() <extra_id_0> logic constraint <extra_id_5> nextline() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> nextline() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "nextint()"}, {"type": "API", "offset": [22], "text": "nextline()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [10], "text": "nextint()"}, {"type": "API", "offset": [22], "text": "nextline()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "nextint()", "label": "API", "asoc": [["logic constraint", "nextline()"]]}, {"span": "nextline()", "label": "API", "asoc": []}]}
{"text": "the reflection tutorial suggest the use of class.isassignablefrom() sample for finding print(string)", "tokens": ["the", "reflection", "tutorial", "suggest", "the", "use", "of", "class.isassignablefrom()", "sample", "for", "finding", "print(string)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> class.isassignablefrom() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "class.isassignablefrom()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "class.isassignablefrom()", "label": "API", "asoc": []}]}
{"text": "in fact ,  if you look at the source of double.compare() ,  you will find that it's slightly more complicated than you might think", "tokens": ["in", "fact", ",", "", "if", "you", "look", "at", "the", "source", "of", "double.compare()", ",", "", "you", "will", "find", "that", "it's", "slightly", "more", "complicated", "than", "you", "might", "think", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> double.compare() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "double.compare()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "double.compare()", "label": "API", "asoc": []}]}
{"text": "you are right in that the tostring() method will just return the unformatted string contents of the hssfrichtextstring", "tokens": ["you", "are", "right", "in", "that", "the", "tostring()", "method", "will", "just", "return", "the", "unformatted", "string", "contents", "of", "the", "hssfrichtextstring", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "the interrupt() method sets an interrupt flag", "tokens": ["the", "interrupt()", "method", "sets", "an", "interrupt", "flag", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> interrupt() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "interrupt()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "interrupt()", "label": "API", "asoc": []}]}
{"text": "linkedlist and arraylist are two different implementations of the list interface .", "tokens": ["linkedlist", "and", "arraylist", "are", "two", "different", "implementations", "of", "the", "list", "interface", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> linkedlist <extra_id_0> behavior difference <extra_id_5> arraylist <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> arraylist <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "linkedlist"}, {"type": "API", "offset": [2], "text": "arraylist"}], "relation": [{"type": "behavior difference", "args": [{"type": "API", "offset": [0], "text": "linkedlist"}, {"type": "API", "offset": [2], "text": "arraylist"}]}], "event": [], "spot": ["API"], "asoc": ["behavior difference"], "spot_asoc": [{"span": "linkedlist", "label": "API", "asoc": [["behavior difference", "arraylist"]]}, {"span": "arraylist", "label": "API", "asoc": []}]}
{"text": "according to the documentation for file.listfiles() ,  it will return null if the file is not a directory", "tokens": ["according", "to", "the", "documentation", "for", "file.listfiles()", ",", "", "it", "will", "return", "null", "if", "the", "file", "is", "not", "a", "directory", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.listfiles() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "file.listfiles()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.listfiles()", "label": "API", "asoc": []}]}
{"text": "if you want a one-shot alarm ,  you would just use set()", "tokens": ["if", "you", "want", "a", "one-shot", "alarm", ",", "", "you", "would", "just", "use", "set()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> set() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "set()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "set()", "label": "API", "asoc": []}]}
{"text": "i would recommend using the java.time package ,  which has a precision of nanoseconds ,  like your input", "tokens": ["i", "would", "recommend", "using", "the", "java.time", "package", ",", "", "which", "has", "a", "precision", "of", "nanoseconds", ",", "", "like", "your", "input", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "java.time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.time", "label": "API", "asoc": []}]}
{"text": "override the object.equals and object.hashcode methods in the fraction class", "tokens": ["override", "the", "object.equals", "and", "object.hashcode", "methods", "in", "the", "fraction", "class", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> object.equals <extra_id_0> function collaboration <extra_id_5> object.hashcode <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> object.hashcode <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "object.equals"}, {"type": "API", "offset": [4], "text": "object.hashcode"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [2], "text": "object.equals"}, {"type": "API", "offset": [4], "text": "object.hashcode"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "object.equals", "label": "API", "asoc": [["function collaboration", "object.hashcode"]]}, {"span": "object.hashcode", "label": "API", "asoc": []}]}
{"text": "sets the designated parameter to the given java.sql.timestamp value ,  using the given calendar object .", "tokens": ["sets", "the", "designated", "parameter", "to", "the", "given", "java.sql.timestamp", "value", ",", "", "using", "the", "given", "calendar", "object", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.sql.timestamp <extra_id_0> logic constraint <extra_id_5> calendar <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> calendar <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "java.sql.timestamp"}, {"type": "API", "offset": [14], "text": "calendar"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [7], "text": "java.sql.timestamp"}, {"type": "API", "offset": [14], "text": "calendar"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "java.sql.timestamp", "label": "API", "asoc": [["logic constraint", "calendar"]]}, {"span": "calendar", "label": "API", "asoc": []}]}
{"text": "if your class happens to not override equals ,  then it will use object.equals that ends using java == for equality check", "tokens": ["if", "your", "class", "happens", "to", "not", "override", "equals", ",", "", "then", "it", "will", "use", "object.equals", "that", "ends", "using", "java", "==", "for", "equality", "check", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> object.equals <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "object.equals"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "object.equals", "label": "API", "asoc": []}]}
{"text": "moving onto comparing the stringbuilder and string.join", "tokens": ["moving", "onto", "comparing", "the", "stringbuilder", "and", "string.join", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> stringbuilder <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "stringbuilder"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "stringbuilder", "label": "API", "asoc": []}]}
{"text": "you can use java inbuilt method java.net.urlencoder to construct url with param data", "tokens": ["you", "can", "use", "java", "inbuilt", "method", "java.net.urlencoder", "to", "construct", "url", "with", "param", "data", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.net.urlencoder <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "java.net.urlencoder"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.net.urlencoder", "label": "API", "asoc": []}]}
{"text": "when the beginning of a string matches the regex pattern in string.split() ,  it results in an additional empty string", "tokens": ["when", "the", "beginning", "of", "a", "string", "matches", "the", "regex", "pattern", "in", "string.split()", ",", "", "it", "results", "in", "an", "additional", "empty", "string", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.split() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "string.split()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.split()", "label": "API", "asoc": []}]}
{"text": "you haven't said what you expect it to be ,  but i suspect you wanted august ( which is month 7 in java.util.calendar )", "tokens": ["you", "haven't", "said", "what", "you", "expect", "it", "to", "be", ",", "", "but", "i", "suspect", "you", "wanted", "august", "(", "which", "is", "month", "7", "in", "java.util.calendar", ")", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.calendar <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "java.util.calendar"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.calendar", "label": "API", "asoc": []}]}
{"text": "finally ,  you could avoid the need to declare a local variable in the take() method by using try {} finally {}", "tokens": ["finally", ",", "", "you", "could", "avoid", "the", "need", "to", "declare", "a", "local", "variable", "in", "the", "take()", "method", "by", "using", "try", "{}", "finally", "{}", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> take() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "take()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "take()", "label": "API", "asoc": []}]}
{"text": "btw to make your code cleaner and avoid expensive operations like creating exceptions you should use methods like hasnextint()", "tokens": ["btw", "to", "make", "your", "code", "cleaner", "and", "avoid", "expensive", "operations", "like", "creating", "exceptions", "you", "should", "use", "methods", "like", "hasnextint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hasnextint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "hasnextint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "hasnextint()", "label": "API", "asoc": []}]}
{"text": "if you look at the source ,  you see that writeobject() does not save the backing array", "tokens": ["if", "you", "look", "at", "the", "source", ",", "", "you", "see", "that", "writeobject()", "does", "not", "save", "the", "backing", "array", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> writeobject() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "writeobject()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "writeobject()", "label": "API", "asoc": []}]}
{"text": "the repaint() refreshes the view (component) ,  so whenever you make any change on the component ,  you must call it", "tokens": ["the", "repaint()", "refreshes", "the", "view", "(component)", ",", "", "so", "whenever", "you", "make", "any", "change", "on", "the", "component", ",", "", "you", "must", "call", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "you can rewrite the code of run() method like this:", "tokens": ["you", "can", "rewrite", "the", "code", "of", "run()", "method", "like", "this:", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> run() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "run()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "run()", "label": "API", "asoc": []}]}
{"text": "random.nextdouble() uses random.next() twice to generate a double that has approximately uniformly distributed bits in its mantissa ,  so it is uniformly distributed in the range 0 to 1-(2^-53)", "tokens": ["random.nextdouble()", "uses", "random.next()", "twice", "to", "generate", "a", "double", "that", "has", "approximately", "uniformly", "distributed", "bits", "in", "its", "mantissa", ",", "", "so", "it", "is", "uniformly", "distributed", "in", "the", "range", "0", "to", "1-(2^-53)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> random.nextdouble() <extra_id_0> logic constraint <extra_id_5> random.next() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> random.next() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "random.nextdouble()"}, {"type": "API", "offset": [2], "text": "random.next()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [0], "text": "random.nextdouble()"}, {"type": "API", "offset": [2], "text": "random.next()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "random.nextdouble()", "label": "API", "asoc": [["logic constraint", "random.next()"]]}, {"span": "random.next()", "label": "API", "asoc": []}]}
{"text": "by utilising a single javax.swing.timer it should be more capable of supporting a growing number of random balls", "tokens": ["by", "utilising", "a", "single", "javax.swing.timer", "it", "should", "be", "more", "capable", "of", "supporting", "a", "growing", "number", "of", "random", "balls", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> javax.swing.timer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "javax.swing.timer"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "javax.swing.timer", "label": "API", "asoc": []}]}
{"text": "there is a bug in xp where the os call system.nanotime() uses is not consistent between sockets so as the thread switches which socket it is running on ,  you can expect to see this jumping around", "tokens": ["there", "is", "a", "bug", "in", "xp", "where", "the", "os", "call", "system.nanotime()", "uses", "is", "not", "consistent", "between", "sockets", "so", "as", "the", "thread", "switches", "which", "socket", "it", "is", "running", "on", ",", "", "you", "can", "expect", "to", "see", "this", "jumping", "around", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.nanotime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "system.nanotime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.nanotime()", "label": "API", "asoc": []}]}
{"text": "for others with the same error (does not answer this exact question) i experienced this error with hibernate 4.3 and 5.0.5 due to fields of type java.time.localdatetime", "tokens": ["for", "others", "with", "the", "same", "error", "(does", "not", "answer", "this", "exact", "question)", "i", "experienced", "this", "error", "with", "hibernate", "4.3", "and", "5.0.5", "due", "to", "fields", "of", "type", "java.time.localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.time.localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [26], "text": "java.time.localdatetime"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.time.localdatetime", "label": "API", "asoc": []}]}
{"text": "for sorting primarily by age ,  and then by name in case of ties: combine that with arrays.sort ,  and you are done .", "tokens": ["for", "sorting", "primarily", "by", "age", ",", "", "and", "then", "by", "name", "in", "case", "of", "ties:", "combine", "that", "with", "arrays.sort", ",", "", "and", "you", "are", "done", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "arrays.sort"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort", "label": "API", "asoc": []}]}
{"text": "to elaborate further on the difference between a cachedthreadpool and a fixedthreadpool", "tokens": ["to", "elaborate", "further", "on", "the", "difference", "between", "a", "cachedthreadpool", "and", "a", "fixedthreadpool", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> cachedthreadpool <extra_id_0> behavior difference <extra_id_5> fixedthreadpool <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> fixedthreadpool <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "cachedthreadpool"}, {"type": "API", "offset": [11], "text": "fixedthreadpool"}], "relation": [{"type": "behavior difference", "args": [{"type": "API", "offset": [8], "text": "cachedthreadpool"}, {"type": "API", "offset": [11], "text": "fixedthreadpool"}]}], "event": [], "spot": ["API"], "asoc": ["behavior difference"], "spot_asoc": [{"span": "cachedthreadpool", "label": "API", "asoc": [["behavior difference", "fixedthreadpool"]]}, {"span": "fixedthreadpool", "label": "API", "asoc": []}]}
{"text": "the exception in your stacktrace says which essentially means that getcolumnindex() could not find the specified column in the cursor and -1 was returned as column index", "tokens": ["the", "exception", "in", "your", "stacktrace", "says", "which", "essentially", "means", "that", "getcolumnindex()", "could", "not", "find", "the", "specified", "column", "in", "the", "cursor", "and", "-1", "was", "returned", "as", "column", "index", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumnindex() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolumnindex()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumnindex()", "label": "API", "asoc": []}]}
{"text": "the majority of questions about java.util.scanner are of the how can i get my program to quit when i enter some specific input category", "tokens": ["the", "majority", "of", "questions", "about", "java.util.scanner", "are", "of", "the", "how", "can", "i", "get", "my", "program", "to", "quit", "when", "i", "enter", "some", "specific", "input", "category", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.scanner <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "java.util.scanner"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.scanner", "label": "API", "asoc": []}]}
{"text": "as you can see ,  it doesn't make your transactions actually read-only since you still can persist changes by calling flush() manually", "tokens": ["as", "you", "can", "see", ",", "", "it", "doesn't", "make", "your", "transactions", "actually", "read-only", "since", "you", "still", "can", "persist", "changes", "by", "calling", "flush()", "manually", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> flush() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "flush()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "flush()", "label": "API", "asoc": []}]}
{"text": "the repaint() method just adds a paint request to the repaintmanager", "tokens": ["the", "repaint()", "method", "just", "adds", "a", "paint", "request", "to", "the", "repaintmanager", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "in hotspot jvm by default on the first invocation of non-overloaded object.hashcode or system.identityhashcode a random number is generated and stored in the object header", "tokens": ["in", "hotspot", "jvm", "by", "default", "on", "the", "first", "invocation", "of", "non-overloaded", "object.hashcode", "or", "system.identityhashcode", "a", "random", "number", "is", "generated", "and", "stored", "in", "the", "object", "header", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> object.hashcode <extra_id_0> function similarity <extra_id_5> system.identityhashcode <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> system.identityhashcode <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "object.hashcode"}, {"type": "API", "offset": [13], "text": "system.identityhashcode"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [11], "text": "object.hashcode"}, {"type": "API", "offset": [13], "text": "system.identityhashcode"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "object.hashcode", "label": "API", "asoc": [["function similarity", "system.identityhashcode"]]}, {"span": "system.identityhashcode", "label": "API", "asoc": []}]}
{"text": "using next() will only return what comes before the delimiter (defaults to whitespace)", "tokens": ["using", "next()", "will", "only", "return", "what", "comes", "before", "the", "delimiter", "(defaults", "to", "whitespace)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "next()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "next()", "label": "API", "asoc": []}]}
{"text": "you will need to prevent close() from being called somehow", "tokens": ["you", "will", "need", "to", "prevent", "close()", "from", "being", "called", "somehow", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> close() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "close()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "close()", "label": "API", "asoc": []}]}
{"text": "in this case you need to request such a synchronization explicitly by calling refresh() .", "tokens": ["in", "this", "case", "you", "need", "to", "request", "such", "a", "synchronization", "explicitly", "by", "calling", "refresh()", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> refresh() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "refresh()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "refresh()", "label": "API", "asoc": []}]}
{"text": "the method  as you can see it uses either getcolor() or getselectioncolor()", "tokens": ["the", "method", "", "as", "you", "can", "see", "it", "uses", "either", "getcolor()", "or", "getselectioncolor()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolor() <extra_id_0> function similarity <extra_id_5> getselectioncolor() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> getselectioncolor() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolor()"}, {"type": "API", "offset": [12], "text": "getselectioncolor()"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [10], "text": "getcolor()"}, {"type": "API", "offset": [12], "text": "getselectioncolor()"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "getcolor()", "label": "API", "asoc": [["function similarity", "getselectioncolor()"]]}, {"span": "getselectioncolor()", "label": "API", "asoc": []}]}
{"text": "but most likely ,  you'll need to get real familiar with java.util.formatter", "tokens": ["but", "most", "likely", ",", "", "you'll", "need", "to", "get", "real", "familiar", "with", "java.util.formatter", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.formatter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "java.util.formatter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.formatter", "label": "API", "asoc": []}]}
{"text": "so try checking exists() before you do anything with the file .", "tokens": ["so", "try", "checking", "exists()", "before", "you", "do", "anything", "with", "the", "file", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> exists() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "exists()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "exists()", "label": "API", "asoc": []}]}
{"text": "from the source code of java.util.random", "tokens": ["from", "the", "source", "code", "of", "java.util.random", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "java.util.random"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.random", "label": "API", "asoc": []}]}
{"text": "one thing you could do is use nextline() instead ,  then explicitly try and parse the returned string into an integer", "tokens": ["one", "thing", "you", "could", "do", "is", "use", "nextline()", "instead", ",", "", "then", "explicitly", "try", "and", "parse", "the", "returned", "string", "into", "an", "integer", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextline() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "nextline()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nextline()", "label": "API", "asoc": []}]}
{"text": "collections.sort method takes two parameters", "tokens": ["collections.sort", "method", "takes", "two", "parameters", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> collections.sort <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "collections.sort"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "collections.sort", "label": "API", "asoc": []}]}
{"text": "well ,  the api for integer.valueof(string) does indeed say that the string is interpreted exactly as if it were given to integer.parseint(string)", "tokens": ["well", ",", "", "the", "api", "for", "integer.valueof(string)", "does", "indeed", "say", "that", "the", "string", "is", "interpreted", "exactly", "as", "if", "it", "were", "given", "to", "integer.parseint(string)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> integer.valueof(string) <extra_id_0> function similarity <extra_id_5> integer.parseint(string) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> integer.parseint(string) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "integer.valueof(string)"}, {"type": "API", "offset": [22], "text": "integer.parseint(string)"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [6], "text": "integer.valueof(string)"}, {"type": "API", "offset": [22], "text": "integer.parseint(string)"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "integer.valueof(string)", "label": "API", "asoc": [["function similarity", "integer.parseint(string)"]]}, {"span": "integer.parseint(string)", "label": "API", "asoc": []}]}
{"text": "if you want this \"as a string\" ,  the closest thing is to call tostring() on the jsonobject location", "tokens": ["if", "you", "want", "this", "\"as", "a", "string\"", ",", "", "the", "closest", "thing", "is", "to", "call", "tostring()", "on", "the", "jsonobject", "location", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "alternatively ,  use getresource() and the createimage() method that takes an url parameter .", "tokens": ["alternatively", ",", "", "use", "getresource()", "and", "the", "createimage()", "method", "that", "takes", "an", "url", "parameter", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getresource() <extra_id_0> function collaboration <extra_id_5> createimage() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> createimage() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "getresource()"}, {"type": "API", "offset": [7], "text": "createimage()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [4], "text": "getresource()"}, {"type": "API", "offset": [7], "text": "createimage()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "getresource()", "label": "API", "asoc": [["function collaboration", "createimage()"]]}, {"span": "createimage()", "label": "API", "asoc": []}]}
{"text": "perhaps something is calling get() while the array list is making its copy with the iterator .", "tokens": ["perhaps", "something", "is", "calling", "get()", "while", "the", "array", "list", "is", "making", "its", "copy", "with", "the", "iterator", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "get()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "get()", "label": "API", "asoc": []}]}
{"text": "i always thought that clone() creates an object without calling a constructor", "tokens": ["i", "always", "thought", "that", "clone()", "creates", "an", "object", "without", "calling", "a", "constructor", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> clone() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "clone()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "clone()", "label": "API", "asoc": []}]}
{"text": "you should use string.format instead", "tokens": ["you", "should", "use", "string.format", "instead", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.format <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "string.format"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.format", "label": "API", "asoc": []}]}
{"text": "and  ,  override the method compareto() as per your need", "tokens": ["and", "", ",", "", "override", "the", "method", "compareto()", "as", "per", "your", "need", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> compareto() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "compareto()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "compareto()", "label": "API", "asoc": []}]}
{"text": "in your case ,  you should be overriding paint()", "tokens": ["in", "your", "case", ",", "", "you", "should", "be", "overriding", "paint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> paint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "paint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "paint()", "label": "API", "asoc": []}]}
{"text": "look at the signature of converter.ofnullable()", "tokens": ["look", "at", "the", "signature", "of", "converter.ofnullable()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> converter.ofnullable() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "converter.ofnullable()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "converter.ofnullable()", "label": "API", "asoc": []}]}
{"text": "appends using invokelater() will be processed in the order in which they are enqueued", "tokens": ["appends", "using", "invokelater()", "will", "be", "processed", "in", "the", "order", "in", "which", "they", "are", "enqueued", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> invokelater() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "invokelater()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "invokelater()", "label": "API", "asoc": []}]}
{"text": "just use the appropriately named method: string.split()", "tokens": ["just", "use", "the", "appropriately", "named", "method:", "string.split()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.split() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "string.split()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.split()", "label": "API", "asoc": []}]}
{"text": "in that case you have to also override hashcode()", "tokens": ["in", "that", "case", "you", "have", "to", "also", "override", "hashcode()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "hashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "hashcode()", "label": "API", "asoc": []}]}
{"text": "you can do it with the following method which only iterates over the map once: the add() method on hashset will return false if a value has already been added to the set", "tokens": ["you", "can", "do", "it", "with", "the", "following", "method", "which", "only", "iterates", "over", "the", "map", "once:", "the", "add()", "method", "on", "hashset", "will", "return", "false", "if", "a", "value", "has", "already", "been", "added", "to", "the", "set", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> add() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "add()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "add()", "label": "API", "asoc": []}]}
{"text": "(and the only place you can thread.sleep() in a swing application is inside a swingworker's doinbackground method", "tokens": ["(and", "the", "only", "place", "you", "can", "thread.sleep()", "in", "a", "swing", "application", "is", "inside", "a", "swingworker's", "doinbackground", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "thread.sleep()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep()", "label": "API", "asoc": []}]}
{"text": "its young brother system#nanotime() has a much better precision than system#currenttimemillis()", "tokens": ["its", "young", "brother", "system#nanotime()", "has", "a", "much", "better", "precision", "than", "system#currenttimemillis()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system#nanotime() <extra_id_0> efficiency comparison <extra_id_5> system#currenttimemillis() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> system#currenttimemillis() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "system#nanotime()"}, {"type": "API", "offset": [10], "text": "system#currenttimemillis()"}], "relation": [{"type": "efficiency comparison", "args": [{"type": "API", "offset": [3], "text": "system#nanotime()"}, {"type": "API", "offset": [10], "text": "system#currenttimemillis()"}]}], "event": [], "spot": ["API"], "asoc": ["efficiency comparison"], "spot_asoc": [{"span": "system#nanotime()", "label": "API", "asoc": [["efficiency comparison", "system#currenttimemillis()"]]}, {"span": "system#currenttimemillis()", "label": "API", "asoc": []}]}
{"text": "i added below part below is the source code ,  it might be not efficient ,  but it work: look at string.hashcode()", "tokens": ["i", "added", "below", "part", "below", "is", "the", "source", "code", ",", "", "it", "might", "be", "not", "efficient", ",", "", "but", "it", "work:", "look", "at", "string.hashcode()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.hashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "string.hashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.hashcode()", "label": "API", "asoc": []}]}
{"text": "it might be worthwhile to create a constant for math.log(2) so you aren't constantly recalculating it .", "tokens": ["it", "might", "be", "worthwhile", "to", "create", "a", "constant", "for", "math.log(2)", "so", "you", "aren't", "constantly", "recalculating", "it", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> math.log(2) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "math.log(2)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "math.log(2)", "label": "API", "asoc": []}]}
{"text": "nextint() doesn't consume invalid input so it will try read same invalid value over and over again .", "tokens": ["nextint()", "doesn't", "consume", "invalid", "input", "so", "it", "will", "try", "read", "same", "invalid", "value", "over", "and", "over", "again", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "nextint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nextint()", "label": "API", "asoc": []}]}
{"text": "as java rule finally will always be executed except in case when jvm crashes or system.exit() is called", "tokens": ["as", "java", "rule", "finally", "will", "always", "be", "executed", "except", "in", "case", "when", "jvm", "crashes", "or", "system.exit()", "is", "called", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.exit() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "system.exit()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.exit()", "label": "API", "asoc": []}]}
{"text": "you might wanna to have a look at the java.nio.file package description to get further details on this", "tokens": ["you", "might", "wanna", "to", "have", "a", "look", "at", "the", "java.nio.file", "package", "description", "to", "get", "further", "details", "on", "this", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.nio.file <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "java.nio.file"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.nio.file", "label": "API", "asoc": []}]}
{"text": "and i don't mean a java.util.date ,  which is really an instant", "tokens": ["and", "i", "don't", "mean", "a", "java.util.date", ",", "", "which", "is", "really", "an", "instant", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.date <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "java.util.date"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.date", "label": "API", "asoc": []}]}
{"text": "to avoid direct use of flow control statements like if or while you can use math.min and math.max", "tokens": ["to", "avoid", "direct", "use", "of", "flow", "control", "statements", "like", "if", "or", "while", "you", "can", "use", "math.min", "and", "math.max", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> math.min <extra_id_0> function collaboration <extra_id_5> math.max <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> math.max <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "math.min"}, {"type": "API", "offset": [17], "text": "math.max"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [15], "text": "math.min"}, {"type": "API", "offset": [17], "text": "math.max"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "math.min", "label": "API", "asoc": [["function collaboration", "math.max"]]}, {"span": "math.max", "label": "API", "asoc": []}]}
{"text": "instead use java.time.instant for a moment in utc with a resolution as fine as nanoseconds", "tokens": ["instead", "use", "java.time.instant", "for", "a", "moment", "in", "utc", "with", "a", "resolution", "as", "fine", "as", "nanoseconds", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.time.instant <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "java.time.instant"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.time.instant", "label": "API", "asoc": []}]}
{"text": "for example ,  the call to files.lines doesn't actually read the file until you add a terminal operation on the stream .", "tokens": ["for", "example", ",", "", "the", "call", "to", "files.lines", "doesn't", "actually", "read", "the", "file", "until", "you", "add", "a", "terminal", "operation", "on", "the", "stream", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> files.lines <extra_id_0> logic constraint <extra_id_5> stream <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> stream <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "files.lines"}, {"type": "API", "offset": [21], "text": "stream"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [7], "text": "files.lines"}, {"type": "API", "offset": [21], "text": "stream"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "files.lines", "label": "API", "asoc": [["logic constraint", "stream"]]}, {"span": "stream", "label": "API", "asoc": []}]}
{"text": "joshua bloch says on effective java you must override hashcode() in every class that overrides equals()", "tokens": ["joshua", "bloch", "says", "on", "effective", "java", "you", "must", "override", "hashcode()", "in", "every", "class", "that", "overrides", "equals()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hashcode() <extra_id_0> logic constraint <extra_id_5> equals() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> equals() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "hashcode()"}, {"type": "API", "offset": [15], "text": "equals()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [9], "text": "hashcode()"}, {"type": "API", "offset": [15], "text": "equals()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "hashcode()", "label": "API", "asoc": [["logic constraint", "equals()"]]}, {"span": "equals()", "label": "API", "asoc": []}]}
{"text": "practice and you'll see it quality code such as java.util.concurrent structures .", "tokens": ["practice", "and", "you'll", "see", "it", "quality", "code", "such", "as", "java.util.concurrent", "structures", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.concurrent <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "java.util.concurrent"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.concurrent", "label": "API", "asoc": []}]}
{"text": "thread.join() was a perfectly fine way of resolving your issue before countdownlatch and the other synchronizers were created", "tokens": ["thread.join()", "was", "a", "perfectly", "fine", "way", "of", "resolving", "your", "issue", "before", "countdownlatch", "and", "the", "other", "synchronizers", "were", "created", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.join() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "thread.join()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.join()", "label": "API", "asoc": []}]}
{"text": "this might lead to stored values in hashmap to be lost if stringbuilder is used as keys .", "tokens": ["this", "might", "lead", "to", "stored", "values", "in", "hashmap", "to", "be", "lost", "if", "stringbuilder", "is", "used", "as", "keys", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hashmap <extra_id_0> logic constraint <extra_id_5> stringbuilder <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> stringbuilder <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "hashmap"}, {"type": "API", "offset": [12], "text": "stringbuilder"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [7], "text": "hashmap"}, {"type": "API", "offset": [12], "text": "stringbuilder"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "hashmap", "label": "API", "asoc": [["logic constraint", "stringbuilder"]]}, {"span": "stringbuilder", "label": "API", "asoc": []}]}
{"text": "the painting of the background is done in the paint() method", "tokens": ["the", "painting", "of", "the", "background", "is", "done", "in", "the", "paint()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> paint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "paint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "paint()", "label": "API", "asoc": []}]}
{"text": "since you need to work with regular expressions ,  you may consider using replaceall instead of replace .", "tokens": ["since", "you", "need", "to", "work", "with", "regular", "expressions", ",", "", "you", "may", "consider", "using", "replaceall", "instead", "of", "replace", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replaceall <extra_id_0> function replace <extra_id_5> replace <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> replace <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "replaceall"}, {"type": "API", "offset": [17], "text": "replace"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [14], "text": "replaceall"}, {"type": "API", "offset": [17], "text": "replace"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "replaceall", "label": "API", "asoc": [["function replace", "replace"]]}, {"span": "replace", "label": "API", "asoc": []}]}
{"text": "as further comment ,  you should be aware of this term in the equals contract: from object.equals(object)", "tokens": ["as", "further", "comment", ",", "", "you", "should", "be", "aware", "of", "this", "term", "in", "the", "equals", "contract:", "from", "object.equals(object)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> object.equals(object) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "object.equals(object)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "object.equals(object)", "label": "API", "asoc": []}]}
{"text": "the intvalue() method is however available on the double ,  as shown in the javadoc some more reading on those primitive types can be found here", "tokens": ["the", "intvalue()", "method", "is", "however", "available", "on", "the", "double", ",", "", "as", "shown", "in", "the", "javadoc", "some", "more", "reading", "on", "those", "primitive", "types", "can", "be", "found", "here", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> intvalue() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "intvalue()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "intvalue()", "label": "API", "asoc": []}]}
{"text": "since java doesn't support primitive collections there is no easy way to use arrays.aslist to wrap a primitive array", "tokens": ["since", "java", "doesn't", "support", "primitive", "collections", "there", "is", "no", "easy", "way", "to", "use", "arrays.aslist", "to", "wrap", "a", "primitive", "array", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.aslist <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "arrays.aslist"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.aslist", "label": "API", "asoc": []}]}
{"text": "firstly ,  calling flush() is not going to do you any good: flush() does not commit anything and ,  as you are logging the error in the same transaction ,  the insert will be rolled back", "tokens": ["firstly", ",", "", "calling", "flush()", "is", "not", "going", "to", "do", "you", "any", "good:", "flush()", "does", "not", "commit", "anything", "and", ",", "", "as", "you", "are", "logging", "the", "error", "in", "the", "same", "transaction", ",", "", "the", "insert", "will", "be", "rolled", "back", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> flush() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "flush()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "flush()", "label": "API", "asoc": []}]}
{"text": "so when you call arrays.aslist(ar) the arrays creates a list with exactly one item - the int array ar", "tokens": ["so", "when", "you", "call", "arrays.aslist(ar)", "the", "arrays", "creates", "a", "list", "with", "exactly", "one", "item", "-", "the", "int", "array", "ar", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.aslist(ar) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "arrays.aslist(ar)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.aslist(ar)", "label": "API", "asoc": []}]}
{"text": "the following uses the java.lang.invoke package", "tokens": ["the", "following", "uses", "the", "java.lang.invoke", "package", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.invoke <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "java.lang.invoke"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.invoke", "label": "API", "asoc": []}]}
{"text": "what is the potential damage if it was possible to invoke wait() outside a synchronized block", "tokens": ["what", "is", "the", "potential", "damage", "if", "it", "was", "possible", "to", "invoke", "wait()", "outside", "a", "synchronized", "block", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "it especially initializes the loading of fonts (on the os or included in jar) in a cache by using font implement in java.awt", "tokens": ["it", "especially", "initializes", "the", "loading", "of", "fonts", "(on", "the", "os", "or", "included", "in", "jar)", "in", "a", "cache", "by", "using", "font", "implement", "in", "java.awt", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.awt <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "java.awt"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.awt", "label": "API", "asoc": []}]}
{"text": "any other value is rejected at runtime with an sqlexception .", "tokens": ["any", "other", "value", "is", "rejected", "at", "runtime", "with", "an", "sqlexception", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> sqlexception <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "sqlexception"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "sqlexception", "label": "API", "asoc": []}]}
{"text": "in the second and third lines ,  the target typing is disrupted by the presence of the call to reversed()", "tokens": ["in", "the", "second", "and", "third", "lines", ",", "", "the", "target", "typing", "is", "disrupted", "by", "the", "presence", "of", "the", "call", "to", "reversed()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> reversed() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [20], "text": "reversed()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "reversed()", "label": "API", "asoc": []}]}
{"text": "however ,  as pointed out below println() also does a few other things such as causing a memory barrier ,  so this isn't a foolproof test", "tokens": ["however", ",", "", "as", "pointed", "out", "below", "println()", "also", "does", "a", "few", "other", "things", "such", "as", "causing", "a", "memory", "barrier", ",", "", "so", "this", "isn't", "a", "foolproof", "test", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> println() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "println()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "println()", "label": "API", "asoc": []}]}
{"text": "looking at the source ,  it seems that because your hashcode returns a different value (was 5 ,  now 6) ,  it's possible that it's being looked up in a different bucket based on implementation details .", "tokens": ["looking", "at", "the", "source", ",", "", "it", "seems", "that", "because", "your", "hashcode", "returns", "a", "different", "value", "(was", "5", ",", "", "now", "6)", ",", "", "it's", "possible", "that", "it's", "being", "looked", "up", "in", "a", "different", "bucket", "based", "on", "implementation", "details", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hashcode <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "hashcode"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "hashcode", "label": "API", "asoc": []}]}
{"text": "update: extending java.util.logging.simpleformatter did the trick", "tokens": ["update:", "extending", "java.util.logging.simpleformatter", "did", "the", "trick", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.logging.simpleformatter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "java.util.logging.simpleformatter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.logging.simpleformatter", "label": "API", "asoc": []}]}
{"text": "the full formatting options are documented as part of java.util.formatter .", "tokens": ["the", "full", "formatting", "options", "are", "documented", "as", "part", "of", "java.util.formatter", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.formatter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "java.util.formatter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.formatter", "label": "API", "asoc": []}]}
{"text": "perhaps in 2.11 or 2.12 there will be a mutable treemap ; it requires someone to write it ,  test it ,  optimize it ,  etc. ,  but i don't think there's a philosophical objection to having it .", "tokens": ["perhaps", "in", "2.11", "or", "2.12", "there", "will", "be", "a", "mutable", "treemap", ";", "it", "requires", "someone", "to", "write", "it", ",", "", "test", "it", ",", "", "optimize", "it", ",", "", "etc.", ",", "", "but", "i", "don't", "think", "there's", "a", "philosophical", "objection", "to", "having", "it", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> treemap <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "treemap"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "treemap", "label": "API", "asoc": []}]}
{"text": "to do that ,  you must synchronize on it: the same rule applies to notify() / notifyall() as well", "tokens": ["to", "do", "that", ",", "", "you", "must", "synchronize", "on", "it:", "the", "same", "rule", "applies", "to", "notify()", "/", "notifyall()", "as", "well", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> notify() <extra_id_0> function similarity <extra_id_5> notifyall() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> notifyall() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "notify()"}, {"type": "API", "offset": [17], "text": "notifyall()"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [15], "text": "notify()"}, {"type": "API", "offset": [17], "text": "notifyall()"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "notify()", "label": "API", "asoc": [["function similarity", "notifyall()"]]}, {"span": "notifyall()", "label": "API", "asoc": []}]}
{"text": "so hashcode() is executed exactly once on the key object you pass as a parameter", "tokens": ["so", "hashcode()", "is", "executed", "exactly", "once", "on", "the", "key", "object", "you", "pass", "as", "a", "parameter", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "hashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "hashcode()", "label": "API", "asoc": []}]}
{"text": "if you want to parse a url ,  use java.net.uri", "tokens": ["if", "you", "want", "to", "parse", "a", "url", ",", "", "use", "java.net.uri", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.net.uri <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "java.net.uri"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.net.uri", "label": "API", "asoc": []}]}
{"text": "a java.util.date represents a moment in utc", "tokens": ["a", "java.util.date", "represents", "a", "moment", "in", "utc", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.date <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "java.util.date"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.date", "label": "API", "asoc": []}]}
{"text": "logic : match the characters in a string with the previous character .", "tokens": ["logic", ":", "match", "the", "characters", "in", "a", "string", "with", "the", "previous", "character", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string", "label": "API", "asoc": []}]}
{"text": "i had to initialize the variable to new java.util.random().nextint() to prevent it from optimizing away a lot of code .", "tokens": ["i", "had", "to", "initialize", "the", "variable", "to", "new", "java.util.random().nextint()", "to", "prevent", "it", "from", "optimizing", "away", "a", "lot", "of", "code", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.random().nextint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "java.util.random().nextint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.random().nextint()", "label": "API", "asoc": []}]}
{"text": "apparently the interrupt() approach doesn't work on \"most\" modern java platforms", "tokens": ["apparently", "the", "interrupt()", "approach", "doesn't", "work", "on", "\"most\"", "modern", "java", "platforms", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> interrupt() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "interrupt()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "interrupt()", "label": "API", "asoc": []}]}
{"text": "note that you can call unordered() to release the ordering contract and potentially increase performance", "tokens": ["note", "that", "you", "can", "call", "unordered()", "to", "release", "the", "ordering", "contract", "and", "potentially", "increase", "performance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> unordered() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "unordered()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "unordered()", "label": "API", "asoc": []}]}
{"text": "the constructor invocation itself will use ,  behind the scenes ,  system.arraycopy", "tokens": ["the", "constructor", "invocation", "itself", "will", "use", ",", "", "behind", "the", "scenes", ",", "", "system.arraycopy", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.arraycopy <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "system.arraycopy"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.arraycopy", "label": "API", "asoc": []}]}
{"text": "but i think a work-around for your specific case would be to specify type as java.lang.object  ,  since this should work ok", "tokens": ["but", "i", "think", "a", "work-around", "for", "your", "specific", "case", "would", "be", "to", "specify", "type", "as", "java.lang.object", "", ",", "", "since", "this", "should", "work", "ok", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.object <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "java.lang.object"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.object", "label": "API", "asoc": []}]}
{"text": "if the consumer has already begun to wait ,  he has acquired the lock to the q instance through the synchronized get() method and then releases it while he waits", "tokens": ["if", "the", "consumer", "has", "already", "begun", "to", "wait", ",", "", "he", "has", "acquired", "the", "lock", "to", "the", "q", "instance", "through", "the", "synchronized", "get()", "method", "and", "then", "releases", "it", "while", "he", "waits", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "get()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "get()", "label": "API", "asoc": []}]}
{"text": "this is actually a frequent pattern: have a static getinstance() and keep the constructor private", "tokens": ["this", "is", "actually", "a", "frequent", "pattern:", "have", "a", "static", "getinstance()", "and", "keep", "the", "constructor", "private", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getinstance() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "getinstance()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getinstance()", "label": "API", "asoc": []}]}
{"text": "implementations of java.lang.charsequence (such as the string class) ,  and implementations of java.text.characteriterator", "tokens": ["implementations", "of", "java.lang.charsequence", "(such", "as", "the", "string", "class)", ",", "", "and", "implementations", "of", "java.text.characteriterator", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.charsequence <extra_id_0> function similarity <extra_id_5> java.text.characteriterator <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> java.text.characteriterator <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "java.lang.charsequence"}, {"type": "API", "offset": [13], "text": "java.text.characteriterator"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [2], "text": "java.lang.charsequence"}, {"type": "API", "offset": [13], "text": "java.text.characteriterator"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "java.lang.charsequence", "label": "API", "asoc": [["function similarity", "java.text.characteriterator"]]}, {"span": "java.text.characteriterator", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always return null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "return", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "also keep in mind that integer.parseint() can throw a numberformatexception if it is not able to parse the data in the scores column as an integer .", "tokens": ["also", "keep", "in", "mind", "that", "integer.parseint()", "can", "throw", "a", "numberformatexception", "if", "it", "is", "not", "able", "to", "parse", "the", "data", "in", "the", "scores", "column", "as", "an", "integer", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> integer.parseint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "integer.parseint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "integer.parseint()", "label": "API", "asoc": []}]}
{"text": "let's take a look at an example: in this example ,  the show() method looks like this: this is the output: page 3 (see line 4 in code sample 3.8) is an a4 page just like page 1 ,  but it's oriented in landscape", "tokens": ["let's", "take", "a", "look", "at", "an", "example:", "in", "this", "example", ",", "", "the", "show()", "method", "looks", "like", "this:", "this", "is", "the", "output:", "page", "3", "(see", "line", "4", "in", "code", "sample", "3.8)", "is", "an", "a4", "page", "just", "like", "page", "1", ",", "", "but", "it's", "oriented", "in", "landscape", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> show() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "show()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "show()", "label": "API", "asoc": []}]}
{"text": "calling shutdownoutput() on a socket actually sends something on the network (fin) that wakes up my selector on the other side", "tokens": ["calling", "shutdownoutput()", "on", "a", "socket", "actually", "sends", "something", "on", "the", "network", "(fin)", "that", "wakes", "up", "my", "selector", "on", "the", "other", "side", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> shutdownoutput() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "shutdownoutput()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "shutdownoutput()", "label": "API", "asoc": []}]}
{"text": "don't understand why ,  since hasnext() is supposed to look at something ,  not change ,  but it worked", "tokens": ["don't", "understand", "why", ",", "", "since", "hasnext()", "is", "supposed", "to", "look", "at", "something", ",", "", "not", "change", ",", "", "but", "it", "worked", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hasnext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "hasnext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "hasnext()", "label": "API", "asoc": []}]}
{"text": "note that you should not use new file() for this", "tokens": ["note", "that", "you", "should", "not", "use", "new", "file()", "for", "this", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "file()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file()", "label": "API", "asoc": []}]}
{"text": "i would prefer to use suggested java.util.concurrent.timeunit class .", "tokens": ["i", "would", "prefer", "to", "use", "suggested", "java.util.concurrent.timeunit", "class", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.concurrent.timeunit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "java.util.concurrent.timeunit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.concurrent.timeunit", "label": "API", "asoc": []}]}
{"text": "i would do it like that: if you want to use the getidentifier() method:", "tokens": ["i", "would", "do", "it", "like", "that:", "if", "you", "want", "to", "use", "the", "getidentifier()", "method:", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getidentifier() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "getidentifier()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getidentifier()", "label": "API", "asoc": []}]}
{"text": "the normally fast set operations ( especially contains() ) are quite slow here ,  as the arrays will be searched in linear time", "tokens": ["the", "normally", "fast", "set", "operations", "(", "especially", "contains()", ")", "are", "quite", "slow", "here", ",", "", "as", "the", "arrays", "will", "be", "searched", "in", "linear", "time", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> contains() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "contains()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "contains()", "label": "API", "asoc": []}]}
{"text": "however ,  the javax.xml package contains classes that can deal with this format", "tokens": ["however", ",", "", "the", "javax.xml", "package", "contains", "classes", "that", "can", "deal", "with", "this", "format", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> javax.xml <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "javax.xml"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "javax.xml", "label": "API", "asoc": []}]}
{"text": "if this is the case ,  we will use the math.floor() function", "tokens": ["if", "this", "is", "the", "case", ",", "", "we", "will", "use", "the", "math.floor()", "function", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> math.floor() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "math.floor()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "math.floor()", "label": "API", "asoc": []}]}
{"text": "also note that fileinputstream.available() is not documented to mean the same thing as total size", "tokens": ["also", "note", "that", "fileinputstream.available()", "is", "not", "documented", "to", "mean", "the", "same", "thing", "as", "total", "size", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> fileinputstream.available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "fileinputstream.available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "fileinputstream.available()", "label": "API", "asoc": []}]}
{"text": "as defined by java.lang.system specification the user.dir property returns the current working directory (i.e", "tokens": ["as", "defined", "by", "java.lang.system", "specification", "the", "user.dir", "property", "returns", "the", "current", "working", "directory", "(i.e", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.system <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "java.lang.system"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.system", "label": "API", "asoc": []}]}
{"text": "edit: i just realized i can simplify the regex quite a bit by putting the alternation inside the lookahead: by the way ,  have you considered using format() to build the regex instead of replace() ?", "tokens": ["edit:", "i", "just", "realized", "i", "can", "simplify", "the", "regex", "quite", "a", "bit", "by", "putting", "the", "alternation", "inside", "the", "lookahead:", "by", "the", "way", ",", "", "have", "you", "considered", "using", "format()", "to", "build", "the", "regex", "instead", "of", "replace()", "?", "", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> format() <extra_id_0> function replace <extra_id_5> replace() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "format()", "label": "API", "asoc": [["function replace", "replace()"]]}, {"span": "replace()", "label": "API", "asoc": []}]}
{"text": "also ,  any time you do custom painting you need to override the getpreferredsize() method of the custom component so the layout managers can do their job .", "tokens": ["also", ",", "", "any", "time", "you", "do", "custom", "painting", "you", "need", "to", "override", "the", "getpreferredsize()", "method", "of", "the", "custom", "component", "so", "the", "layout", "managers", "can", "do", "their", "job", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getpreferredsize() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "getpreferredsize()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getpreferredsize()", "label": "API", "asoc": []}]}
{"text": "this still does not explain the behavior but it further confirms that thread.sleep is not necessarily the reason behind the consumer suddenly seeing the updates made to the queue", "tokens": ["this", "still", "does", "not", "explain", "the", "behavior", "but", "it", "further", "confirms", "that", "thread.sleep", "is", "not", "necessarily", "the", "reason", "behind", "the", "consumer", "suddenly", "seeing", "the", "updates", "made", "to", "the", "queue", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "thread.sleep"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep", "label": "API", "asoc": []}]}
{"text": "without putting my brain fully into gear ,  from a quick scan of what you say it looks as though you need to intern() your strings", "tokens": ["without", "putting", "my", "brain", "fully", "into", "gear", ",", "", "from", "a", "quick", "scan", "of", "what", "you", "say", "it", "looks", "as", "though", "you", "need", "to", "intern()", "your", "strings", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> intern() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [24], "text": "intern()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "intern()", "label": "API", "asoc": []}]}
{"text": "see the comments for an explanation ,  but here is an example program that continuously generates objects until it finds two with the same system.identityhashcode()", "tokens": ["see", "the", "comments", "for", "an", "explanation", ",", "", "but", "here", "is", "an", "example", "program", "that", "continuously", "generates", "objects", "until", "it", "finds", "two", "with", "the", "same", "system.identityhashcode()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [25], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "i've performed 100 runs with the same file ,  and measured each run with system.nanotime()", "tokens": ["i've", "performed", "100", "runs", "with", "the", "same", "file", ",", "", "and", "measured", "each", "run", "with", "system.nanotime()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.nanotime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "system.nanotime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.nanotime()", "label": "API", "asoc": []}]}
{"text": "the java.time classes use the standard formats by default when parsing/generating strings", "tokens": ["the", "java.time", "classes", "use", "the", "standard", "formats", "by", "default", "when", "parsing/generating", "strings", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "java.time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.time", "label": "API", "asoc": []}]}
{"text": "socket.getinetaddress() returns an inetaddress object that contains the ip address of the remote machine", "tokens": ["socket.getinetaddress()", "returns", "an", "inetaddress", "object", "that", "contains", "the", "ip", "address", "of", "the", "remote", "machine", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> socket.getinetaddress() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "socket.getinetaddress()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "socket.getinetaddress()", "label": "API", "asoc": []}]}
{"text": "when the client exits ,  readline() gives you back the data it read thus far .", "tokens": ["when", "the", "client", "exits", ",", "", "readline()", "gives", "you", "back", "the", "data", "it", "read", "thus", "far", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> readline() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "readline()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "readline()", "label": "API", "asoc": []}]}
{"text": "surrogate key) ,  we have to use business/natural key to implement equals() method", "tokens": ["surrogate", "key)", ",", "", "we", "have", "to", "use", "business/natural", "key", "to", "implement", "equals()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "equals()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": []}]}
{"text": "there's an input stream decorator ,  java.security.digestinputstream ,  so that you can compute the digest while using the input stream as you normally would", "tokens": ["there's", "an", "input", "stream", "decorator", ",", "", "java.security.digestinputstream", ",", "", "so", "that", "you", "can", "compute", "the", "digest", "while", "using", "the", "input", "stream", "as", "you", "normally", "would", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.security.digestinputstream <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "java.security.digestinputstream"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.security.digestinputstream", "label": "API", "asoc": []}]}
{"text": "the java.time classes use these standard formats by default when parsing/generating strings", "tokens": ["the", "java.time", "classes", "use", "these", "standard", "formats", "by", "default", "when", "parsing/generating", "strings", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "java.time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.time", "label": "API", "asoc": []}]}
{"text": "the static methods valueof() and values() are created at compile time and do not appear in source code", "tokens": ["the", "static", "methods", "valueof()", "and", "values()", "are", "created", "at", "compile", "time", "and", "do", "not", "appear", "in", "source", "code", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> valueof() <extra_id_0> function similarity <extra_id_5> values() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> values() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "valueof()"}, {"type": "API", "offset": [5], "text": "values()"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [3], "text": "valueof()"}, {"type": "API", "offset": [5], "text": "values()"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "valueof()", "label": "API", "asoc": [["function similarity", "values()"]]}, {"span": "values()", "label": "API", "asoc": []}]}
{"text": "calling system.err.flush() after printing the first two stack traces and then system.out.flush() after printing to the std output stream should get consistent results .", "tokens": ["calling", "system.err.flush()", "after", "printing", "the", "first", "two", "stack", "traces", "and", "then", "system.out.flush()", "after", "printing", "to", "the", "std", "output", "stream", "should", "get", "consistent", "results", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.err.flush() <extra_id_0> logic constraint <extra_id_5> system.out.flush() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> system.out.flush() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "system.err.flush()"}, {"type": "API", "offset": [11], "text": "system.out.flush()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [1], "text": "system.err.flush()"}, {"type": "API", "offset": [11], "text": "system.out.flush()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "system.err.flush()", "label": "API", "asoc": [["logic constraint", "system.out.flush()"]]}, {"span": "system.out.flush()", "label": "API", "asoc": []}]}
{"text": "this is just the api though ,  not the storage format inside java.util.date", "tokens": ["this", "is", "just", "the", "api", "though", ",", "", "not", "the", "storage", "format", "inside", "java.util.date", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.date <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "java.util.date"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.date", "label": "API", "asoc": []}]}
{"text": "so here ,  readline() will be executed ,  and its return value stored in line", "tokens": ["so", "here", ",", "", "readline()", "will", "be", "executed", ",", "", "and", "its", "return", "value", "stored", "in", "line", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> readline() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "readline()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "readline()", "label": "API", "asoc": []}]}
{"text": "so when nextline() is called ,  it sees that there are no characters before the end-of-line character ,  so it thinks that an empty line was entered ,  and you get an empty string back", "tokens": ["so", "when", "nextline()", "is", "called", ",", "", "it", "sees", "that", "there", "are", "no", "characters", "before", "the", "end-of-line", "character", ",", "", "so", "it", "thinks", "that", "an", "empty", "line", "was", "entered", ",", "", "and", "you", "get", "an", "empty", "string", "back", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextline() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "nextline()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nextline()", "label": "API", "asoc": []}]}
{"text": "when some other thread calls thread.interrupt() the method sets thread's interrupt status flag (initially false) to true", "tokens": ["when", "some", "other", "thread", "calls", "thread.interrupt()", "the", "method", "sets", "thread's", "interrupt", "status", "flag", "(initially", "false)", "to", "true", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.interrupt() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "thread.interrupt()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.interrupt()", "label": "API", "asoc": []}]}
{"text": "give java nio a try: using transferfrom() is potentially much more efficient than a simple loop that reads from the source channel and writes to this channel", "tokens": ["give", "java", "nio", "a", "try:", "using", "transferfrom()", "is", "potentially", "much", "more", "efficient", "than", "a", "simple", "loop", "that", "reads", "from", "the", "source", "channel", "and", "writes", "to", "this", "channel", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> transferfrom() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "transferfrom()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "transferfrom()", "label": "API", "asoc": []}]}
{"text": "the issue is the nextdouble() function", "tokens": ["the", "issue", "is", "the", "nextdouble()", "function", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextdouble() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "nextdouble()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nextdouble()", "label": "API", "asoc": []}]}
{"text": "the second problem is that when you close() a scanner that also closes the input source", "tokens": ["the", "second", "problem", "is", "that", "when", "you", "close()", "a", "scanner", "that", "also", "closes", "the", "input", "source", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> close() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "close()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "close()", "label": "API", "asoc": []}]}
{"text": "he makes a false assertion about cancel()", "tokens": ["he", "makes", "a", "false", "assertion", "about", "cancel()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> cancel() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "cancel()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "cancel()", "label": "API", "asoc": []}]}
{"text": "if the pattern.matcher() were to match the pattern ,  then there has to be some way to define various ways to match ,  as matching can be in different ways", "tokens": ["if", "the", "pattern.matcher()", "were", "to", "match", "the", "pattern", ",", "", "then", "there", "has", "to", "be", "some", "way", "to", "define", "various", "ways", "to", "match", ",", "", "as", "matching", "can", "be", "in", "different", "ways", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pattern.matcher() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "pattern.matcher()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pattern.matcher()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not give you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "give", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "when reading using imageio.read(file) you are effectively stripping away any meta data in the jpeg file ,  like xmp ,  exif or icc profiles", "tokens": ["when", "reading", "using", "imageio.read(file)", "you", "are", "effectively", "stripping", "away", "any", "meta", "data", "in", "the", "jpeg", "file", ",", "", "like", "xmp", ",", "", "exif", "or", "icc", "profiles", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> imageio.read(file) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "imageio.read(file)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "imageio.read(file)", "label": "API", "asoc": []}]}
{"text": "the file.isfile() call deals with these cases", "tokens": ["the", "file.isfile()", "call", "deals", "with", "these", "cases", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.isfile() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.isfile()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.isfile()", "label": "API", "asoc": []}]}
{"text": "if you want to print the contents of an array ,  try for custom classes ,  you should always implement (override) your own custom tostring() method", "tokens": ["if", "you", "want", "to", "print", "the", "contents", "of", "an", "array", ",", "", "try", "for", "custom", "classes", ",", "", "you", "should", "always", "implement", "(override)", "your", "own", "custom", "tostring()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [26], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "i have explained in my answer from this post a recommended way in which you can paginate queries by combining query cursors with the limit() method", "tokens": ["i", "have", "explained", "in", "my", "answer", "from", "this", "post", "a", "recommended", "way", "in", "which", "you", "can", "paginate", "queries", "by", "combining", "query", "cursors", "with", "the", "limit()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> limit() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [24], "text": "limit()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "limit()", "label": "API", "asoc": []}]}
{"text": "if i were to add a new java.lang.runnable to the code base ,  i would have to also include that line", "tokens": ["if", "i", "were", "to", "add", "a", "new", "java.lang.runnable", "to", "the", "code", "base", ",", "", "i", "would", "have", "to", "also", "include", "that", "line", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.runnable <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "java.lang.runnable"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.runnable", "label": "API", "asoc": []}]}
{"text": "whatever you get when you do class.forname() are stored there", "tokens": ["whatever", "you", "get", "when", "you", "do", "class.forname()", "are", "stored", "there", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> class.forname() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "class.forname()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "class.forname()", "label": "API", "asoc": []}]}
{"text": "the one-arg zoneddatetime.parse has parsed the 00 seconds", "tokens": ["the", "one-arg", "zoneddatetime.parse", "has", "parsed", "the", "00", "seconds", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> zoneddatetime.parse <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "zoneddatetime.parse"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "zoneddatetime.parse", "label": "API", "asoc": []}]}
{"text": "the exception is thrown because you are adding/removing things from the map while you are iterating it: you should use iterator.remove() instead .", "tokens": ["the", "exception", "is", "thrown", "because", "you", "are", "adding/removing", "things", "from", "the", "map", "while", "you", "are", "iterating", "it:", "you", "should", "use", "iterator.remove()", "instead", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> iterator.remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [20], "text": "iterator.remove()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "iterator.remove()", "label": "API", "asoc": []}]}
{"text": "as told by many a wonderful stackoverflow users ,  the right idea in here is to use the javax.swing.timer", "tokens": ["as", "told", "by", "many", "a", "wonderful", "stackoverflow", "users", ",", "", "the", "right", "idea", "in", "here", "is", "to", "use", "the", "javax.swing.timer", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> javax.swing.timer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "javax.swing.timer"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "javax.swing.timer", "label": "API", "asoc": []}]}
{"text": "java.awt.point  ,  you can put the weights into a map: then ,  you make an image ,  and for each x , y coordinate ,  find the best score", "tokens": ["java.awt.point", "", ",", "", "you", "can", "put", "the", "weights", "into", "a", "map:", "then", ",", "", "you", "make", "an", "image", ",", "", "and", "for", "each", "x", ",", "y", "coordinate", ",", "", "find", "the", "best", "score", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.awt.point <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "java.awt.point"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.awt.point", "label": "API", "asoc": []}]}
{"text": "something like: you can probably use something like: that assumes the sql.time represents the number of milliseconds since midnight .", "tokens": ["something", "like:", "you", "can", "probably", "use", "something", "like:", "that", "assumes", "the", "sql.time", "represents", "the", "number", "of", "milliseconds", "since", "midnight", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> sql.time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "sql.time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "sql.time", "label": "API", "asoc": []}]}
{"text": "you need java.util.collections : if you have to write your own ,  have that class implement the list interface and throw exceptions for the methods that modify contents .", "tokens": ["you", "need", "java.util.collections", ":", "if", "you", "have", "to", "write", "your", "own", ",", "", "have", "that", "class", "implement", "the", "list", "interface", "and", "throw", "exceptions", "for", "the", "methods", "that", "modify", "contents", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.collections <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "java.util.collections"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.collections", "label": "API", "asoc": []}]}
{"text": "from the javadoc for timer.scheduleatfixedrate() : throws: illegalstateexception - if task was already scheduled or cancelled ,  timer was cancelled ,  or timer thread terminated", "tokens": ["from", "the", "javadoc", "for", "timer.scheduleatfixedrate()", ":", "throws:", "illegalstateexception", "-", "if", "task", "was", "already", "scheduled", "or", "cancelled", ",", "", "timer", "was", "cancelled", ",", "", "or", "timer", "thread", "terminated", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timer.scheduleatfixedrate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "timer.scheduleatfixedrate()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "timer.scheduleatfixedrate()", "label": "API", "asoc": []}]}
{"text": "split() takes a regex as it's argument", "tokens": ["split()", "takes", "a", "regex", "as", "it's", "argument", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> split() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "split()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "split()", "label": "API", "asoc": []}]}
{"text": "just call dispose() method:  for instance: you can dispatch a new windowevent like this: if the window has attached a windowlistener it will be notified", "tokens": ["just", "call", "dispose()", "method:", "", "for", "instance:", "you", "can", "dispatch", "a", "new", "windowevent", "like", "this:", "if", "the", "window", "has", "attached", "a", "windowlistener", "it", "will", "be", "notified", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> dispose() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "dispose()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "dispose()", "label": "API", "asoc": []}]}
{"text": "as already noted ,  the parameters to collectors.tomap have to be functions ,  so you have to change 0 to name -&gt;", "tokens": ["as", "already", "noted", ",", "", "the", "parameters", "to", "collectors.tomap", "have", "to", "be", "functions", ",", "", "so", "you", "have", "to", "change", "0", "to", "name", "-&gt;", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> collectors.tomap <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "collectors.tomap"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "collectors.tomap", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can determine the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "determine", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "the relationship between these are documented in the java.lang.ref package documentation .", "tokens": ["the", "relationship", "between", "these", "are", "documented", "in", "the", "java.lang.ref", "package", "documentation", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.ref <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "java.lang.ref"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.ref", "label": "API", "asoc": []}]}
{"text": "is it safe to use string.getbytes()  ?  no", "tokens": ["is", "it", "safe", "to", "use", "string.getbytes()", "", "?", "", "no", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.getbytes() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "string.getbytes()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.getbytes()", "label": "API", "asoc": []}]}
{"text": "you're using readline() which expects a newline character", "tokens": ["you're", "using", "readline()", "which", "expects", "a", "newline", "character", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> readline() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "readline()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "readline()", "label": "API", "asoc": []}]}
{"text": "with that information in your head ,  a google search for java.util.list will take you to the javadoc for the class", "tokens": ["with", "that", "information", "in", "your", "head", ",", "", "a", "google", "search", "for", "java.util.list", "will", "take", "you", "to", "the", "javadoc", "for", "the", "class", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.list <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "java.util.list"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.list", "label": "API", "asoc": []}]}
{"text": "as both rely on a javax.swing.timer thread ,  neither is a solution ,  but the techniques may prove useful .", "tokens": ["as", "both", "rely", "on", "a", "javax.swing.timer", "thread", ",", "", "neither", "is", "a", "solution", ",", "", "but", "the", "techniques", "may", "prove", "useful", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> javax.swing.timer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "javax.swing.timer"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "javax.swing.timer", "label": "API", "asoc": []}]}
{"text": "the old classes are outmoded by java.time", "tokens": ["the", "old", "classes", "are", "outmoded", "by", "java.time", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "java.time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.time", "label": "API", "asoc": []}]}
{"text": "unfortunately the file.delete() method provides very little information as to why; it's pretty much up to you to poke around and figure it out", "tokens": ["unfortunately", "the", "file.delete()", "method", "provides", "very", "little", "information", "as", "to", "why;", "it's", "pretty", "much", "up", "to", "you", "to", "poke", "around", "and", "figure", "it", "out", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.delete() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "file.delete()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.delete()", "label": "API", "asoc": []}]}
{"text": "personally i very rarely use available()", "tokens": ["personally", "i", "very", "rarely", "use", "available()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't have a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "have", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "that's the reason we have the load factor ,  and the reason we should use a proper hashcode() that spreads the keys as evenly as possible across the buckets .", "tokens": ["that's", "the", "reason", "we", "have", "the", "load", "factor", ",", "", "and", "the", "reason", "we", "should", "use", "a", "proper", "hashcode()", "that", "spreads", "the", "keys", "as", "evenly", "as", "possible", "across", "the", "buckets", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "hashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "hashcode()", "label": "API", "asoc": []}]}
{"text": "the answer comes from the javadoc of zoneid (emphasis mine) . .", "tokens": ["the", "answer", "comes", "from", "the", "javadoc", "of", "zoneid", "(emphasis", "mine)", ".", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> zoneid <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "zoneid"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "zoneid", "label": "API", "asoc": []}]}
{"text": "the java.io.file.getfreespace() method returns the number of unallocated bytes in the partition named by this abstract path name", "tokens": ["the", "java.io.file.getfreespace()", "method", "returns", "the", "number", "of", "unallocated", "bytes", "in", "the", "partition", "named", "by", "this", "abstract", "path", "name", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.io.file.getfreespace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "java.io.file.getfreespace()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.io.file.getfreespace()", "label": "API", "asoc": []}]}
{"text": "then again ,  it's the same as array.newinstance with a cast added ,  so i'm not sure that your method adds a lot of value", "tokens": ["then", "again", ",", "", "it's", "the", "same", "as", "array.newinstance", "with", "a", "cast", "added", ",", "", "so", "i'm", "not", "sure", "that", "your", "method", "adds", "a", "lot", "of", "value", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> array.newinstance <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "array.newinstance"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "array.newinstance", "label": "API", "asoc": []}]}
{"text": "so next() always returns the value after the cursor ,  and moves the cursor to the position after that", "tokens": ["so", "next()", "always", "returns", "the", "value", "after", "the", "cursor", ",", "", "and", "moves", "the", "cursor", "to", "the", "position", "after", "that", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "next()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "next()", "label": "API", "asoc": []}]}
{"text": "calling file.canread() will test if it is a readable file", "tokens": ["calling", "file.canread()", "will", "test", "if", "it", "is", "a", "readable", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.canread() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.canread()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.canread()", "label": "API", "asoc": []}]}
{"text": "no ,  there are no guarantees that write() will exhaust the whole buffer", "tokens": ["no", ",", "", "there", "are", "no", "guarantees", "that", "write()", "will", "exhaust", "the", "whole", "buffer", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> write() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "write()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "write()", "label": "API", "asoc": []}]}
{"text": "many rest clients expect a list when they invoke list() method .", "tokens": ["many", "rest", "clients", "expect", "a", "list", "when", "they", "invoke", "list()", "method", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> list() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "list()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "list()", "label": "API", "asoc": []}]}
{"text": "instead ,  you need to declare map as a volatile and implement your refresh() method as per your question", "tokens": ["instead", ",", "", "you", "need", "to", "declare", "map", "as", "a", "volatile", "and", "implement", "your", "refresh()", "method", "as", "per", "your", "question", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> refresh() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "refresh()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "refresh()", "label": "API", "asoc": []}]}
{"text": "arraylist.add() should never throw an arrayindexoutofboundsexception if used \"properly\" so it seems that you're using your arraylist in a way which it does not support", "tokens": ["arraylist.add()", "should", "never", "throw", "an", "arrayindexoutofboundsexception", "if", "used", "\"properly\"", "so", "it", "seems", "that", "you're", "using", "your", "arraylist", "in", "a", "way", "which", "it", "does", "not", "support", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arraylist.add() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "arraylist.add()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arraylist.add()", "label": "API", "asoc": []}]}
{"text": "prior to scaling by 6 ,  the output of math.random() is one of 2^53 possible values drawn from a uniform distribution", "tokens": ["prior", "to", "scaling", "by", "6", ",", "", "the", "output", "of", "math.random()", "is", "one", "of", "2^53", "possible", "values", "drawn", "from", "a", "uniform", "distribution", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> math.random() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "math.random()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "math.random()", "label": "API", "asoc": []}]}
{"text": "just use file.getname() using string methods:", "tokens": ["just", "use", "file.getname()", "using", "string", "methods:", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.getname() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "file.getname()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.getname()", "label": "API", "asoc": []}]}
{"text": "and because of the backwards compatibility ,  it is too late to change it.) in your first example the string.split function creates a string[] object", "tokens": ["and", "because", "of", "the", "backwards", "compatibility", ",", "", "it", "is", "too", "late", "to", "change", "it.)", "in", "your", "first", "example", "the", "string.split", "function", "creates", "a", "string[]", "object", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.split <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [20], "text": "string.split"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.split", "label": "API", "asoc": []}]}
{"text": "readline() declares that it throws an ioexception", "tokens": ["readline()", "declares", "that", "it", "throws", "an", "ioexception", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> readline() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "readline()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "readline()", "label": "API", "asoc": []}]}
{"text": "in case the method is private use getdeclaredmethod() instead of getmethod()", "tokens": ["in", "case", "the", "method", "is", "private", "use", "getdeclaredmethod()", "instead", "of", "getmethod()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getdeclaredmethod() <extra_id_0> function replace <extra_id_5> getmethod() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> getmethod() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "getdeclaredmethod()"}, {"type": "API", "offset": [10], "text": "getmethod()"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [7], "text": "getdeclaredmethod()"}, {"type": "API", "offset": [10], "text": "getmethod()"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "getdeclaredmethod()", "label": "API", "asoc": [["function replace", "getmethod()"]]}, {"span": "getmethod()", "label": "API", "asoc": []}]}
{"text": "you'd have to remember to cancel or complete your completablefuture so that other parts of your code don't remain blocked/starved forever .", "tokens": ["you'd", "have", "to", "remember", "to", "cancel", "or", "complete", "your", "completablefuture", "so", "that", "other", "parts", "of", "your", "code", "don't", "remain", "blocked/starved", "forever", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> cancel <extra_id_0> function similarity <extra_id_5> complete <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> complete <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "cancel"}, {"type": "API", "offset": [7], "text": "complete"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [5], "text": "cancel"}, {"type": "API", "offset": [7], "text": "complete"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "cancel", "label": "API", "asoc": [["function similarity", "complete"]]}, {"span": "complete", "label": "API", "asoc": []}]}
{"text": "moreover ,  there is a pure java compatible implementation of java.lang.reflect.array from gnu classpath", "tokens": ["moreover", ",", "", "there", "is", "a", "pure", "java", "compatible", "implementation", "of", "java.lang.reflect.array", "from", "gnu", "classpath", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.reflect.array <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "java.lang.reflect.array"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.reflect.array", "label": "API", "asoc": []}]}
{"text": "the get() operation returns a task&lt;&gt; which means it is an asynchronous operation", "tokens": ["the", "get()", "operation", "returns", "a", "task&lt;&gt;", "which", "means", "it", "is", "an", "asynchronous", "operation", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "get()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "get()", "label": "API", "asoc": []}]}
{"text": "the standard oracle jdk 7 implementation uses what's called a linear congruential generator  to produce random values in java.util.random", "tokens": ["the", "standard", "oracle", "jdk", "7", "implementation", "uses", "what's", "called", "a", "linear", "congruential", "generator", "", "to", "produce", "random", "values", "in", "java.util.random", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "java.util.random"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.random", "label": "API", "asoc": []}]}
{"text": "if you just use string.getbytes() it will use the platform default", "tokens": ["if", "you", "just", "use", "string.getbytes()", "it", "will", "use", "the", "platform", "default", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.getbytes() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "string.getbytes()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.getbytes()", "label": "API", "asoc": []}]}
{"text": "additionally ,  the stringbuffer (by the way: better use stringbuilder for that) internally uses again a char[] ,  which is expanded (in length) automatically when needed", "tokens": ["additionally", ",", "", "the", "stringbuffer", "(by", "the", "way:", "better", "use", "stringbuilder", "for", "that)", "internally", "uses", "again", "a", "char[]", ",", "", "which", "is", "expanded", "(in", "length)", "automatically", "when", "needed", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> stringbuffer <extra_id_0> function replace <extra_id_5> stringbuilder <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> stringbuilder <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "stringbuffer"}, {"type": "API", "offset": [10], "text": "stringbuilder"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [4], "text": "stringbuffer"}, {"type": "API", "offset": [10], "text": "stringbuilder"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "stringbuffer", "label": "API", "asoc": [["function replace", "stringbuilder"]]}, {"span": "stringbuilder", "label": "API", "asoc": []}]}
{"text": "1.) if the class implements the actionlistener interface ,  i.e", "tokens": ["1.)", "if", "the", "class", "implements", "the", "actionlistener", "interface", ",", "", "i.e", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> actionlistener <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "actionlistener"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "actionlistener", "label": "API", "asoc": []}]}
{"text": "the jvm actually specifically provides a mechanism for overriding classes in java.lang", "tokens": ["the", "jvm", "actually", "specifically", "provides", "a", "mechanism", "for", "overriding", "classes", "in", "java.lang", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "java.lang"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang", "label": "API", "asoc": []}]}
{"text": "it is called peek() (example from the javadoc):", "tokens": ["it", "is", "called", "peek()", "(example", "from", "the", "javadoc):", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> peek() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "peek()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "peek()", "label": "API", "asoc": []}]}
{"text": "the other option is to override the equals and hashcode methods ,  but it is not good approach in your case .", "tokens": ["the", "other", "option", "is", "to", "override", "the", "equals", "and", "hashcode", "methods", ",", "", "but", "it", "is", "not", "good", "approach", "in", "your", "case", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals <extra_id_0> logic constraint <extra_id_5> hashcode <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> hashcode <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "equals"}, {"type": "API", "offset": [9], "text": "hashcode"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [7], "text": "equals"}, {"type": "API", "offset": [9], "text": "hashcode"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "equals", "label": "API", "asoc": [["logic constraint", "hashcode"]]}, {"span": "hashcode", "label": "API", "asoc": []}]}
{"text": "commit() is instantaneous but performs disk writes", "tokens": ["commit()", "is", "instantaneous", "but", "performs", "disk", "writes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> commit() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "commit()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "commit()", "label": "API", "asoc": []}]}
{"text": "calling thread.interrupted will result in clearing the interrupt flag ,  and makes no sense here ,  especially since the return value is discarded", "tokens": ["calling", "thread.interrupted", "will", "result", "in", "clearing", "the", "interrupt", "flag", ",", "", "and", "makes", "no", "sense", "here", ",", "", "especially", "since", "the", "return", "value", "is", "discarded", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.interrupted <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "thread.interrupted"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.interrupted", "label": "API", "asoc": []}]}
{"text": "for more information visit this link you are most probably using java.awt.event.keyevent ,  which will not work with javafx events", "tokens": ["for", "more", "information", "visit", "this", "link", "you", "are", "most", "probably", "using", "java.awt.event.keyevent", ",", "", "which", "will", "not", "work", "with", "javafx", "events", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.awt.event.keyevent <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "java.awt.event.keyevent"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.awt.event.keyevent", "label": "API", "asoc": []}]}
{"text": "arrays.aslist() creates a fixed-size list that is directly backed by the varargs array parameter", "tokens": ["arrays.aslist()", "creates", "a", "fixed-size", "list", "that", "is", "directly", "backed", "by", "the", "varargs", "array", "parameter", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.aslist() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "arrays.aslist()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.aslist()", "label": "API", "asoc": []}]}
{"text": "that will result in hasnextline() returning false", "tokens": ["that", "will", "result", "in", "hasnextline()", "returning", "false", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hasnextline() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "hasnextline()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "hasnextline()", "label": "API", "asoc": []}]}
{"text": "if the producer is currently already waiting on the lock ,  calling notify() will let it know that it can wake up and continue when the lock is released", "tokens": ["if", "the", "producer", "is", "currently", "already", "waiting", "on", "the", "lock", ",", "", "calling", "notify()", "will", "let", "it", "know", "that", "it", "can", "wake", "up", "and", "continue", "when", "the", "lock", "is", "released", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> notify() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "notify()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "notify()", "label": "API", "asoc": []}]}
{"text": "i don't see where your query is executed ( like statement.executequery() ) but ,  this kind of errors generally happens when your cursor is not well positioned", "tokens": ["i", "don't", "see", "where", "your", "query", "is", "executed", "(", "like", "statement.executequery()", ")", "but", ",", "", "this", "kind", "of", "errors", "generally", "happens", "when", "your", "cursor", "is", "not", "well", "positioned", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> statement.executequery() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "statement.executequery()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "statement.executequery()", "label": "API", "asoc": []}]}
{"text": "java.lang.reflect.type is a mess and unusable", "tokens": ["java.lang.reflect.type", "is", "a", "mess", "and", "unusable", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.reflect.type <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "java.lang.reflect.type"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.reflect.type", "label": "API", "asoc": []}]}
{"text": "as shown in dependentcolumn ,  you can calculate derived values in your implementation of getvalueat()", "tokens": ["as", "shown", "in", "dependentcolumn", ",", "", "you", "can", "calculate", "derived", "values", "in", "your", "implementation", "of", "getvalueat()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getvalueat() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "getvalueat()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getvalueat()", "label": "API", "asoc": []}]}
{"text": "everything i tried ,  like scanner and inputstreamreader ,  reads ahead (buffers) the input :( i guess i missed a some cases like \\r .", "tokens": ["everything", "i", "tried", ",", "", "like", "scanner", "and", "inputstreamreader", ",", "", "reads", "ahead", "(buffers)", "the", "input", ":(", "i", "guess", "i", "missed", "a", "some", "cases", "like", "\\r", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> scanner <extra_id_0> function similarity <extra_id_5> inputstreamreader <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> inputstreamreader <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "scanner"}, {"type": "API", "offset": [8], "text": "inputstreamreader"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [6], "text": "scanner"}, {"type": "API", "offset": [8], "text": "inputstreamreader"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "scanner", "label": "API", "asoc": [["function similarity", "inputstreamreader"]]}, {"span": "inputstreamreader", "label": "API", "asoc": []}]}
{"text": "every java.lang.object subclass has an android callable wrapper generated at build time", "tokens": ["every", "java.lang.object", "subclass", "has", "an", "android", "callable", "wrapper", "generated", "at", "build", "time", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.object <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "java.lang.object"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.object", "label": "API", "asoc": []}]}
{"text": "if you have java 8 available ,  you can use java.util.function", "tokens": ["if", "you", "have", "java", "8", "available", ",", "", "you", "can", "use", "java.util.function", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.function <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "java.util.function"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.function", "label": "API", "asoc": []}]}
{"text": "as @hovercraft notes ,  repaint() alone is not sufficient to tell the chart's plot that you have replaced the dataset", "tokens": ["as", "@hovercraft", "notes", ",", "", "repaint()", "alone", "is", "not", "sufficient", "to", "tell", "the", "chart's", "plot", "that", "you", "have", "replaced", "the", "dataset", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "as the build() method returns a closeablehttpclient which is-a autoclosable ,  you can place the declaration in a try-with-resources  statement", "tokens": ["as", "the", "build()", "method", "returns", "a", "closeablehttpclient", "which", "is-a", "autoclosable", ",", "", "you", "can", "place", "the", "declaration", "in", "a", "try-with-resources", "", "statement", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> build() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "build()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "build()", "label": "API", "asoc": []}]}
{"text": "well ,  besides operating on different stuff ,  collections.sort operates on a list ,  and arrays.sort operates on an array", "tokens": ["well", ",", "", "besides", "operating", "on", "different", "stuff", ",", "", "collections.sort", "operates", "on", "a", "list", ",", "", "and", "arrays.sort", "operates", "on", "an", "array", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> collections.sort <extra_id_0> behavior difference <extra_id_5> arrays.sort <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> arrays.sort <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "collections.sort"}, {"type": "API", "offset": [18], "text": "arrays.sort"}], "relation": [{"type": "behavior difference", "args": [{"type": "API", "offset": [10], "text": "collections.sort"}, {"type": "API", "offset": [18], "text": "arrays.sort"}]}], "event": [], "spot": ["API"], "asoc": ["behavior difference"], "spot_asoc": [{"span": "collections.sort", "label": "API", "asoc": [["behavior difference", "arrays.sort"]]}, {"span": "arrays.sort", "label": "API", "asoc": []}]}
{"text": "use indexof : note that you shouldn't generally use == to compare strings - that will compare references ,  i.e", "tokens": ["use", "indexof", ":", "note", "that", "you", "shouldn't", "generally", "use", "==", "to", "compare", "strings", "-", "that", "will", "compare", "references", ",", "", "i.e", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> indexof <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "indexof"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "indexof", "label": "API", "asoc": []}]}
{"text": "if the producer is not waiting through a wait() call ,  it must be outside the method (possibly waiting to enter the method and acquire the lock that way)", "tokens": ["if", "the", "producer", "is", "not", "waiting", "through", "a", "wait()", "call", ",", "", "it", "must", "be", "outside", "the", "method", "(possibly", "waiting", "to", "enter", "the", "method", "and", "acquire", "the", "lock", "that", "way)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "the java documentation for math.pow states", "tokens": ["the", "java", "documentation", "for", "math.pow", "states", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> math.pow <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "math.pow"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "math.pow", "label": "API", "asoc": []}]}
{"text": "it is also worth noting that if the nextint() call succeeded ,  the scanner would be positioned immediately after the last character of the number", "tokens": ["it", "is", "also", "worth", "noting", "that", "if", "the", "nextint()", "call", "succeeded", ",", "", "the", "scanner", "would", "be", "positioned", "immediately", "after", "the", "last", "character", "of", "the", "number", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "nextint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nextint()", "label": "API", "asoc": []}]}
{"text": "users are now asked to migrate to java.time (jsr-310)", "tokens": ["users", "are", "now", "asked", "to", "migrate", "to", "java.time", "(jsr-310)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "java.time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.time", "label": "API", "asoc": []}]}
{"text": "java 8 and above starting from java 8 you can use java.util.optional", "tokens": ["java", "8", "and", "above", "starting", "from", "java", "8", "you", "can", "use", "java.util.optional", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.optional <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "java.util.optional"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.optional", "label": "API", "asoc": []}]}
{"text": "you will see that your setreuseaddress(true) is being called too late i.e", "tokens": ["you", "will", "see", "that", "your", "setreuseaddress(true)", "is", "being", "called", "too", "late", "i.e", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> setreuseaddress(true) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "setreuseaddress(true)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "setreuseaddress(true)", "label": "API", "asoc": []}]}
{"text": "try system.out.println() on the runnable given to newthread in your example .", "tokens": ["try", "system.out.println()", "on", "the", "runnable", "given", "to", "newthread", "in", "your", "example", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.out.println() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "system.out.println()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.out.println()", "label": "API", "asoc": []}]}
{"text": "i suggest using  the java.text.dateformat as shown in this page :", "tokens": ["i", "suggest", "using", "", "the", "java.text.dateformat", "as", "shown", "in", "this", "page", ":", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.text.dateformat <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "java.text.dateformat"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.text.dateformat", "label": "API", "asoc": []}]}
{"text": "the main loop ( in this case a javax.swing.timer ) ,  tells the component that it should update it's movement as required", "tokens": ["the", "main", "loop", "(", "in", "this", "case", "a", "javax.swing.timer", ")", ",", "", "tells", "the", "component", "that", "it", "should", "update", "it's", "movement", "as", "required", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> javax.swing.timer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "javax.swing.timer"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "javax.swing.timer", "label": "API", "asoc": []}]}
{"text": "public final class getclass() is a public instance method declared 'final' in the object class and therefore if an interface tries to declare a method with this signature then the compilation will fail .", "tokens": ["public", "final", "class", "getclass()", "is", "a", "public", "instance", "method", "declared", "'final'", "in", "the", "object", "class", "and", "therefore", "if", "an", "interface", "tries", "to", "declare", "a", "method", "with", "this", "signature", "then", "the", "compilation", "will", "fail", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getclass() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "getclass()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getclass()", "label": "API", "asoc": []}]}
{"text": "to parse your date you can use  but if that fails and you are seeing  java.text.parseexception", "tokens": ["to", "parse", "your", "date", "you", "can", "use", "", "but", "if", "that", "fails", "and", "you", "are", "seeing", "", "java.text.parseexception", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.text.parseexception <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "java.text.parseexception"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.text.parseexception", "label": "API", "asoc": []}]}
{"text": "if we assume that there is something more sophisticated going on ,  not creating the same string in every iteration ,  well ,  then there is no benefit in calling intern()", "tokens": ["if", "we", "assume", "that", "there", "is", "something", "more", "sophisticated", "going", "on", ",", "", "not", "creating", "the", "same", "string", "in", "every", "iteration", ",", "", "well", ",", "", "then", "there", "is", "no", "benefit", "in", "calling", "intern()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> intern() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [33], "text": "intern()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "intern()", "label": "API", "asoc": []}]}
{"text": "by the time that you call dispose() ,  the observable is done ,  and nothing will happen -- disposing a completed observable has no effect .", "tokens": ["by", "the", "time", "that", "you", "call", "dispose()", ",", "", "the", "observable", "is", "done", ",", "", "and", "nothing", "will", "happen", "--", "disposing", "a", "completed", "observable", "has", "no", "effect", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> dispose() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "dispose()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "dispose()", "label": "API", "asoc": []}]}
{"text": "the codesource is available by protectiondomain.getcodesource()", "tokens": ["the", "codesource", "is", "available", "by", "protectiondomain.getcodesource()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> protectiondomain.getcodesource() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "protectiondomain.getcodesource()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "protectiondomain.getcodesource()", "label": "API", "asoc": []}]}
{"text": "the first block is a lot faster because equals() is executed for integer instead of hashset ,  which is a lot faster .", "tokens": ["the", "first", "block", "is", "a", "lot", "faster", "because", "equals()", "is", "executed", "for", "integer", "instead", "of", "hashset", ",", "", "which", "is", "a", "lot", "faster", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_0> function replace <extra_id_5> hashset <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> hashset <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "equals()"}, {"type": "API", "offset": [15], "text": "hashset"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [8], "text": "equals()"}, {"type": "API", "offset": [15], "text": "hashset"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": [["function replace", "hashset"]]}, {"span": "hashset", "label": "API", "asoc": []}]}
{"text": "by default all classes inherit java.lang.object", "tokens": ["by", "default", "all", "classes", "inherit", "java.lang.object", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.object <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "java.lang.object"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.object", "label": "API", "asoc": []}]}
{"text": "a task queued with execute() that generates some throwable will cause the uncaughtexceptionhandler for the thread running the task to be invoked", "tokens": ["a", "task", "queued", "with", "execute()", "that", "generates", "some", "throwable", "will", "cause", "the", "uncaughtexceptionhandler", "for", "the", "thread", "running", "the", "task", "to", "be", "invoked", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> execute() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "execute()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "execute()", "label": "API", "asoc": []}]}
{"text": "edit: note that delete() can be done to any element ,  and not only the head ,  however", "tokens": ["edit:", "note", "that", "delete()", "can", "be", "done", "to", "any", "element", ",", "", "and", "not", "only", "the", "head", ",", "", "however", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> delete() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "delete()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "delete()", "label": "API", "asoc": []}]}
{"text": "that format is specified in the date.tostring()", "tokens": ["that", "format", "is", "specified", "in", "the", "date.tostring()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> date.tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "date.tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "date.tostring()", "label": "API", "asoc": []}]}
{"text": "the problem is almost certainly because the array returned by bytebuffer.array() is the full backing array ,  but the data may only be contained within a portion of it", "tokens": ["the", "problem", "is", "almost", "certainly", "because", "the", "array", "returned", "by", "bytebuffer.array()", "is", "the", "full", "backing", "array", ",", "", "but", "the", "data", "may", "only", "be", "contained", "within", "a", "portion", "of", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> bytebuffer.array() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "bytebuffer.array()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "bytebuffer.array()", "label": "API", "asoc": []}]}
{"text": "it does have system.nanotime() ,  but that just gives an offset from some previously known time", "tokens": ["it", "does", "have", "system.nanotime()", ",", "", "but", "that", "just", "gives", "an", "offset", "from", "some", "previously", "known", "time", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.nanotime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "system.nanotime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.nanotime()", "label": "API", "asoc": []}]}
{"text": "to the point ,  you need to scan the entire classpath (and subfolders) for classes implementing java.sql.driver", "tokens": ["to", "the", "point", ",", "", "you", "need", "to", "scan", "the", "entire", "classpath", "(and", "subfolders)", "for", "classes", "implementing", "java.sql.driver", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.sql.driver <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "java.sql.driver"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.sql.driver", "label": "API", "asoc": []}]}
{"text": "you can try using system.arraycopy() but ,  probably better to use clone() in most cases:", "tokens": ["you", "can", "try", "using", "system.arraycopy()", "but", ",", "", "probably", "better", "to", "use", "clone()", "in", "most", "cases:", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.arraycopy() <extra_id_0> efficiency comparison <extra_id_5> clone() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> clone() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.arraycopy()"}, {"type": "API", "offset": [12], "text": "clone()"}], "relation": [{"type": "efficiency comparison", "args": [{"type": "API", "offset": [4], "text": "system.arraycopy()"}, {"type": "API", "offset": [12], "text": "clone()"}]}], "event": [], "spot": ["API"], "asoc": ["efficiency comparison"], "spot_asoc": [{"span": "system.arraycopy()", "label": "API", "asoc": [["efficiency comparison", "clone()"]]}, {"span": "clone()", "label": "API", "asoc": []}]}
{"text": "even if the thread.start() is the last statement in your constructor ,  the new thread may be accessing a partially constructed object because of the reordering", "tokens": ["even", "if", "the", "thread.start()", "is", "the", "last", "statement", "in", "your", "constructor", ",", "", "the", "new", "thread", "may", "be", "accessing", "a", "partially", "constructed", "object", "because", "of", "the", "reordering", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.start() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "thread.start()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.start()", "label": "API", "asoc": []}]}
{"text": "here is an example ,  this prints class comes from getclass() inherited from object edit: to get the getter or setter and its name .", "tokens": ["here", "is", "an", "example", ",", "", "this", "prints", "class", "comes", "from", "getclass()", "inherited", "from", "object", "edit:", "to", "get", "the", "getter", "or", "setter", "and", "its", "name", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getclass() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "getclass()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getclass()", "label": "API", "asoc": []}]}
{"text": "also ,  use revalidate() and repaint() to encourage the container to update it's layout when adding new components recommendations", "tokens": ["also", ",", "", "use", "revalidate()", "and", "repaint()", "to", "encourage", "the", "container", "to", "update", "it's", "layout", "when", "adding", "new", "components", "recommendations", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> revalidate() <extra_id_0> function collaboration <extra_id_5> repaint() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "revalidate()"}, {"type": "API", "offset": [6], "text": "repaint()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [4], "text": "revalidate()"}, {"type": "API", "offset": [6], "text": "repaint()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "revalidate()", "label": "API", "asoc": [["function collaboration", "repaint()"]]}, {"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "another feasible way is using java.net.socket", "tokens": ["another", "feasible", "way", "is", "using", "java.net.socket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.net.socket <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "java.net.socket"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.net.socket", "label": "API", "asoc": []}]}
{"text": "the new random().nextint() generates a random positive number", "tokens": ["the", "new", "random().nextint()", "generates", "a", "random", "positive", "number", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> random().nextint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "random().nextint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "random().nextint()", "label": "API", "asoc": []}]}
{"text": "calling run will execute run() method in the same thread ,  without starting new thread .", "tokens": ["calling", "run", "will", "execute", "run()", "method", "in", "the", "same", "thread", ",", "", "without", "starting", "new", "thread", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> run() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "run()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "run()", "label": "API", "asoc": []}]}
{"text": "check the api for suitable types; a java.lang.string should be acceptable", "tokens": ["check", "the", "api", "for", "suitable", "types;", "a", "java.lang.string", "should", "be", "acceptable", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "now look at implementation of thread.start() : because threadstatus has not been stored/restored properly you can start a second time", "tokens": ["now", "look", "at", "implementation", "of", "thread.start()", ":", "because", "threadstatus", "has", "not", "been", "stored/restored", "properly", "you", "can", "start", "a", "second", "time", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.start() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "thread.start()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.start()", "label": "API", "asoc": []}]}
{"text": "now ,  you are at the mercy of the output stream and how often the writing portion of your program calls flush() so there may be a delay", "tokens": ["now", ",", "", "you", "are", "at", "the", "mercy", "of", "the", "output", "stream", "and", "how", "often", "the", "writing", "portion", "of", "your", "program", "calls", "flush()", "so", "there", "may", "be", "a", "delay", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> flush() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "flush()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "flush()", "label": "API", "asoc": []}]}
{"text": "let's further assume that equals() is implemented correctly on this object ,  that is ,  that it checks all of these fields correctly", "tokens": ["let's", "further", "assume", "that", "equals()", "is", "implemented", "correctly", "on", "this", "object", ",", "", "that", "is", ",", "", "that", "it", "checks", "all", "of", "these", "fields", "correctly", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "equals()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": []}]}
{"text": "in java 1.4 and earlier they used java.lang.object as the type for any object added to the collection", "tokens": ["in", "java", "1.4", "and", "earlier", "they", "used", "java.lang.object", "as", "the", "type", "for", "any", "object", "added", "to", "the", "collection", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.object <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "java.lang.object"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.object", "label": "API", "asoc": []}]}
{"text": "you need to check whether string is not empty before using parseint() function", "tokens": ["you", "need", "to", "check", "whether", "string", "is", "not", "empty", "before", "using", "parseint()", "function", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> parseint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "parseint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "parseint()", "label": "API", "asoc": []}]}
{"text": "use file's getparentfile() method and string.lastindexof() to retrieve just the immediate parent directory", "tokens": ["use", "file's", "getparentfile()", "method", "and", "string.lastindexof()", "to", "retrieve", "just", "the", "immediate", "parent", "directory", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getparentfile() <extra_id_0> function collaboration <extra_id_5> string.lastindexof() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> string.lastindexof() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "getparentfile()"}, {"type": "API", "offset": [5], "text": "string.lastindexof()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [2], "text": "getparentfile()"}, {"type": "API", "offset": [5], "text": "string.lastindexof()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "getparentfile()", "label": "API", "asoc": [["function collaboration", "string.lastindexof()"]]}, {"span": "string.lastindexof()", "label": "API", "asoc": []}]}
{"text": "2018-12-31t23:37z use the modern java.time classes ,  not those terrible legacy classes such as date", "tokens": ["2018-12-31t23:37z", "use", "the", "modern", "java.time", "classes", ",", "", "not", "those", "terrible", "legacy", "classes", "such", "as", "date", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "java.time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.time", "label": "API", "asoc": []}]}
{"text": "using java.nio.channels.filechannel : java nio classes were introduced in java 1.4 and filechannel can be used to copy file in java", "tokens": ["using", "java.nio.channels.filechannel", ":", "java", "nio", "classes", "were", "introduced", "in", "java", "1.4", "and", "filechannel", "can", "be", "used", "to", "copy", "file", "in", "java", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.nio.channels.filechannel <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "java.nio.channels.filechannel"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.nio.channels.filechannel", "label": "API", "asoc": []}]}
{"text": "you're calling string.valueof to store the icon in your database", "tokens": ["you're", "calling", "string.valueof", "to", "store", "the", "icon", "in", "your", "database", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.valueof <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "string.valueof"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.valueof", "label": "API", "asoc": []}]}
{"text": "if you're using java 8 try using the new java.time api which uses immutable objects", "tokens": ["if", "you're", "using", "java", "8", "try", "using", "the", "new", "java.time", "api", "which", "uses", "immutable", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "java.time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.time", "label": "API", "asoc": []}]}
{"text": "if you have a specific jar file and you know the path within that jar file then you could simply treat that file as archive and access it via java.util.jar.jarfile which lets you list all entries in the file", "tokens": ["if", "you", "have", "a", "specific", "jar", "file", "and", "you", "know", "the", "path", "within", "that", "jar", "file", "then", "you", "could", "simply", "treat", "that", "file", "as", "archive", "and", "access", "it", "via", "java.util.jar.jarfile", "which", "lets", "you", "list", "all", "entries", "in", "the", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.jar.jarfile <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [29], "text": "java.util.jar.jarfile"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.jar.jarfile", "label": "API", "asoc": []}]}
{"text": "especially once they start to get their own methods like getname() ,  getid() ,  etc. .", "tokens": ["especially", "once", "they", "start", "to", "get", "their", "own", "methods", "like", "getname()", ",", "", "getid()", ",", "", "etc.", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getname() <extra_id_0> function similarity <extra_id_5> getid() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> getid() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getname()"}, {"type": "API", "offset": [13], "text": "getid()"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [10], "text": "getname()"}, {"type": "API", "offset": [13], "text": "getid()"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "getname()", "label": "API", "asoc": [["function similarity", "getid()"]]}, {"span": "getid()", "label": "API", "asoc": []}]}
{"text": "all you need to do is use substring()", "tokens": ["all", "you", "need", "to", "do", "is", "use", "substring()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> substring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "substring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "substring()", "label": "API", "asoc": []}]}
{"text": "secondary ,  you mention calling add() multiple times. .", "tokens": ["secondary", ",", "", "you", "mention", "calling", "add()", "multiple", "times.", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> add() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "add()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "add()", "label": "API", "asoc": []}]}
{"text": "you can do this through getactivity().runonuithread()", "tokens": ["you", "can", "do", "this", "through", "getactivity().runonuithread()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getactivity().runonuithread() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "getactivity().runonuithread()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getactivity().runonuithread()", "label": "API", "asoc": []}]}
{"text": "from the javadoc for reset() brokenbarrierexception so reset causes any currently waiting threads to throw a brokenbarrierexception and wake immediately", "tokens": ["from", "the", "javadoc", "for", "reset()", "brokenbarrierexception", "so", "reset", "causes", "any", "currently", "waiting", "threads", "to", "throw", "a", "brokenbarrierexception", "and", "wake", "immediately", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> reset() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "reset()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "reset()", "label": "API", "asoc": []}]}
{"text": "basically ,  you shouldn't use date.tostring() for anything other than debugging", "tokens": ["basically", ",", "", "you", "shouldn't", "use", "date.tostring()", "for", "anything", "other", "than", "debugging", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> date.tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "date.tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "date.tostring()", "label": "API", "asoc": []}]}
{"text": "preparedstatement.setdate takes a java.sql.date ,  not a java.util.date", "tokens": ["preparedstatement.setdate", "takes", "a", "java.sql.date", ",", "", "not", "a", "java.util.date", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.sql.date <extra_id_0> function replace <extra_id_5> java.util.date <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> java.util.date <extra_id_1> <extra_id_0> API <extra_id_5> preparedstatement.setdate <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "java.sql.date"}, {"type": "API", "offset": [8], "text": "java.util.date"}, {"type": "API", "offset": [0], "text": "preparedstatement.setdate"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [3], "text": "java.sql.date"}, {"type": "API", "offset": [8], "text": "java.util.date"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "java.sql.date", "label": "API", "asoc": [["function replace", "java.util.date"]]}, {"span": "java.util.date", "label": "API", "asoc": []}, {"span": "preparedstatement.setdate", "label": "API", "asoc": []}]}
{"text": "your java file is missing an import statement for java.util.list ,  which is why it's failing to compile", "tokens": ["your", "java", "file", "is", "missing", "an", "import", "statement", "for", "java.util.list", ",", "", "which", "is", "why", "it's", "failing", "to", "compile", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.list <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "java.util.list"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.list", "label": "API", "asoc": []}]}
{"text": "to create a formatted string out a localdatetime object you can use the format() method", "tokens": ["to", "create", "a", "formatted", "string", "out", "a", "localdatetime", "object", "you", "can", "use", "the", "format()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> localdatetime <extra_id_0> logic constraint <extra_id_5> format() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> format() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "localdatetime", "label": "API", "asoc": [["logic constraint", "format()"]]}, {"span": "format()", "label": "API", "asoc": []}]}
{"text": "you can call get() on a future as often as you like ,  and it will only block if the task that produces the result has not finished yet", "tokens": ["you", "can", "call", "get()", "on", "a", "future", "as", "often", "as", "you", "like", ",", "", "and", "it", "will", "only", "block", "if", "the", "task", "that", "produces", "the", "result", "has", "not", "finished", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "get()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "get()", "label": "API", "asoc": []}]}
{"text": "it feels ugly to write it as a string and call getbytes() ,  but perhaps you can look into this", "tokens": ["it", "feels", "ugly", "to", "write", "it", "as", "a", "string", "and", "call", "getbytes()", ",", "", "but", "perhaps", "you", "can", "look", "into", "this", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getbytes() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "getbytes()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getbytes()", "label": "API", "asoc": []}]}
{"text": "arrays.sort returns void not int[] type", "tokens": ["arrays.sort", "returns", "void", "not", "int[]", "type", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "arrays.sort"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort", "label": "API", "asoc": []}]}
{"text": "from the object.tostring docs: tostring the tostring method for class object example:", "tokens": ["from", "the", "object.tostring", "docs:", "tostring", "the", "tostring", "method", "for", "class", "object", "example:", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> object.tostring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "object.tostring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "object.tostring", "label": "API", "asoc": []}]}
{"text": "yes ,  after calling flush() ,  the dbms is now aware of your data - but following acid standards ,  no other database sessions will see this data until the dbms is told to commit it", "tokens": ["yes", ",", "", "after", "calling", "flush()", ",", "", "the", "dbms", "is", "now", "aware", "of", "your", "data", "-", "but", "following", "acid", "standards", ",", "", "no", "other", "database", "sessions", "will", "see", "this", "data", "until", "the", "dbms", "is", "told", "to", "commit", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> flush() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "flush()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "flush()", "label": "API", "asoc": []}]}
{"text": "through the use of a single javax.swing.timer ,  you could iterate through the balls list and update there positions", "tokens": ["through", "the", "use", "of", "a", "single", "javax.swing.timer", ",", "", "you", "could", "iterate", "through", "the", "balls", "list", "and", "update", "there", "positions", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> javax.swing.timer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "javax.swing.timer"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "javax.swing.timer", "label": "API", "asoc": []}]}
{"text": "then you can see that you program will sit in wait() forever .", "tokens": ["then", "you", "can", "see", "that", "you", "program", "will", "sit", "in", "wait()", "forever", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "calling file.isdirectory() will test if it is a directory", "tokens": ["calling", "file.isdirectory()", "will", "test", "if", "it", "is", "a", "directory", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.isdirectory() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.isdirectory()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.isdirectory()", "label": "API", "asoc": []}]}
{"text": "the fxmlloader has a getcontroller() method that allows you to retrieve a reference to the controller", "tokens": ["the", "fxmlloader", "has", "a", "getcontroller()", "method", "that", "allows", "you", "to", "retrieve", "a", "reference", "to", "the", "controller", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontroller() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "getcontroller()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontroller()", "label": "API", "asoc": []}]}
{"text": "the arraylist uses overridden equals() methods to compare contents", "tokens": ["the", "arraylist", "uses", "overridden", "equals()", "methods", "to", "compare", "contents", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arraylist <extra_id_0> logic constraint <extra_id_5> equals() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> equals() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "arraylist"}, {"type": "API", "offset": [4], "text": "equals()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [1], "text": "arraylist"}, {"type": "API", "offset": [4], "text": "equals()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "arraylist", "label": "API", "asoc": [["logic constraint", "equals()"]]}, {"span": "equals()", "label": "API", "asoc": []}]}
{"text": "however ,  you're not displaying it in utc ,  because of the way date.tostring() works (it always uses the system local time zone)", "tokens": ["however", ",", "", "you're", "not", "displaying", "it", "in", "utc", ",", "", "because", "of", "the", "way", "date.tostring()", "works", "(it", "always", "uses", "the", "system", "local", "time", "zone)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> date.tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "date.tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "date.tostring()", "label": "API", "asoc": []}]}
{"text": "although new scanner(filereader) works ,  you could rather pass the file name directly into the scanner's constructor .", "tokens": ["although", "new", "scanner(filereader)", "works", ",", "", "you", "could", "rather", "pass", "the", "file", "name", "directly", "into", "the", "scanner's", "constructor", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> scanner(filereader) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "scanner(filereader)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "scanner(filereader)", "label": "API", "asoc": []}]}
{"text": "(this probably should use wait / notify . .", "tokens": ["(this", "probably", "should", "use", "wait", "/", "notify", ".", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait <extra_id_0> function similarity <extra_id_5> notify <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> notify <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "wait"}, {"type": "API", "offset": [6], "text": "notify"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [4], "text": "wait"}, {"type": "API", "offset": [6], "text": "notify"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "wait", "label": "API", "asoc": [["function similarity", "notify"]]}, {"span": "notify", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can return the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "return", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "flip() sets the limit (length) of the buffer to the current position and then the position is set to zero", "tokens": ["flip()", "sets", "the", "limit", "(length)", "of", "the", "buffer", "to", "the", "current", "position", "and", "then", "the", "position", "is", "set", "to", "zero", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> flip() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "flip()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "flip()", "label": "API", "asoc": []}]}
{"text": "that sets the thread.isinterrupted() to true and causes wait() ,  sleep() ,  and a couple other methods to throw interruptedexception", "tokens": ["that", "sets", "the", "thread.isinterrupted()", "to", "true", "and", "causes", "wait()", ",", "", "sleep()", ",", "", "and", "a", "couple", "other", "methods", "to", "throw", "interruptedexception", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.isinterrupted() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "thread.isinterrupted()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.isinterrupted()", "label": "API", "asoc": []}]}
{"text": "you are ignoring the result of connect() ,  which if true means that op_connect will never fire ,  because the channel is already connected", "tokens": ["you", "are", "ignoring", "the", "result", "of", "connect()", ",", "", "which", "if", "true", "means", "that", "op_connect", "will", "never", "fire", ",", "", "because", "the", "channel", "is", "already", "connected", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> connect() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "connect()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "connect()", "label": "API", "asoc": []}]}
{"text": "you should never call thread.sleep() on the edt", "tokens": ["you", "should", "never", "call", "thread.sleep()", "on", "the", "edt", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "thread.sleep()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep()", "label": "API", "asoc": []}]}
{"text": "instead of java.util.timer ,  javax.swing.timer may be more convenient ,  as seen in this example .", "tokens": ["instead", "of", "java.util.timer", ",", "", "javax.swing.timer", "may", "be", "more", "convenient", ",", "", "as", "seen", "in", "this", "example", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.timer <extra_id_0> efficiency comparison <extra_id_5> javax.swing.timer <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> javax.swing.timer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "java.util.timer"}, {"type": "API", "offset": [5], "text": "javax.swing.timer"}], "relation": [{"type": "efficiency comparison", "args": [{"type": "API", "offset": [2], "text": "java.util.timer"}, {"type": "API", "offset": [5], "text": "javax.swing.timer"}]}], "event": [], "spot": ["API"], "asoc": ["efficiency comparison"], "spot_asoc": [{"span": "java.util.timer", "label": "API", "asoc": [["efficiency comparison", "javax.swing.timer"]]}, {"span": "javax.swing.timer", "label": "API", "asoc": []}]}
{"text": "it looks to me like this workaround is required because of a possible bug in javax.swing.scrollpanelayout", "tokens": ["it", "looks", "to", "me", "like", "this", "workaround", "is", "required", "because", "of", "a", "possible", "bug", "in", "javax.swing.scrollpanelayout", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> javax.swing.scrollpanelayout <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "javax.swing.scrollpanelayout"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "javax.swing.scrollpanelayout", "label": "API", "asoc": []}]}
{"text": "uuid uses java.security.securerandom ,  which is supposed to be \"cryptographically strong\"", "tokens": ["uuid", "uses", "java.security.securerandom", ",", "", "which", "is", "supposed", "to", "be", "\"cryptographically", "strong\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.security.securerandom <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "java.security.securerandom"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.security.securerandom", "label": "API", "asoc": []}]}
{"text": "this methods required an object of type java.sql.driver", "tokens": ["this", "methods", "required", "an", "object", "of", "type", "java.sql.driver", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.sql.driver <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "java.sql.driver"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.sql.driver", "label": "API", "asoc": []}]}
{"text": "unless you add imageio.scanforplugins() somewhere in your code ,  the plugins might never be available at all", "tokens": ["unless", "you", "add", "imageio.scanforplugins()", "somewhere", "in", "your", "code", ",", "", "the", "plugins", "might", "never", "be", "available", "at", "all", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> imageio.scanforplugins() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "imageio.scanforplugins()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "imageio.scanforplugins()", "label": "API", "asoc": []}]}
{"text": "(...) java.util.locale for the current request locale ,  determined by the most specific locale resolver available ,  in effect ,  the configured localeresolver in a servlet environment", "tokens": ["(...)", "java.util.locale", "for", "the", "current", "request", "locale", ",", "", "determined", "by", "the", "most", "specific", "locale", "resolver", "available", ",", "", "in", "effect", ",", "", "the", "configured", "localeresolver", "in", "a", "servlet", "environment", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.locale <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "java.util.locale"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.locale", "label": "API", "asoc": []}]}
{"text": "use collections.shuffle() : it enables you to get n unique elements by an incremented index (assuming that the list itself contains unique elements)", "tokens": ["use", "collections.shuffle()", ":", "it", "enables", "you", "to", "get", "n", "unique", "elements", "by", "an", "incremented", "index", "(assuming", "that", "the", "list", "itself", "contains", "unique", "elements)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> collections.shuffle() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "collections.shuffle()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "collections.shuffle()", "label": "API", "asoc": []}]}
{"text": "your snippet is incorrectly synchronized; you should update your dataset from the process() method of a swingworker ,  as shown here", "tokens": ["your", "snippet", "is", "incorrectly", "synchronized;", "you", "should", "update", "your", "dataset", "from", "the", "process()", "method", "of", "a", "swingworker", ",", "", "as", "shown", "here", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> process() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "process()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "process()", "label": "API", "asoc": []}]}
{"text": "with this rule you are able to test code ,  that calls system.exit() : system rules needs at least junit 4.9", "tokens": ["with", "this", "rule", "you", "are", "able", "to", "test", "code", ",", "", "that", "calls", "system.exit()", ":", "system", "rules", "needs", "at", "least", "junit", "4.9", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.exit() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "system.exit()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.exit()", "label": "API", "asoc": []}]}
{"text": "from observability of a package: the packages java ,  java.lang ,  and java.io are always observable", "tokens": ["from", "observability", "of", "a", "package:", "the", "packages", "java", ",", "", "java.lang", ",", "", "and", "java.io", "are", "always", "observable", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang <extra_id_0> function similarity <extra_id_5> java.io <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> java.io <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "java.lang"}, {"type": "API", "offset": [14], "text": "java.io"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [10], "text": "java.lang"}, {"type": "API", "offset": [14], "text": "java.io"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "java.lang", "label": "API", "asoc": [["function similarity", "java.io"]]}, {"span": "java.io", "label": "API", "asoc": []}]}
{"text": "since this is a swing application ,  don't use a java.util.timer but rather a javax.swing.timer also known as a swing timer", "tokens": ["since", "this", "is", "a", "swing", "application", ",", "", "don't", "use", "a", "java.util.timer", "but", "rather", "a", "javax.swing.timer", "also", "known", "as", "a", "swing", "timer", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.timer <extra_id_0> function replace <extra_id_5> javax.swing.timer <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> javax.swing.timer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "java.util.timer"}, {"type": "API", "offset": [15], "text": "javax.swing.timer"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [11], "text": "java.util.timer"}, {"type": "API", "offset": [15], "text": "javax.swing.timer"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "java.util.timer", "label": "API", "asoc": [["function replace", "javax.swing.timer"]]}, {"span": "javax.swing.timer", "label": "API", "asoc": []}]}
{"text": "have you tried embedding both reques ts and responses in bufferedinputstream / bufferedoutputstream  ?  it should widely improve performances .", "tokens": ["have", "you", "tried", "embedding", "both", "reques", "ts", "and", "responses", "in", "bufferedinputstream", "/", "bufferedoutputstream", "", "?", "", "it", "should", "widely", "improve", "performances", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> bufferedinputstream <extra_id_0> function collaboration <extra_id_5> bufferedoutputstream <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> bufferedoutputstream <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "bufferedinputstream"}, {"type": "API", "offset": [12], "text": "bufferedoutputstream"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [10], "text": "bufferedinputstream"}, {"type": "API", "offset": [12], "text": "bufferedoutputstream"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "bufferedinputstream", "label": "API", "asoc": [["function collaboration", "bufferedoutputstream"]]}, {"span": "bufferedoutputstream", "label": "API", "asoc": []}]}
{"text": "but do you know anything about java.lang.string objects ?", "tokens": ["but", "do", "you", "know", "anything", "about", "java.lang.string", "objects", "?", "", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "you can use java.lang.thread for parallel execution", "tokens": ["you", "can", "use", "java.lang.thread", "for", "parallel", "execution", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.thread <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "java.lang.thread"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.thread", "label": "API", "asoc": []}]}
{"text": "from jdk 7 you can use files.readallbytes(path)", "tokens": ["from", "jdk", "7", "you", "can", "use", "files.readallbytes(path)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> files.readallbytes(path) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "files.readallbytes(path)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "files.readallbytes(path)", "label": "API", "asoc": []}]}
{"text": "a java.sql.timestamp actually does have (up to) nanosecond precision (assuming the database server and the driver actually support it)", "tokens": ["a", "java.sql.timestamp", "actually", "does", "have", "(up", "to)", "nanosecond", "precision", "(assuming", "the", "database", "server", "and", "the", "driver", "actually", "support", "it)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.sql.timestamp <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "java.sql.timestamp"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.sql.timestamp", "label": "API", "asoc": []}]}
{"text": "i assume the reason you want access to the native java.sql.connection is because you want access to a vendor connection class so you have access to vendor extensions", "tokens": ["i", "assume", "the", "reason", "you", "want", "access", "to", "the", "native", "java.sql.connection", "is", "because", "you", "want", "access", "to", "a", "vendor", "connection", "class", "so", "you", "have", "access", "to", "vendor", "extensions", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.sql.connection <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "java.sql.connection"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.sql.connection", "label": "API", "asoc": []}]}
{"text": "use the matcher.replaceall() method to replace all matches in the string note: using the \\b regex command will match on a word boundary (like whitespace)", "tokens": ["use", "the", "matcher.replaceall()", "method", "to", "replace", "all", "matches", "in", "the", "string", "note:", "using", "the", "\\b", "regex", "command", "will", "match", "on", "a", "word", "boundary", "(like", "whitespace)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> matcher.replaceall() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "matcher.replaceall()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "matcher.replaceall()", "label": "API", "asoc": []}]}
{"text": "note that it might not be this ,  because system.currenttimemillis() doesn't progress smoothly ,  owing to corrections for clock skew", "tokens": ["note", "that", "it", "might", "not", "be", "this", ",", "", "because", "system.currenttimemillis()", "doesn't", "progress", "smoothly", ",", "", "owing", "to", "corrections", "for", "clock", "skew", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.currenttimemillis() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "system.currenttimemillis()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.currenttimemillis()", "label": "API", "asoc": []}]}
{"text": "so i was expecting a compiling error due to the fact that the compiler would not be able to find the java.lang.string class file", "tokens": ["so", "i", "was", "expecting", "a", "compiling", "error", "due", "to", "the", "fact", "that", "the", "compiler", "would", "not", "be", "able", "to", "find", "the", "java.lang.string", "class", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "i think you'll have to live with the @suppresswarnings(...) approach since the invoke() method returns an object", "tokens": ["i", "think", "you'll", "have", "to", "live", "with", "the", "@suppresswarnings(...)", "approach", "since", "the", "invoke()", "method", "returns", "an", "object", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> invoke() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "invoke()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "invoke()", "label": "API", "asoc": []}]}
{"text": "so how can you store nothing in it or have it empty ?  it can only store references to instances of java.util.date", "tokens": ["so", "how", "can", "you", "store", "nothing", "in", "it", "or", "have", "it", "empty", "?", "", "it", "can", "only", "store", "references", "to", "instances", "of", "java.util.date", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.date <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "java.util.date"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.date", "label": "API", "asoc": []}]}
{"text": "the input 'aab' can switch char 0 and char 1 but still be 'aab.'  i used a treeset to preserve ordering for easier verification of the output ,  but hashset would be faster", "tokens": ["the", "input", "'aab'", "can", "switch", "char", "0", "and", "char", "1", "but", "still", "be", "'aab.'", "", "i", "used", "a", "treeset", "to", "preserve", "ordering", "for", "easier", "verification", "of", "the", "output", ",", "", "but", "hashset", "would", "be", "faster", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> treeset <extra_id_0> efficiency comparison <extra_id_5> hashset <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> hashset <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "treeset"}, {"type": "API", "offset": [31], "text": "hashset"}], "relation": [{"type": "efficiency comparison", "args": [{"type": "API", "offset": [18], "text": "treeset"}, {"type": "API", "offset": [31], "text": "hashset"}]}], "event": [], "spot": ["API"], "asoc": ["efficiency comparison"], "spot_asoc": [{"span": "treeset", "label": "API", "asoc": [["efficiency comparison", "hashset"]]}, {"span": "hashset", "label": "API", "asoc": []}]}
{"text": "equals() tests for value equality", "tokens": ["equals()", "tests", "for", "value", "equality", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "equals()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": []}]}
{"text": "when you plan to insert only at the end of a list ,  arraylist is the implementation of choice .", "tokens": ["when", "you", "plan", "to", "insert", "only", "at", "the", "end", "of", "a", "list", ",", "", "arraylist", "is", "the", "implementation", "of", "choice", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arraylist <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "arraylist"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arraylist", "label": "API", "asoc": []}]}
{"text": "read the java.text.simpledateformat javadoc what the individual parts stands for", "tokens": ["read", "the", "java.text.simpledateformat", "javadoc", "what", "the", "individual", "parts", "stands", "for", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.text.simpledateformat <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "java.text.simpledateformat"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.text.simpledateformat", "label": "API", "asoc": []}]}
{"text": "join() will make the currently executing thread to wait for the the thread it is called on to die", "tokens": ["join()", "will", "make", "the", "currently", "executing", "thread", "to", "wait", "for", "the", "the", "thread", "it", "is", "called", "on", "to", "die", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> join() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "join()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "join()", "label": "API", "asoc": []}]}
{"text": "you can access the text by calling the text() method on the element", "tokens": ["you", "can", "access", "the", "text", "by", "calling", "the", "text()", "method", "on", "the", "element", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> text() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "text()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "text()", "label": "API", "asoc": []}]}
{"text": "then you can use the getsource() method to tell which combobox the event came from", "tokens": ["then", "you", "can", "use", "the", "getsource()", "method", "to", "tell", "which", "combobox", "the", "event", "came", "from", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getsource() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "getsource()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getsource()", "label": "API", "asoc": []}]}
{"text": "now when the thread is notified either by notify() or by notifyall() call on the same object then the waiting state of the thread ends", "tokens": ["now", "when", "the", "thread", "is", "notified", "either", "by", "notify()", "or", "by", "notifyall()", "call", "on", "the", "same", "object", "then", "the", "waiting", "state", "of", "the", "thread", "ends", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> notify() <extra_id_0> function similarity <extra_id_5> notifyall() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> notifyall() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "notify()"}, {"type": "API", "offset": [11], "text": "notifyall()"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [8], "text": "notify()"}, {"type": "API", "offset": [11], "text": "notifyall()"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "notify()", "label": "API", "asoc": [["function similarity", "notifyall()"]]}, {"span": "notifyall()", "label": "API", "asoc": []}]}
{"text": "if you must interact with old code not yet updated for java.time types ,  you can convert to/from java.time types", "tokens": ["if", "you", "must", "interact", "with", "old", "code", "not", "yet", "updated", "for", "java.time", "types", ",", "", "you", "can", "convert", "to/from", "java.time", "types", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "java.time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.time", "label": "API", "asoc": []}]}
{"text": "you can't modify this map while iterating on it ,  except by invoking remove() on the iterator", "tokens": ["you", "can't", "modify", "this", "map", "while", "iterating", "on", "it", ",", "", "except", "by", "invoking", "remove()", "on", "the", "iterator", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "remove()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove()", "label": "API", "asoc": []}]}
{"text": "stringbuffer is synchronized ,  stringbuilder is not .", "tokens": ["stringbuffer", "is", "synchronized", ",", "", "stringbuilder", "is", "not", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> stringbuffer <extra_id_0> behavior difference <extra_id_5> stringbuilder <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> stringbuilder <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "stringbuffer"}, {"type": "API", "offset": [5], "text": "stringbuilder"}], "relation": [{"type": "behavior difference", "args": [{"type": "API", "offset": [0], "text": "stringbuffer"}, {"type": "API", "offset": [5], "text": "stringbuilder"}]}], "event": [], "spot": ["API"], "asoc": ["behavior difference"], "spot_asoc": [{"span": "stringbuffer", "label": "API", "asoc": [["behavior difference", "stringbuilder"]]}, {"span": "stringbuilder", "label": "API", "asoc": []}]}
{"text": "in your compareto() method ,  when you detect that you are looking at two strings representing integers ,  make sure they are the same length before comparing them", "tokens": ["in", "your", "compareto()", "method", ",", "", "when", "you", "detect", "that", "you", "are", "looking", "at", "two", "strings", "representing", "integers", ",", "", "make", "sure", "they", "are", "the", "same", "length", "before", "comparing", "them", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> compareto() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "compareto()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "compareto()", "label": "API", "asoc": []}]}
{"text": "use javax.swing.timer to schedule a future event to trigger", "tokens": ["use", "javax.swing.timer", "to", "schedule", "a", "future", "event", "to", "trigger", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> javax.swing.timer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "javax.swing.timer"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "javax.swing.timer", "label": "API", "asoc": []}]}
{"text": "as an aside ,  you don't want to override the update() method for swing gui's as that's mainly for awt gui's ,  unless you're changing the application's look and feel in mid run", "tokens": ["as", "an", "aside", ",", "", "you", "don't", "want", "to", "override", "the", "update()", "method", "for", "swing", "gui's", "as", "that's", "mainly", "for", "awt", "gui's", ",", "", "unless", "you're", "changing", "the", "application's", "look", "and", "feel", "in", "mid", "run", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> update() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "update()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "update()", "label": "API", "asoc": []}]}
{"text": "the problem is that arraylist.remove() has two methods ,  one that is an object ,  and one that is an (int index)", "tokens": ["the", "problem", "is", "that", "arraylist.remove()", "has", "two", "methods", ",", "", "one", "that", "is", "an", "object", ",", "", "and", "one", "that", "is", "an", "(int", "index)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arraylist.remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "arraylist.remove()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arraylist.remove()", "label": "API", "asoc": []}]}
{"text": "this answer explains when the equals() method is called by the hashset and when it isn't", "tokens": ["this", "answer", "explains", "when", "the", "equals()", "method", "is", "called", "by", "the", "hashset", "and", "when", "it", "isn't", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_0> logic constraint <extra_id_5> hashset <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> hashset <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashset"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [5], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashset"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": [["logic constraint", "hashset"]]}, {"span": "hashset", "label": "API", "asoc": []}]}
{"text": "withzonesamelocal() will change the zone but keep all the other fields the same", "tokens": ["withzonesamelocal()", "will", "change", "the", "zone", "but", "keep", "all", "the", "other", "fields", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> withzonesamelocal() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "withzonesamelocal()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "withzonesamelocal()", "label": "API", "asoc": []}]}
{"text": "you need to call repaint() and revalidate()", "tokens": ["you", "need", "to", "call", "repaint()", "and", "revalidate()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_0> function collaboration <extra_id_5> revalidate() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> revalidate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "repaint()"}, {"type": "API", "offset": [6], "text": "revalidate()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [4], "text": "repaint()"}, {"type": "API", "offset": [6], "text": "revalidate()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": [["function collaboration", "revalidate()"]]}, {"span": "revalidate()", "label": "API", "asoc": []}]}
{"text": "you can assert that the two sets are equal to one another ,  which invokes the set equals() method .", "tokens": ["you", "can", "assert", "that", "the", "two", "sets", "are", "equal", "to", "one", "another", ",", "", "which", "invokes", "the", "set", "equals()", "method", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "equals()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": []}]}
{"text": "(i still prefer it over the system.exit() call ,  but using reflection in this way is somewhat fragile.)", "tokens": ["(i", "still", "prefer", "it", "over", "the", "system.exit()", "call", ",", "", "but", "using", "reflection", "in", "this", "way", "is", "somewhat", "fragile.)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.exit() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "system.exit()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.exit()", "label": "API", "asoc": []}]}
{"text": "fetch rows in your implementation of doinbackground() ,  publish() interim results ,  and add them to the table model in your implementation of process()", "tokens": ["fetch", "rows", "in", "your", "implementation", "of", "doinbackground()", ",", "", "publish()", "interim", "results", ",", "", "and", "add", "them", "to", "the", "table", "model", "in", "your", "implementation", "of", "process()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> doinbackground() <extra_id_0> function collaboration <extra_id_5> publish() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> publish() <extra_id_1> <extra_id_0> API <extra_id_5> process() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "doinbackground()"}, {"type": "API", "offset": [9], "text": "publish()"}, {"type": "API", "offset": [25], "text": "process()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [6], "text": "doinbackground()"}, {"type": "API", "offset": [9], "text": "publish()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "doinbackground()", "label": "API", "asoc": [["function collaboration", "publish()"]]}, {"span": "publish()", "label": "API", "asoc": []}, {"span": "process()", "label": "API", "asoc": []}]}
{"text": "in short paintcomponent() is a method defined in jpanel or your own custom class that extends jpanel", "tokens": ["in", "short", "paintcomponent()", "is", "a", "method", "defined", "in", "jpanel", "or", "your", "own", "custom", "class", "that", "extends", "jpanel", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> paintcomponent() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "paintcomponent()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "paintcomponent()", "label": "API", "asoc": []}]}
{"text": "because the first thread has already checked the condition however ,  it will simply call wait() after being re-scheduled ,  even though it could make progress", "tokens": ["because", "the", "first", "thread", "has", "already", "checked", "the", "condition", "however", ",", "", "it", "will", "simply", "call", "wait()", "after", "being", "re-scheduled", ",", "", "even", "though", "it", "could", "make", "progress", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "for the first iteration it's good enough as long as you call method setfilter every time user types something in your jtextfield .", "tokens": ["for", "the", "first", "iteration", "it's", "good", "enough", "as", "long", "as", "you", "call", "method", "setfilter", "every", "time", "user", "types", "something", "in", "your", "jtextfield", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> setfilter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "setfilter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "setfilter", "label": "API", "asoc": []}]}
{"text": "so your bytebuffer code will be more efficient than your fileoutputstream code .", "tokens": ["so", "your", "bytebuffer", "code", "will", "be", "more", "efficient", "than", "your", "fileoutputstream", "code", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> bytebuffer <extra_id_0> efficiency comparison <extra_id_5> fileoutputstream <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> fileoutputstream <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "bytebuffer"}, {"type": "API", "offset": [10], "text": "fileoutputstream"}], "relation": [{"type": "efficiency comparison", "args": [{"type": "API", "offset": [2], "text": "bytebuffer"}, {"type": "API", "offset": [10], "text": "fileoutputstream"}]}], "event": [], "spot": ["API"], "asoc": ["efficiency comparison"], "spot_asoc": [{"span": "bytebuffer", "label": "API", "asoc": [["efficiency comparison", "fileoutputstream"]]}, {"span": "fileoutputstream", "label": "API", "asoc": []}]}
{"text": "it's very compact: a hashset is used here to give good look-up performance - even very large hash sets are able to execute contains() extremely quickly", "tokens": ["it's", "very", "compact:", "a", "hashset", "is", "used", "here", "to", "give", "good", "look-up", "performance", "-", "even", "very", "large", "hash", "sets", "are", "able", "to", "execute", "contains()", "extremely", "quickly", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> contains() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "contains()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "contains()", "label": "API", "asoc": []}]}
{"text": "it is clear that they could not either get rid of size() or change its semantics without creating compatibility problems", "tokens": ["it", "is", "clear", "that", "they", "could", "not", "either", "get", "rid", "of", "size()", "or", "change", "its", "semantics", "without", "creating", "compatibility", "problems", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> size() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "size()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "size()", "label": "API", "asoc": []}]}
{"text": "collections are iterable ,  and each call to iterator() produces a distinct iterator instance that is independent of any other active instances", "tokens": ["collections", "are", "iterable", ",", "", "and", "each", "call", "to", "iterator()", "produces", "a", "distinct", "iterator", "instance", "that", "is", "independent", "of", "any", "other", "active", "instances", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> iterator() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "iterator()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "iterator()", "label": "API", "asoc": []}]}
{"text": "inshort ,  klassklass means that you would have one java.lang.class object which defines the behavior of java.lang.class itself", "tokens": ["inshort", ",", "", "klassklass", "means", "that", "you", "would", "have", "one", "java.lang.class", "object", "which", "defines", "the", "behavior", "of", "java.lang.class", "itself", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.class <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "java.lang.class"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.class", "label": "API", "asoc": []}]}
{"text": "2.why i'm able to acess the method show() ?   because this method is available in all a objects (if it's not declared in the subclass ,  it is still inherited from a) .", "tokens": ["2.why", "i'm", "able", "to", "acess", "the", "method", "show()", "?", "", "", "because", "this", "method", "is", "available", "in", "all", "a", "objects", "(if", "it's", "not", "declared", "in", "the", "subclass", ",", "", "it", "is", "still", "inherited", "from", "a)", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> show() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "show()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "show()", "label": "API", "asoc": []}]}
{"text": "in case you're not on java 8 yet ,  or are forced to use java.util.date ,  then format the date using simpledateformat using a format pattern matching the input string", "tokens": ["in", "case", "you're", "not", "on", "java", "8", "yet", ",", "", "or", "are", "forced", "to", "use", "java.util.date", ",", "", "then", "format", "the", "date", "using", "simpledateformat", "using", "a", "format", "pattern", "matching", "the", "input", "string", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.date <extra_id_0> function collaboration <extra_id_5> simpledateformat <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> simpledateformat <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "java.util.date"}, {"type": "API", "offset": [23], "text": "simpledateformat"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [15], "text": "java.util.date"}, {"type": "API", "offset": [23], "text": "simpledateformat"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "java.util.date", "label": "API", "asoc": [["function collaboration", "simpledateformat"]]}, {"span": "simpledateformat", "label": "API", "asoc": []}]}
{"text": "the method ,  resultset.refreshrow() ,  suppose to update the resultset ,  hence it rightly requires updatable resultset", "tokens": ["the", "method", ",", "", "resultset.refreshrow()", ",", "", "suppose", "to", "update", "the", "resultset", ",", "", "hence", "it", "rightly", "requires", "updatable", "resultset", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> resultset.refreshrow() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "resultset.refreshrow()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "resultset.refreshrow()", "label": "API", "asoc": []}]}
{"text": "this call is normally included in a finally block ,  but if the application calls system.exit(0) ,  finally blocks are no longer executed .", "tokens": ["this", "call", "is", "normally", "included", "in", "a", "finally", "block", ",", "", "but", "if", "the", "application", "calls", "system.exit(0)", ",", "", "finally", "blocks", "are", "no", "longer", "executed", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.exit(0) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "system.exit(0)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.exit(0)", "label": "API", "asoc": []}]}
{"text": "considering object identity \"it is recommended that you implement equals() and hashcode() using business key equality", "tokens": ["considering", "object", "identity", "\"it", "is", "recommended", "that", "you", "implement", "equals()", "and", "hashcode()", "using", "business", "key", "equality", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_0> function collaboration <extra_id_5> hashcode() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> hashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": [["function collaboration", "hashcode()"]]}, {"span": "hashcode()", "label": "API", "asoc": []}]}
{"text": "it gives you a process object that you can waitfor() ,  like this:", "tokens": ["it", "gives", "you", "a", "process", "object", "that", "you", "can", "waitfor()", ",", "", "like", "this:", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> waitfor() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "waitfor()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "waitfor()", "label": "API", "asoc": []}]}
{"text": "this is file is simply java.util.properties file", "tokens": ["this", "is", "file", "is", "simply", "java.util.properties", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.properties <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "java.util.properties"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.properties", "label": "API", "asoc": []}]}
{"text": "this is most likely because your code (either directly or via hibernate) is trying to read a value from a returned result set and it's using the wrong type (such as getstring() on a numeric value)", "tokens": ["this", "is", "most", "likely", "because", "your", "code", "(either", "directly", "or", "via", "hibernate)", "is", "trying", "to", "read", "a", "value", "from", "a", "returned", "result", "set", "and", "it's", "using", "the", "wrong", "type", "(such", "as", "getstring()", "on", "a", "numeric", "value)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getstring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [31], "text": "getstring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getstring()", "label": "API", "asoc": []}]}
{"text": "java.util.stream is not a sub-pacakge of java.util", "tokens": ["java.util.stream", "is", "not", "a", "sub-pacakge", "of", "java.util", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.stream <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "java.util.stream"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.stream", "label": "API", "asoc": []}]}
{"text": "i don't believe it's possible ,  since java.util.date is based on utc ,  which is based on the gregorian calendar ,  and the gregorian calendar has no year zero", "tokens": ["i", "don't", "believe", "it's", "possible", ",", "", "since", "java.util.date", "is", "based", "on", "utc", ",", "", "which", "is", "based", "on", "the", "gregorian", "calendar", ",", "", "and", "the", "gregorian", "calendar", "has", "no", "year", "zero", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.date <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "java.util.date"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.date", "label": "API", "asoc": []}]}
{"text": "this comparator class must implement the java.util.comparator interface .", "tokens": ["this", "comparator", "class", "must", "implement", "the", "java.util.comparator", "interface", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.comparator <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "java.util.comparator"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.comparator", "label": "API", "asoc": []}]}
{"text": "try to use your original code with write() and add \\n at the end to confirm this .", "tokens": ["try", "to", "use", "your", "original", "code", "with", "write()", "and", "add", "\\n", "at", "the", "end", "to", "confirm", "this", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> write() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "write()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "write()", "label": "API", "asoc": []}]}
{"text": "the run() method would be in the stackframe if the user overrode it in a thread superclass", "tokens": ["the", "run()", "method", "would", "be", "in", "the", "stackframe", "if", "the", "user", "overrode", "it", "in", "a", "thread", "superclass", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> run() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "run()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "run()", "label": "API", "asoc": []}]}
{"text": "additionally ,  since the list utilized by the collector is an arraylist ,  it should preserve the iteration order of the stream relative to the list .", "tokens": ["additionally", ",", "", "since", "the", "list", "utilized", "by", "the", "collector", "is", "an", "arraylist", ",", "", "it", "should", "preserve", "the", "iteration", "order", "of", "the", "stream", "relative", "to", "the", "list", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arraylist <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "arraylist"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arraylist", "label": "API", "asoc": []}]}
{"text": "use java.util.arrays.copyof() methods which returns a bigger array ,  with the contents of the original array .", "tokens": ["use", "java.util.arrays.copyof()", "methods", "which", "returns", "a", "bigger", "array", ",", "", "with", "the", "contents", "of", "the", "original", "array", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.arrays.copyof() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "java.util.arrays.copyof()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.arrays.copyof()", "label": "API", "asoc": []}]}
{"text": "they are now legacy ,  supplanted entirely by the java.time classes", "tokens": ["they", "are", "now", "legacy", ",", "", "supplanted", "entirely", "by", "the", "java.time", "classes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "java.time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.time", "label": "API", "asoc": []}]}
{"text": "this is the reason why your contains() is not giving you correct results .", "tokens": ["this", "is", "the", "reason", "why", "your", "contains()", "is", "not", "giving", "you", "correct", "results", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> contains() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "contains()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "contains()", "label": "API", "asoc": []}]}
{"text": "you should create your own class that is serializable that includes two fields: a byte[] for the file contents ,  and a java.io.file that has everything else you need", "tokens": ["you", "should", "create", "your", "own", "class", "that", "is", "serializable", "that", "includes", "two", "fields:", "a", "byte[]", "for", "the", "file", "contents", ",", "", "and", "a", "java.io.file", "that", "has", "everything", "else", "you", "need", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.io.file <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "java.io.file"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.io.file", "label": "API", "asoc": []}]}
{"text": "by contrast ,  iterable.foreach is always executed in the iteration order of the iterable ,  if one is specified", "tokens": ["by", "contrast", ",", "", "iterable.foreach", "is", "always", "executed", "in", "the", "iteration", "order", "of", "the", "iterable", ",", "", "if", "one", "is", "specified", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> iterable.foreach <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "iterable.foreach"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "iterable.foreach", "label": "API", "asoc": []}]}
{"text": "you can always convert to/from a java.util.date at the boundaries of your own code if you need to ,  e.g", "tokens": ["you", "can", "always", "convert", "to/from", "a", "java.util.date", "at", "the", "boundaries", "of", "your", "own", "code", "if", "you", "need", "to", ",", "", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.date <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "java.util.date"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.date", "label": "API", "asoc": []}]}
{"text": "on most of those types you can't \"just\" do a tostring() as you would do in a simple statement", "tokens": ["on", "most", "of", "those", "types", "you", "can't", "\"just\"", "do", "a", "tostring()", "as", "you", "would", "do", "in", "a", "simple", "statement", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "this can be seen in the source code for field.get (archive)", "tokens": ["this", "can", "be", "seen", "in", "the", "source", "code", "for", "field.get", "(archive)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> field.get <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "field.get"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "field.get", "label": "API", "asoc": []}]}
{"text": "the repaint() will definitely be necessary if the change in components involves a deletion ,  or a component being drawn where another component was visualized previously", "tokens": ["the", "repaint()", "will", "definitely", "be", "necessary", "if", "the", "change", "in", "components", "involves", "a", "deletion", ",", "", "or", "a", "component", "being", "drawn", "where", "another", "component", "was", "visualized", "previously", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "[if a class load fails one time and you or spring call class.forname() again for some reason ,  then java won't actually try to load a second time", "tokens": ["[if", "a", "class", "load", "fails", "one", "time", "and", "you", "or", "spring", "call", "class.forname()", "again", "for", "some", "reason", ",", "", "then", "java", "won't", "actually", "try", "to", "load", "a", "second", "time", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> class.forname() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "class.forname()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "class.forname()", "label": "API", "asoc": []}]}
{"text": "inheriting gives you the release() method ,  for example (you can peek inside the unknown class to see the implementation)", "tokens": ["inheriting", "gives", "you", "the", "release()", "method", ",", "", "for", "example", "(you", "can", "peek", "inside", "the", "unknown", "class", "to", "see", "the", "implementation)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> release() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "release()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "release()", "label": "API", "asoc": []}]}
{"text": "i have nether used system.gc()", "tokens": ["i", "have", "nether", "used", "system.gc()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.gc() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.gc()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.gc()", "label": "API", "asoc": []}]}
{"text": "these troublesome classes are entirely supplanted by the java.time classes", "tokens": ["these", "troublesome", "classes", "are", "entirely", "supplanted", "by", "the", "java.time", "classes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "java.time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.time", "label": "API", "asoc": []}]}
{"text": "you should not use thread.sleep() on event dispatch thread (or any thread where sleep will cuase unwanted execution blocking) ,  as this will cause the ui to seem frozen", "tokens": ["you", "should", "not", "use", "thread.sleep()", "on", "event", "dispatch", "thread", "(or", "any", "thread", "where", "sleep", "will", "cuase", "unwanted", "execution", "blocking)", ",", "", "as", "this", "will", "cause", "the", "ui", "to", "seem", "frozen", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "thread.sleep()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep()", "label": "API", "asoc": []}]}
{"text": "if you take a look at the bytecode of a java program that performs string concatenation ,  you'll see that it creates stringbuilder and uses the append() method", "tokens": ["if", "you", "take", "a", "look", "at", "the", "bytecode", "of", "a", "java", "program", "that", "performs", "string", "concatenation", ",", "", "you'll", "see", "that", "it", "creates", "stringbuilder", "and", "uses", "the", "append()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> stringbuilder <extra_id_0> logic constraint <extra_id_5> append() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> append() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "stringbuilder"}, {"type": "API", "offset": [27], "text": "append()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [23], "text": "stringbuilder"}, {"type": "API", "offset": [27], "text": "append()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "stringbuilder", "label": "API", "asoc": [["logic constraint", "append()"]]}, {"span": "append()", "label": "API", "asoc": []}]}
{"text": "in 1.3 and above there is a single thread per consumer; the next poll() is performed after the last message from the previous poll has been processed by the listener", "tokens": ["in", "1.3", "and", "above", "there", "is", "a", "single", "thread", "per", "consumer;", "the", "next", "poll()", "is", "performed", "after", "the", "last", "message", "from", "the", "previous", "poll", "has", "been", "processed", "by", "the", "listener", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> poll() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "poll()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "poll()", "label": "API", "asoc": []}]}
{"text": "so afterwards ,  the keyset() of the map contains the disjoint set .", "tokens": ["so", "afterwards", ",", "", "the", "keyset()", "of", "the", "map", "contains", "the", "disjoint", "set", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> keyset() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "keyset()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "keyset()", "label": "API", "asoc": []}]}
{"text": "java.time.clock is an interface that you can use to get your timestamp values", "tokens": ["java.time.clock", "is", "an", "interface", "that", "you", "can", "use", "to", "get", "your", "timestamp", "values", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.time.clock <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "java.time.clock"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.time.clock", "label": "API", "asoc": []}]}
{"text": "to start the playback ,  start() must be called", "tokens": ["to", "start", "the", "playback", ",", "", "start()", "must", "be", "called", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> start() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "start()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "start()", "label": "API", "asoc": []}]}
{"text": "i am using the libphonenumber library along with java.util.locale class to complete this as follows", "tokens": ["i", "am", "using", "the", "libphonenumber", "library", "along", "with", "java.util.locale", "class", "to", "complete", "this", "as", "follows", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.locale <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "java.util.locale"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.locale", "label": "API", "asoc": []}]}
{"text": "the first step of the take() method is then ,  naturally ,  to acquire the read semaphore ,  in order to disallow any other thread to retrieve the element concurrently", "tokens": ["the", "first", "step", "of", "the", "take()", "method", "is", "then", ",", "", "naturally", ",", "", "to", "acquire", "the", "read", "semaphore", ",", "", "in", "order", "to", "disallow", "any", "other", "thread", "to", "retrieve", "the", "element", "concurrently", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> take() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "take()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "take()", "label": "API", "asoc": []}]}
{"text": "read the input with java.util.scanner and a for loop:", "tokens": ["read", "the", "input", "with", "java.util.scanner", "and", "a", "for", "loop:", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.scanner <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "java.util.scanner"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.scanner", "label": "API", "asoc": []}]}
{"text": "when you call bufferedimage.getsubimage() ,  then the image on which you call this method will become \"unmanaged\"", "tokens": ["when", "you", "call", "bufferedimage.getsubimage()", ",", "", "then", "the", "image", "on", "which", "you", "call", "this", "method", "will", "become", "\"unmanaged\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> bufferedimage.getsubimage() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "bufferedimage.getsubimage()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "bufferedimage.getsubimage()", "label": "API", "asoc": []}]}
{"text": "select() statements in jsoup will not return null if there are no elements", "tokens": ["select()", "statements", "in", "jsoup", "will", "not", "return", "null", "if", "there", "are", "no", "elements", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> select() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "select()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "select()", "label": "API", "asoc": []}]}
{"text": "this follows from the fact that the equals() method takes in an object as parameter ,  not just the same type as the object", "tokens": ["this", "follows", "from", "the", "fact", "that", "the", "equals()", "method", "takes", "in", "an", "object", "as", "parameter", ",", "", "not", "just", "the", "same", "type", "as", "the", "object", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "equals()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": []}]}
{"text": "update: to clarify a conceptual misunderstanding ,  the sleep() is not required", "tokens": ["update:", "to", "clarify", "a", "conceptual", "misunderstanding", ",", "", "the", "sleep()", "is", "not", "required", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> sleep() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "sleep()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "sleep()", "label": "API", "asoc": []}]}
{"text": "note also that the power-of-two computation based on integer.highestonebit() introduced by this changeset also disappeared at the same time ,  though this was noted but dismissed during the review", "tokens": ["note", "also", "that", "the", "power-of-two", "computation", "based", "on", "integer.highestonebit()", "introduced", "by", "this", "changeset", "also", "disappeared", "at", "the", "same", "time", ",", "", "though", "this", "was", "noted", "but", "dismissed", "during", "the", "review", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> integer.highestonebit() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "integer.highestonebit()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "integer.highestonebit()", "label": "API", "asoc": []}]}
{"text": "by default the oracle drivers does not return information on synonyms in getcolumns()", "tokens": ["by", "default", "the", "oracle", "drivers", "does", "not", "return", "information", "on", "synonyms", "in", "getcolumns()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumns() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "getcolumns()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumns()", "label": "API", "asoc": []}]}
{"text": "however ,  there is nothing special about iterator.remove() that makes it work in all cases .", "tokens": ["however", ",", "", "there", "is", "nothing", "special", "about", "iterator.remove()", "that", "makes", "it", "work", "in", "all", "cases", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> iterator.remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "iterator.remove()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "iterator.remove()", "label": "API", "asoc": []}]}
{"text": "e.g. ,  instead of calling files.newdirectorystream(path) just call files.list(path)", "tokens": ["e.g.", ",", "", "instead", "of", "calling", "files.newdirectorystream(path)", "just", "call", "files.list(path)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> files.newdirectorystream(path) <extra_id_0> function replace <extra_id_5> files.list(path) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> files.list(path) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "files.newdirectorystream(path)"}, {"type": "API", "offset": [9], "text": "files.list(path)"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [6], "text": "files.newdirectorystream(path)"}, {"type": "API", "offset": [9], "text": "files.list(path)"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "files.newdirectorystream(path)", "label": "API", "asoc": [["function replace", "files.list(path)"]]}, {"span": "files.list(path)", "label": "API", "asoc": []}]}
{"text": "the solution is to call pipedwriter.flush() always after writing something to the pipe", "tokens": ["the", "solution", "is", "to", "call", "pipedwriter.flush()", "always", "after", "writing", "something", "to", "the", "pipe", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pipedwriter.flush() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "pipedwriter.flush()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pipedwriter.flush()", "label": "API", "asoc": []}]}
{"text": "you can't wait() on an object unless the current thread owns that object's monitor", "tokens": ["you", "can't", "wait()", "on", "an", "object", "unless", "the", "current", "thread", "owns", "that", "object's", "monitor", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "to be more precise ,  i would use nanotime() method rather than currenttimemillis()", "tokens": ["to", "be", "more", "precise", ",", "", "i", "would", "use", "nanotime()", "method", "rather", "than", "currenttimemillis()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nanotime() <extra_id_0> function replace <extra_id_5> currenttimemillis() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> currenttimemillis() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "nanotime()"}, {"type": "API", "offset": [13], "text": "currenttimemillis()"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [9], "text": "nanotime()"}, {"type": "API", "offset": [13], "text": "currenttimemillis()"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "nanotime()", "label": "API", "asoc": [["function replace", "currenttimemillis()"]]}, {"span": "currenttimemillis()", "label": "API", "asoc": []}]}
{"text": "available() will always return 0 for sslsocket", "tokens": ["available()", "will", "always", "return", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "but when interfacing with old code not yet updated to java.time ,  you may need to convert", "tokens": ["but", "when", "interfacing", "with", "old", "code", "not", "yet", "updated", "to", "java.time", ",", "", "you", "may", "need", "to", "convert", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "java.time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.time", "label": "API", "asoc": []}]}
{"text": "you only have one image in your relation per parseobject in your \"notica\" class as you call getfirst()", "tokens": ["you", "only", "have", "one", "image", "in", "your", "relation", "per", "parseobject", "in", "your", "\"notica\"", "class", "as", "you", "call", "getfirst()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getfirst() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "getfirst()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getfirst()", "label": "API", "asoc": []}]}
{"text": "see also this comparison with the preparerenderer() approach", "tokens": ["see", "also", "this", "comparison", "with", "the", "preparerenderer()", "approach", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> preparerenderer() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "preparerenderer()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "preparerenderer()", "label": "API", "asoc": []}]}
{"text": "that's how tostring() is implemented for arrays", "tokens": ["that's", "how", "tostring()", "is", "implemented", "for", "arrays", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "you can also stop/start all listeners by calling stop() / start() on the registry itself .", "tokens": ["you", "can", "also", "stop/start", "all", "listeners", "by", "calling", "stop()", "/", "start()", "on", "the", "registry", "itself", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> stop() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "stop()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "stop()", "label": "API", "asoc": []}]}
{"text": "arrays.aslist only provides a thin wrapper around an array", "tokens": ["arrays.aslist", "only", "provides", "a", "thin", "wrapper", "around", "an", "array", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.aslist <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "arrays.aslist"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.aslist", "label": "API", "asoc": []}]}
{"text": "okay ,  the script obviously kicks in when the clear() method clears the input and leaves it empty", "tokens": ["okay", ",", "", "the", "script", "obviously", "kicks", "in", "when", "the", "clear()", "method", "clears", "the", "input", "and", "leaves", "it", "empty", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "clear()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "clear()", "label": "API", "asoc": []}]}
{"text": "gettext() will only get the inner text of an element", "tokens": ["gettext()", "will", "only", "get", "the", "inner", "text", "of", "an", "element", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> gettext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "gettext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "gettext()", "label": "API", "asoc": []}]}
{"text": "according to the java.io.file java docs the default temporary-file directory is specified by the system property java.io.tmpdir", "tokens": ["according", "to", "the", "java.io.file", "java", "docs", "the", "default", "temporary-file", "directory", "is", "specified", "by", "the", "system", "property", "java.io.tmpdir", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.io.file <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "java.io.file"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.io.file", "label": "API", "asoc": []}]}
{"text": "normally the split() would remove the characters matched by the regex", "tokens": ["normally", "the", "split()", "would", "remove", "the", "characters", "matched", "by", "the", "regex", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> split() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "split()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "split()", "label": "API", "asoc": []}]}
{"text": "a java.util.date is not a java.sql.date", "tokens": ["a", "java.util.date", "is", "not", "a", "java.sql.date", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.date <extra_id_0> behavior difference <extra_id_5> java.sql.date <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> java.sql.date <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "java.util.date"}, {"type": "API", "offset": [5], "text": "java.sql.date"}], "relation": [{"type": "behavior difference", "args": [{"type": "API", "offset": [1], "text": "java.util.date"}, {"type": "API", "offset": [5], "text": "java.sql.date"}]}], "event": [], "spot": ["API"], "asoc": ["behavior difference"], "spot_asoc": [{"span": "java.util.date", "label": "API", "asoc": [["behavior difference", "java.sql.date"]]}, {"span": "java.sql.date", "label": "API", "asoc": []}]}
{"text": "string.contains() may be what you're looking for ,  or perhaps you want to put some wild cards before and after your word: e.g. ,", "tokens": ["string.contains()", "may", "be", "what", "you're", "looking", "for", ",", "", "or", "perhaps", "you", "want", "to", "put", "some", "wild", "cards", "before", "and", "after", "your", "word:", "e.g.", ",", "", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.contains() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "string.contains()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.contains()", "label": "API", "asoc": []}]}
{"text": "it is possible to do this reasonably using some reflection ( java.lang.reflect.array ) ,  but we need to provide a class as an argument", "tokens": ["it", "is", "possible", "to", "do", "this", "reasonably", "using", "some", "reflection", "(", "java.lang.reflect.array", ")", ",", "", "but", "we", "need", "to", "provide", "a", "class", "as", "an", "argument", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.reflect.array <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "java.lang.reflect.array"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.reflect.array", "label": "API", "asoc": []}]}
{"text": "here is a method that returns a set containing the map.entry items sorted by their value .", "tokens": ["here", "is", "a", "method", "that", "returns", "a", "set", "containing", "the", "map.entry", "items", "sorted", "by", "their", "value", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> map.entry <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "map.entry"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "map.entry", "label": "API", "asoc": []}]}
{"text": "code example on how to cache values()", "tokens": ["code", "example", "on", "how", "to", "cache", "values()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> values() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "values()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "values()", "label": "API", "asoc": []}]}
{"text": "the arrays.sort() methods use a quick sort in all primitive type arrays", "tokens": ["the", "arrays.sort()", "methods", "use", "a", "quick", "sort", "in", "all", "primitive", "type", "arrays", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "arrays.sort()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort()", "label": "API", "asoc": []}]}
{"text": "replace next() with nextline()", "tokens": ["replace", "next()", "with", "nextline()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_0> function replace <extra_id_5> nextline() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> nextline() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "next()"}, {"type": "API", "offset": [3], "text": "nextline()"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [1], "text": "next()"}, {"type": "API", "offset": [3], "text": "nextline()"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "next()", "label": "API", "asoc": [["function replace", "nextline()"]]}, {"span": "nextline()", "label": "API", "asoc": []}]}
{"text": "if you have a multi-dimensional array ,  you can use arrays.deeptostring() to achieve the same sort of output", "tokens": ["if", "you", "have", "a", "multi-dimensional", "array", ",", "", "you", "can", "use", "arrays.deeptostring()", "to", "achieve", "the", "same", "sort", "of", "output", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.deeptostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "arrays.deeptostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.deeptostring()", "label": "API", "asoc": []}]}
{"text": "override both hashcode() and equals() : hashmap maps key1 ,  key2 and key3 into the same bucket", "tokens": ["override", "both", "hashcode()", "and", "equals()", ":", "hashmap", "maps", "key1", ",", "", "key2", "and", "key3", "into", "the", "same", "bucket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hashcode() <extra_id_0> function collaboration <extra_id_5> equals() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> equals() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "hashcode()"}, {"type": "API", "offset": [4], "text": "equals()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [2], "text": "hashcode()"}, {"type": "API", "offset": [4], "text": "equals()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "hashcode()", "label": "API", "asoc": [["function collaboration", "equals()"]]}, {"span": "equals()", "label": "API", "asoc": []}]}
{"text": "using an array of executors.newsinglethreadexecutor() would be fine", "tokens": ["using", "an", "array", "of", "executors.newsinglethreadexecutor()", "would", "be", "fine", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> executors.newsinglethreadexecutor() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "executors.newsinglethreadexecutor()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "executors.newsinglethreadexecutor()", "label": "API", "asoc": []}]}
{"text": "you can call thread.getstate() on and check if the state is timed_waiting", "tokens": ["you", "can", "call", "thread.getstate()", "on", "and", "check", "if", "the", "state", "is", "timed_waiting", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.getstate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "thread.getstate()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.getstate()", "label": "API", "asoc": []}]}
{"text": "what you want is in which case java.lang.integer is used as a type argument .", "tokens": ["what", "you", "want", "is", "in", "which", "case", "java.lang.integer", "is", "used", "as", "a", "type", "argument", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.integer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "java.lang.integer"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.integer", "label": "API", "asoc": []}]}
{"text": "the user class's get set methods: then this was implemented in the run() method in my server class as follows:", "tokens": ["the", "user", "class's", "get", "set", "methods:", "then", "this", "was", "implemented", "in", "the", "run()", "method", "in", "my", "server", "class", "as", "follows:", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> run() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "run()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "run()", "label": "API", "asoc": []}]}
{"text": "because the background color is a bound property of the buttons ,  you don't need the subsequent calls to repaint()", "tokens": ["because", "the", "background", "color", "is", "a", "bound", "property", "of", "the", "buttons", ",", "", "you", "don't", "need", "the", "subsequent", "calls", "to", "repaint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [20], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "the root cause of your problem is that relative paths in java.io are dependent on the current working directory", "tokens": ["the", "root", "cause", "of", "your", "problem", "is", "that", "relative", "paths", "in", "java.io", "are", "dependent", "on", "the", "current", "working", "directory", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.io <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "java.io"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.io", "label": "API", "asoc": []}]}
{"text": "the javadocs states that add() \"[r]eturns a biginteger whose value is (this + val).\"", "tokens": ["the", "javadocs", "states", "that", "add()", "\"[r]eturns", "a", "biginteger", "whose", "value", "is", "(this", "+", "val).\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> add() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "add()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "add()", "label": "API", "asoc": []}]}
{"text": "since the time zone is not stored ,  your approach of mapping java.time.instant to timestamp with time zone is better ,  because the sql type is really just a utc timestamp", "tokens": ["since", "the", "time", "zone", "is", "not", "stored", ",", "", "your", "approach", "of", "mapping", "java.time.instant", "to", "timestamp", "with", "time", "zone", "is", "better", ",", "", "because", "the", "sql", "type", "is", "really", "just", "a", "utc", "timestamp", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.time.instant <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "java.time.instant"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.time.instant", "label": "API", "asoc": []}]}
{"text": "the modern approach uses the java.time classes", "tokens": ["the", "modern", "approach", "uses", "the", "java.time", "classes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "java.time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.time", "label": "API", "asoc": []}]}
{"text": "this is exactly as specified in the documentation: string nextline() : advances this scanner past the current line and returns the input that was skipped", "tokens": ["this", "is", "exactly", "as", "specified", "in", "the", "documentation:", "string", "nextline()", ":", "advances", "this", "scanner", "past", "the", "current", "line", "and", "returns", "the", "input", "that", "was", "skipped", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextline() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "nextline()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nextline()", "label": "API", "asoc": []}]}
{"text": "lacking the correct encoding in a single place ,  for example in a debug println() call ,  will give erroneous and misleading output .", "tokens": ["lacking", "the", "correct", "encoding", "in", "a", "single", "place", ",", "", "for", "example", "in", "a", "debug", "println()", "call", ",", "", "will", "give", "erroneous", "and", "misleading", "output", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> println() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "println()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "println()", "label": "API", "asoc": []}]}
{"text": "the function system.currenttimemillis() will do that for you ,  and it does it quite accurately .", "tokens": ["the", "function", "system.currenttimemillis()", "will", "do", "that", "for", "you", ",", "", "and", "it", "does", "it", "quite", "accurately", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.currenttimemillis() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "system.currenttimemillis()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.currenttimemillis()", "label": "API", "asoc": []}]}
{"text": "from the docs: \"the iterator provided in method iterator() is not guaranteed to traverse the elements of the priority queue in any particular order.\"", "tokens": ["from", "the", "docs:", "\"the", "iterator", "provided", "in", "method", "iterator()", "is", "not", "guaranteed", "to", "traverse", "the", "elements", "of", "the", "priority", "queue", "in", "any", "particular", "order.\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> iterator() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "iterator()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "iterator()", "label": "API", "asoc": []}]}
{"text": "java.util.logging (jul) was unnecessary from the beginning", "tokens": ["java.util.logging", "(jul)", "was", "unnecessary", "from", "the", "beginning", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.logging <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "java.util.logging"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.logging", "label": "API", "asoc": []}]}
{"text": "when two integers are divided ,  the answer is floor() automatically", "tokens": ["when", "two", "integers", "are", "divided", ",", "", "the", "answer", "is", "floor()", "automatically", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> floor() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "floor()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "floor()", "label": "API", "asoc": []}]}
{"text": "in other words ,  this method returns a string equal to the value of: to achieve what you want ,  rather use arrays.tostring() .", "tokens": ["in", "other", "words", ",", "", "this", "method", "returns", "a", "string", "equal", "to", "the", "value", "of:", "to", "achieve", "what", "you", "want", ",", "", "rather", "use", "arrays.tostring()", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [24], "text": "arrays.tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.tostring()", "label": "API", "asoc": []}]}
{"text": "in this example ,  answers is going to contain a bunch of futures which will return nulls (see definition of executors.callable()", "tokens": ["in", "this", "example", ",", "", "answers", "is", "going", "to", "contain", "a", "bunch", "of", "futures", "which", "will", "return", "nulls", "(see", "definition", "of", "executors.callable()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> executors.callable() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "executors.callable()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "executors.callable()", "label": "API", "asoc": []}]}
{"text": "you just need to know that the objects returned by getclass is at the same memory address if the classes they represent are the same .", "tokens": ["you", "just", "need", "to", "know", "that", "the", "objects", "returned", "by", "getclass", "is", "at", "the", "same", "memory", "address", "if", "the", "classes", "they", "represent", "are", "the", "same", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getclass <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getclass"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getclass", "label": "API", "asoc": []}]}
{"text": "don't use the random() method in a painting method", "tokens": ["don't", "use", "the", "random()", "method", "in", "a", "painting", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> random() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "random()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "random()", "label": "API", "asoc": []}]}
{"text": "invoking pack() on the enclosing window will cause it to be \"sized to fit the preferred size and layouts of its subcomponents.\"", "tokens": ["invoking", "pack()", "on", "the", "enclosing", "window", "will", "cause", "it", "to", "be", "\"sized", "to", "fit", "the", "preferred", "size", "and", "layouts", "of", "its", "subcomponents.\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pack() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "pack()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pack()", "label": "API", "asoc": []}]}
{"text": "if you do prints thread.state states thread state for a waiting thread", "tokens": ["if", "you", "do", "prints", "thread.state", "states", "thread", "state", "for", "a", "waiting", "thread", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.state <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "thread.state"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.state", "label": "API", "asoc": []}]}
{"text": "the easiest way is probably to use string.replaceall() : this will leave all letters a intact and will replace all other characters with question marks", "tokens": ["the", "easiest", "way", "is", "probably", "to", "use", "string.replaceall()", ":", "this", "will", "leave", "all", "letters", "a", "intact", "and", "will", "replace", "all", "other", "characters", "with", "question", "marks", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.replaceall() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "string.replaceall()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.replaceall()", "label": "API", "asoc": []}]}
{"text": "in tostring() you can put whatever information is interesting - for example all fields", "tokens": ["in", "tostring()", "you", "can", "put", "whatever", "information", "is", "interesting", "-", "for", "example", "all", "fields", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "java.util.date and java.sql.timestamp are independent of the timezone", "tokens": ["java.util.date", "and", "java.sql.timestamp", "are", "independent", "of", "the", "timezone", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.date <extra_id_0> function similarity <extra_id_5> java.sql.timestamp <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> java.sql.timestamp <extra_id_1> <extra_id_0> API <extra_id_5> timezone <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "java.util.date"}, {"type": "API", "offset": [2], "text": "java.sql.timestamp"}, {"type": "API", "offset": [7], "text": "timezone"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [0], "text": "java.util.date"}, {"type": "API", "offset": [2], "text": "java.sql.timestamp"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "java.util.date", "label": "API", "asoc": [["function similarity", "java.sql.timestamp"]]}, {"span": "java.sql.timestamp", "label": "API", "asoc": []}, {"span": "timezone", "label": "API", "asoc": []}]}
{"text": "by looking at the source code of the javax.swing.text.plainview#paint method ,  i saw that the fontmetrics are used ,  and those you can easily override in the jtextarea", "tokens": ["by", "looking", "at", "the", "source", "code", "of", "the", "javax.swing.text.plainview#paint", "method", ",", "", "i", "saw", "that", "the", "fontmetrics", "are", "used", ",", "", "and", "those", "you", "can", "easily", "override", "in", "the", "jtextarea", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> javax.swing.text.plainview#paint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "javax.swing.text.plainview#paint"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "javax.swing.text.plainview#paint", "label": "API", "asoc": []}]}
{"text": "* for any reason ,  if you have to stick to java 6 or java 7 ,  you can use threeten-backport which backports most of the java.time functionality to java 6 &amp; 7", "tokens": ["*", "for", "any", "reason", ",", "", "if", "you", "have", "to", "stick", "to", "java", "6", "or", "java", "7", ",", "", "you", "can", "use", "threeten-backport", "which", "backports", "most", "of", "the", "java.time", "functionality", "to", "java", "6", "&amp;", "7", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [28], "text": "java.time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.time", "label": "API", "asoc": []}]}
{"text": "for example overriding the paint() function", "tokens": ["for", "example", "overriding", "the", "paint()", "function", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> paint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "paint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "paint()", "label": "API", "asoc": []}]}
{"text": "since you can use java.time ,  the modern java date and time api ,  you should not wish to apply the old-fashioned and poorly designed timestamp class too", "tokens": ["since", "you", "can", "use", "java.time", ",", "", "the", "modern", "java", "date", "and", "time", "api", ",", "", "you", "should", "not", "wish", "to", "apply", "the", "old-fashioned", "and", "poorly", "designed", "timestamp", "class", "too", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "java.time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.time", "label": "API", "asoc": []}]}
{"text": "in general if the jvm is about to throw an outofmemoryerror ,  calling system.gc() won't prevent it", "tokens": ["in", "general", "if", "the", "jvm", "is", "about", "to", "throw", "an", "outofmemoryerror", ",", "", "calling", "system.gc()", "won't", "prevent", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.gc() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "system.gc()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.gc()", "label": "API", "asoc": []}]}
{"text": "therefore find() returns the same instance when called from the same transaction", "tokens": ["therefore", "find()", "returns", "the", "same", "instance", "when", "called", "from", "the", "same", "transaction", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> find() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "find()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "find()", "label": "API", "asoc": []}]}
{"text": "before attempting to write to a file ,  you can check if the file is writable by your java application using file.canwrite()", "tokens": ["before", "attempting", "to", "write", "to", "a", "file", ",", "", "you", "can", "check", "if", "the", "file", "is", "writable", "by", "your", "java", "application", "using", "file.canwrite()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.canwrite() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "file.canwrite()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.canwrite()", "label": "API", "asoc": []}]}
{"text": "one improvement i'd make is to cut out the unnecessary map() operation and do the lookup in the collector:", "tokens": ["one", "improvement", "i'd", "make", "is", "to", "cut", "out", "the", "unnecessary", "map()", "operation", "and", "do", "the", "lookup", "in", "the", "collector:", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> map() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "map()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "map()", "label": "API", "asoc": []}]}
{"text": "quote the separate column names and use string.replace() to escape the same quote inside the column name .", "tokens": ["quote", "the", "separate", "column", "names", "and", "use", "string.replace()", "to", "escape", "the", "same", "quote", "inside", "the", "column", "name", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "string.replace()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.replace()", "label": "API", "asoc": []}]}
{"text": "you haven't called next() on your iterator ,  so it's not referring to the first item yet", "tokens": ["you", "haven't", "called", "next()", "on", "your", "iterator", ",", "", "so", "it's", "not", "referring", "to", "the", "first", "item", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "next()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "next()", "label": "API", "asoc": []}]}
{"text": "if you choose to sort the array programmatically at run time ,  make sure you use the appropriate (sorted) index when calling getstring() etc", "tokens": ["if", "you", "choose", "to", "sort", "the", "array", "programmatically", "at", "run", "time", ",", "", "make", "sure", "you", "use", "the", "appropriate", "(sorted)", "index", "when", "calling", "getstring()", "etc", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getstring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "getstring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getstring()", "label": "API", "asoc": []}]}
{"text": "it's also recommended ,  after each write ,  to use writer.flush() ,  on both server and client", "tokens": ["it's", "also", "recommended", ",", "", "after", "each", "write", ",", "", "to", "use", "writer.flush()", ",", "", "on", "both", "server", "and", "client", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> writer.flush() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "writer.flush()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "writer.flush()", "label": "API", "asoc": []}]}
{"text": "you can force it via calling intern() as you have already found out", "tokens": ["you", "can", "force", "it", "via", "calling", "intern()", "as", "you", "have", "already", "found", "out", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> intern() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "intern()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "intern()", "label": "API", "asoc": []}]}
{"text": "if another thread invokes parse() before the completion of the first invocation ,  it will clear the calendar ,  but the other invocation will expect it to be populated with intermediate results of the calculation", "tokens": ["if", "another", "thread", "invokes", "parse()", "before", "the", "completion", "of", "the", "first", "invocation", ",", "", "it", "will", "clear", "the", "calendar", ",", "", "but", "the", "other", "invocation", "will", "expect", "it", "to", "be", "populated", "with", "intermediate", "results", "of", "the", "calculation", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> parse() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "parse()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "parse()", "label": "API", "asoc": []}]}
{"text": "call next() to advance to the first item first ,  then call remove() .", "tokens": ["call", "next()", "to", "advance", "to", "the", "first", "item", "first", ",", "", "then", "call", "remove()", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_0> logic constraint <extra_id_5> remove() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "next()"}, {"type": "API", "offset": [13], "text": "remove()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [1], "text": "next()"}, {"type": "API", "offset": [13], "text": "remove()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "next()", "label": "API", "asoc": [["logic constraint", "remove()"]]}, {"span": "remove()", "label": "API", "asoc": []}]}
{"text": "java.lang.verifyerror can be the result when you have compiled against a different library than you are using at runtime", "tokens": ["java.lang.verifyerror", "can", "be", "the", "result", "when", "you", "have", "compiled", "against", "a", "different", "library", "than", "you", "are", "using", "at", "runtime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.verifyerror <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "java.lang.verifyerror"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.verifyerror", "label": "API", "asoc": []}]}
{"text": "in java ,  the equals() method that is inherited from object is: in other words ,  the parameter must be of type object", "tokens": ["in", "java", ",", "", "the", "equals()", "method", "that", "is", "inherited", "from", "object", "is:", "in", "other", "words", ",", "", "the", "parameter", "must", "be", "of", "type", "object", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "equals()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": []}]}
{"text": "one way is to automatically add logging to all places which call thread.sleep using a java agent", "tokens": ["one", "way", "is", "to", "automatically", "add", "logging", "to", "all", "places", "which", "call", "thread.sleep", "using", "a", "java", "agent", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "thread.sleep"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep", "label": "API", "asoc": []}]}
{"text": "step3: iterate the list ,  write a conditions with a use the file.getname() method to compare and the name and your input .", "tokens": ["step3:", "iterate", "the", "list", ",", "", "write", "a", "conditions", "with", "a", "use", "the", "file.getname()", "method", "to", "compare", "and", "the", "name", "and", "your", "input", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.getname() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "file.getname()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.getname()", "label": "API", "asoc": []}]}
{"text": "i reference this all the time ,  and it looks like this functionallity is used in eclipse when generating the hashcode() method for a given class", "tokens": ["i", "reference", "this", "all", "the", "time", ",", "", "and", "it", "looks", "like", "this", "functionallity", "is", "used", "in", "eclipse", "when", "generating", "the", "hashcode()", "method", "for", "a", "given", "class", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "hashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "hashcode()", "label": "API", "asoc": []}]}
{"text": "when you pack() the enclosing window ,  it will be resized to fit the text area", "tokens": ["when", "you", "pack()", "the", "enclosing", "window", ",", "", "it", "will", "be", "resized", "to", "fit", "the", "text", "area", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pack() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "pack()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pack()", "label": "API", "asoc": []}]}
{"text": "the correct approach would be assuming this iterator supports the remove() operation .", "tokens": ["the", "correct", "approach", "would", "be", "assuming", "this", "iterator", "supports", "the", "remove()", "operation", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "remove()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove()", "label": "API", "asoc": []}]}
{"text": "it will also catch exceptions thrown by tostring() and report these failures .", "tokens": ["it", "will", "also", "catch", "exceptions", "thrown", "by", "tostring()", "and", "report", "these", "failures", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "the following is compact and avoids the loop in your example code (and gives you nice commas): however ,  as others have pointed out ,  if you don't have sensible tostring() methods", "tokens": ["the", "following", "is", "compact", "and", "avoids", "the", "loop", "in", "your", "example", "code", "(and", "gives", "you", "nice", "commas):", "however", ",", "", "as", "others", "have", "pointed", "out", ",", "", "if", "you", "don't", "have", "sensible", "tostring()", "methods", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [32], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "when your editor concludes ,  the table's editingstopped() method collects the new value via getcelleditorvalue() and uses it to setvalueat() in the model", "tokens": ["when", "your", "editor", "concludes", ",", "", "the", "table's", "editingstopped()", "method", "collects", "the", "new", "value", "via", "getcelleditorvalue()", "and", "uses", "it", "to", "setvalueat()", "in", "the", "model", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> editingstopped() <extra_id_0> logic constraint <extra_id_5> getcelleditorvalue() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> getcelleditorvalue() <extra_id_1> <extra_id_0> API <extra_id_5> setvalueat() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "editingstopped()"}, {"type": "API", "offset": [15], "text": "getcelleditorvalue()"}, {"type": "API", "offset": [20], "text": "setvalueat()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [8], "text": "editingstopped()"}, {"type": "API", "offset": [15], "text": "getcelleditorvalue()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "editingstopped()", "label": "API", "asoc": [["logic constraint", "getcelleditorvalue()"]]}, {"span": "getcelleditorvalue()", "label": "API", "asoc": []}, {"span": "setvalueat()", "label": "API", "asoc": []}]}
{"text": "you'll need to open a file for writing ,  and pass the filewriter to it ,  along with the document node .", "tokens": ["you'll", "need", "to", "open", "a", "file", "for", "writing", ",", "", "and", "pass", "the", "filewriter", "to", "it", ",", "", "along", "with", "the", "document", "node", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> filewriter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "filewriter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "filewriter", "label": "API", "asoc": []}]}
{"text": "how to ensure that my tasks are responsive to interruption when i call future.cancel() ?  calling future.cancel(...) will stop the task it has not been run yet", "tokens": ["how", "to", "ensure", "that", "my", "tasks", "are", "responsive", "to", "interruption", "when", "i", "call", "future.cancel()", "?", "", "calling", "future.cancel(...)", "will", "stop", "the", "task", "it", "has", "not", "been", "run", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> future.cancel() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "future.cancel()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "future.cancel()", "label": "API", "asoc": []}]}
{"text": "this is because array objects in java do not have a custom tostring() method ,  they inherit object's", "tokens": ["this", "is", "because", "array", "objects", "in", "java", "do", "not", "have", "a", "custom", "tostring()", "method", ",", "", "they", "inherit", "object's", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "system.gc() ; is not guaranteed to force a garbage collection", "tokens": ["system.gc()", ";", "is", "not", "guaranteed", "to", "force", "a", "garbage", "collection", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.gc() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "system.gc()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.gc()", "label": "API", "asoc": []}]}
{"text": "you almost always want to use objects.equals()", "tokens": ["you", "almost", "always", "want", "to", "use", "objects.equals()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> objects.equals() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "objects.equals()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "objects.equals()", "label": "API", "asoc": []}]}
{"text": "increase your run time to about a minute ,  (n=100000000) or put some heavy computations in the compute()", "tokens": ["increase", "your", "run", "time", "to", "about", "a", "minute", ",", "", "(n=100000000)", "or", "put", "some", "heavy", "computations", "in", "the", "compute()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> compute() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "compute()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "compute()", "label": "API", "asoc": []}]}
{"text": "instead the jvm ends when no more non-daemon threads are running or when system.exit() is called", "tokens": ["instead", "the", "jvm", "ends", "when", "no", "more", "non-daemon", "threads", "are", "running", "or", "when", "system.exit()", "is", "called", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.exit() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "system.exit()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.exit()", "label": "API", "asoc": []}]}
{"text": "you should execute the preparestatement with no parameters as follows: calling executequery with a string parameter will execute the provided query as is (without the bound parameters) .", "tokens": ["you", "should", "execute", "the", "preparestatement", "with", "no", "parameters", "as", "follows:", "calling", "executequery", "with", "a", "string", "parameter", "will", "execute", "the", "provided", "query", "as", "is", "(without", "the", "bound", "parameters)", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> preparestatement <extra_id_0> logic constraint <extra_id_5> executequery <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> executequery <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "preparestatement"}, {"type": "API", "offset": [11], "text": "executequery"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [4], "text": "preparestatement"}, {"type": "API", "offset": [11], "text": "executequery"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "preparestatement", "label": "API", "asoc": [["logic constraint", "executequery"]]}, {"span": "executequery", "label": "API", "asoc": []}]}
{"text": "your method would look like this for better compatibility with the java.io.inputstream abstract class you may want to override all its methods in your class .", "tokens": ["your", "method", "would", "look", "like", "this", "for", "better", "compatibility", "with", "the", "java.io.inputstream", "abstract", "class", "you", "may", "want", "to", "override", "all", "its", "methods", "in", "your", "class", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.io.inputstream <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "java.io.inputstream"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.io.inputstream", "label": "API", "asoc": []}]}
{"text": "system.nanotime() has an arbitrary start point; it's not unix epoch", "tokens": ["system.nanotime()", "has", "an", "arbitrary", "start", "point;", "it's", "not", "unix", "epoch", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.nanotime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "system.nanotime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.nanotime()", "label": "API", "asoc": []}]}
{"text": "to test beforehand if the string contains certain character(s) ,  just use string.contains()", "tokens": ["to", "test", "beforehand", "if", "the", "string", "contains", "certain", "character(s)", ",", "", "just", "use", "string.contains()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.contains() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "string.contains()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.contains()", "label": "API", "asoc": []}]}
{"text": "for examples in the java api ,  see java.util.collections.checkedset and similar .", "tokens": ["for", "examples", "in", "the", "java", "api", ",", "", "see", "java.util.collections.checkedset", "and", "similar", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.collections.checkedset <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "java.util.collections.checkedset"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.collections.checkedset", "label": "API", "asoc": []}]}
{"text": "you create a mypanel object and invoke callfilling() on it to set the values in the tablemodel", "tokens": ["you", "create", "a", "mypanel", "object", "and", "invoke", "callfilling()", "on", "it", "to", "set", "the", "values", "in", "the", "tablemodel", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> callfilling() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "callfilling()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "callfilling()", "label": "API", "asoc": []}]}
{"text": "as it is mentioned in the official documentation ,  the key for solving this problem is to use the startafter() method", "tokens": ["as", "it", "is", "mentioned", "in", "the", "official", "documentation", ",", "", "the", "key", "for", "solving", "this", "problem", "is", "to", "use", "the", "startafter()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> startafter() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [20], "text": "startafter()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "startafter()", "label": "API", "asoc": []}]}
{"text": "when you look into it ,  string.indexof() also has a best case of o(n+m) and a worst case of o(nm)", "tokens": ["when", "you", "look", "into", "it", ",", "", "string.indexof()", "also", "has", "a", "best", "case", "of", "o(n+m)", "and", "a", "worst", "case", "of", "o(nm)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.indexof() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "string.indexof()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.indexof()", "label": "API", "asoc": []}]}
{"text": "you only want to next() your reader once ,  unless it has a lot of the same toke nrepeated again and again .", "tokens": ["you", "only", "want", "to", "next()", "your", "reader", "once", ",", "", "unless", "it", "has", "a", "lot", "of", "the", "same", "toke", "nrepeated", "again", "and", "again", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "next()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "next()", "label": "API", "asoc": []}]}
{"text": "i'd recommend using map.computeifabsent ,  to always ensure retrieving a list from the map", "tokens": ["i'd", "recommend", "using", "map.computeifabsent", ",", "", "to", "always", "ensure", "retrieving", "a", "list", "from", "the", "map", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> map.computeifabsent <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "map.computeifabsent"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "map.computeifabsent", "label": "API", "asoc": []}]}
{"text": "iterator.remove() is safe ,  you can use it like this: note that iterator.remove() is the only safe way to modify a collection during iteration;", "tokens": ["iterator.remove()", "is", "safe", ",", "", "you", "can", "use", "it", "like", "this:", "note", "that", "iterator.remove()", "is", "the", "only", "safe", "way", "to", "modify", "a", "collection", "during", "iteration;", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> iterator.remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "iterator.remove()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "iterator.remove()", "label": "API", "asoc": []}]}
{"text": "if you want to join a collection of strings you can use the new string.join() method", "tokens": ["if", "you", "want", "to", "join", "a", "collection", "of", "strings", "you", "can", "use", "the", "new", "string.join()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.join() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "string.join()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.join()", "label": "API", "asoc": []}]}
{"text": "you'll notice that the string.format line has \"%s%\" declared in it ,  so i don't see how the lecturer could possibly think that was faster", "tokens": ["you'll", "notice", "that", "the", "string.format", "line", "has", "\"%s%\"", "declared", "in", "it", ",", "", "so", "i", "don't", "see", "how", "the", "lecturer", "could", "possibly", "think", "that", "was", "faster", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.format <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "string.format"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.format", "label": "API", "asoc": []}]}
{"text": "to compare the values of strings ,  use the string.equals method", "tokens": ["to", "compare", "the", "values", "of", "strings", ",", "", "use", "the", "string.equals", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.equals <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "string.equals"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.equals", "label": "API", "asoc": []}]}
{"text": "for example ,  when the objects aren't initialized ,  no print() will be made and no exceptions will be thrown", "tokens": ["for", "example", ",", "", "when", "the", "objects", "aren't", "initialized", ",", "", "no", "print()", "will", "be", "made", "and", "no", "exceptions", "will", "be", "thrown", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> print() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "print()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "print()", "label": "API", "asoc": []}]}
{"text": "for example ,  one scanner for each distinct input file ,  one for system.in ,  one for each distinct socket input stream", "tokens": ["for", "example", ",", "", "one", "scanner", "for", "each", "distinct", "input", "file", ",", "", "one", "for", "system.in", ",", "", "one", "for", "each", "distinct", "socket", "input", "stream", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> scanner <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "scanner"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "scanner", "label": "API", "asoc": []}]}
{"text": "in your case that means that you are closing system.in", "tokens": ["in", "your", "case", "that", "means", "that", "you", "are", "closing", "system.in", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.in <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "system.in"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.in", "label": "API", "asoc": []}]}
{"text": "and then you are creating a second scanner to read from the (now closed) system.in", "tokens": ["and", "then", "you", "are", "creating", "a", "second", "scanner", "to", "read", "from", "the", "(now", "closed)", "system.in", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.in <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "system.in"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.in", "label": "API", "asoc": []}]}
{"text": "you could use the system.arraycopy function to copy the data ,  but you cannot avoid creating the new array .", "tokens": ["you", "could", "use", "the", "system.arraycopy", "function", "to", "copy", "the", "data", ",", "", "but", "you", "cannot", "avoid", "creating", "the", "new", "array", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.arraycopy <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.arraycopy"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.arraycopy", "label": "API", "asoc": []}]}
{"text": "the paintcomponent() method handles all of the \"painting\"", "tokens": ["the", "paintcomponent()", "method", "handles", "all", "of", "the", "\"painting\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> paintcomponent() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "paintcomponent()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "paintcomponent()", "label": "API", "asoc": []}]}
{"text": "every time you can to change the appearance of your jpanel ,  you must call repaint()", "tokens": ["every", "time", "you", "can", "to", "change", "the", "appearance", "of", "your", "jpanel", ",", "", "you", "must", "call", "repaint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "you'll need to add the following code to your query to fetch the pointer object .", "tokens": ["you'll", "need", "to", "add", "the", "following", "code", "to", "your", "query", "to", "fetch", "the", "pointer", "object", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pointer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "pointer"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pointer", "label": "API", "asoc": []}]}
{"text": "then add these object to the result list result.add(o)", "tokens": ["then", "add", "these", "object", "to", "the", "result", "list", "result.add(o)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> result.add(o) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "result.add(o)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "result.add(o)", "label": "API", "asoc": []}]}
{"text": "the class for that in java.time is localdate", "tokens": ["the", "class", "for", "that", "in", "java.time", "is", "localdate", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "java.time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.time", "label": "API", "asoc": []}]}
{"text": "to this ,  just call new oracle.sql.raw(byte[]) .", "tokens": ["to", "this", ",", "", "just", "call", "new", "oracle.sql.raw(byte[])", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> oracle.sql.raw(byte[]) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "oracle.sql.raw(byte[])"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "oracle.sql.raw(byte[])", "label": "API", "asoc": []}]}
{"text": "note the apache commons stringutils.isempty() method ,  which performs this check concisely .", "tokens": ["note", "the", "apache", "commons", "stringutils.isempty()", "method", ",", "", "which", "performs", "this", "check", "concisely", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> stringutils.isempty() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "stringutils.isempty()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "stringutils.isempty()", "label": "API", "asoc": []}]}
{"text": "on every recursion step  ,  issue a repaint call and sleep for a few hundred milliseconds", "tokens": ["on", "every", "recursion", "step", "", ",", "", "issue", "a", "repaint", "call", "and", "sleep", "for", "a", "few", "hundred", "milliseconds", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "repaint"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint", "label": "API", "asoc": []}]}
{"text": "to create the file you will have to use the method createfile", "tokens": ["to", "create", "the", "file", "you", "will", "have", "to", "use", "the", "method", "createfile", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> createfile <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "createfile"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "createfile", "label": "API", "asoc": []}]}
{"text": "but i would choose 64-bit integer column types for simplicity and for direct compatibility with the instant class  ?", "tokens": ["but", "i", "would", "choose", "64-bit", "integer", "column", "types", "for", "simplicity", "and", "for", "direct", "compatibility", "with", "the", "instant", "class", "", "?", "", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> instant <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "instant"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "instant", "label": "API", "asoc": []}]}
{"text": "however  ,  in most cases it's easier to use an executorservice", "tokens": ["however", "", ",", "", "in", "most", "cases", "it's", "easier", "to", "use", "an", "executorservice", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> executorservice <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "executorservice"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "executorservice", "label": "API", "asoc": []}]}
{"text": "then  ,  you can use split(string) and parseint(string) with something like output is", "tokens": ["then", "", ",", "", "you", "can", "use", "split(string)", "and", "parseint(string)", "with", "something", "like", "output", "is", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> split(string) <extra_id_0> function collaboration <extra_id_5> parseint(string) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> parseint(string) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "split(string)"}, {"type": "API", "offset": [9], "text": "parseint(string)"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [7], "text": "split(string)"}, {"type": "API", "offset": [9], "text": "parseint(string)"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "split(string)", "label": "API", "asoc": [["function collaboration", "parseint(string)"]]}, {"span": "parseint(string)", "label": "API", "asoc": []}]}
{"text": "then  ,  you can use split(string) and parseint with something like output is", "tokens": ["then", "", ",", "", "you", "can", "use", "split(string)", "and", "parseint", "with", "something", "like", "output", "is", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> split(string) <extra_id_0> function collaboration <extra_id_5> parseint <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> parseint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "split(string)"}, {"type": "API", "offset": [9], "text": "parseint"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [7], "text": "split(string)"}, {"type": "API", "offset": [9], "text": "parseint"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "split(string)", "label": "API", "asoc": [["function collaboration", "parseint"]]}, {"span": "parseint", "label": "API", "asoc": []}]}
{"text": "then  ,  you can use split(string) and integer.parseint with something like output is", "tokens": ["then", "", ",", "", "you", "can", "use", "split(string)", "and", "integer.parseint", "with", "something", "like", "output", "is", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> split(string) <extra_id_0> function collaboration <extra_id_5> integer.parseint <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> integer.parseint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "split(string)"}, {"type": "API", "offset": [9], "text": "integer.parseint"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [7], "text": "split(string)"}, {"type": "API", "offset": [9], "text": "integer.parseint"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "split(string)", "label": "API", "asoc": [["function collaboration", "integer.parseint"]]}, {"span": "integer.parseint", "label": "API", "asoc": []}]}
{"text": "then  ,  you can use split and parseint(string) with something like output is", "tokens": ["then", "", ",", "", "you", "can", "use", "split", "and", "parseint(string)", "with", "something", "like", "output", "is", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> split <extra_id_0> function collaboration <extra_id_5> parseint(string) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> parseint(string) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "split"}, {"type": "API", "offset": [9], "text": "parseint(string)"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [7], "text": "split"}, {"type": "API", "offset": [9], "text": "parseint(string)"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "split", "label": "API", "asoc": [["function collaboration", "parseint(string)"]]}, {"span": "parseint(string)", "label": "API", "asoc": []}]}
{"text": "then  ,  you can use split and parseint with something like output is", "tokens": ["then", "", ",", "", "you", "can", "use", "split", "and", "parseint", "with", "something", "like", "output", "is", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> split <extra_id_0> function collaboration <extra_id_5> parseint <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> parseint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "split"}, {"type": "API", "offset": [9], "text": "parseint"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [7], "text": "split"}, {"type": "API", "offset": [9], "text": "parseint"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "split", "label": "API", "asoc": [["function collaboration", "parseint"]]}, {"span": "parseint", "label": "API", "asoc": []}]}
{"text": "then  ,  you can use split and integer.parseint with something like output is", "tokens": ["then", "", ",", "", "you", "can", "use", "split", "and", "integer.parseint", "with", "something", "like", "output", "is", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> split <extra_id_0> function collaboration <extra_id_5> integer.parseint <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> integer.parseint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "split"}, {"type": "API", "offset": [9], "text": "integer.parseint"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [7], "text": "split"}, {"type": "API", "offset": [9], "text": "integer.parseint"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "split", "label": "API", "asoc": [["function collaboration", "integer.parseint"]]}, {"span": "integer.parseint", "label": "API", "asoc": []}]}
{"text": "then  ,  you can use string.split and parseint(string) with something like output is", "tokens": ["then", "", ",", "", "you", "can", "use", "string.split", "and", "parseint(string)", "with", "something", "like", "output", "is", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.split <extra_id_0> function collaboration <extra_id_5> parseint(string) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> parseint(string) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "string.split"}, {"type": "API", "offset": [9], "text": "parseint(string)"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [7], "text": "string.split"}, {"type": "API", "offset": [9], "text": "parseint(string)"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "string.split", "label": "API", "asoc": [["function collaboration", "parseint(string)"]]}, {"span": "parseint(string)", "label": "API", "asoc": []}]}
{"text": "then  ,  you can use string.split and parseint with something like output is", "tokens": ["then", "", ",", "", "you", "can", "use", "string.split", "and", "parseint", "with", "something", "like", "output", "is", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.split <extra_id_0> function collaboration <extra_id_5> parseint <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> parseint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "string.split"}, {"type": "API", "offset": [9], "text": "parseint"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [7], "text": "string.split"}, {"type": "API", "offset": [9], "text": "parseint"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "string.split", "label": "API", "asoc": [["function collaboration", "parseint"]]}, {"span": "parseint", "label": "API", "asoc": []}]}
{"text": "then  ,  you can use string.split and integer.parseint with something like output is", "tokens": ["then", "", ",", "", "you", "can", "use", "string.split", "and", "integer.parseint", "with", "something", "like", "output", "is", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.split <extra_id_0> function collaboration <extra_id_5> integer.parseint <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> integer.parseint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "string.split"}, {"type": "API", "offset": [9], "text": "integer.parseint"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [7], "text": "string.split"}, {"type": "API", "offset": [9], "text": "integer.parseint"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "string.split", "label": "API", "asoc": [["function collaboration", "integer.parseint"]]}, {"span": "integer.parseint", "label": "API", "asoc": []}]}
{"text": "it compiles only because equals accepts object  ,  not a string", "tokens": ["it", "compiles", "only", "because", "equals", "accepts", "object", "", ",", "", "not", "a", "string", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "equals"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "equals", "label": "API", "asoc": []}]}
{"text": "you can export a secretkey using the getencoded method", "tokens": ["you", "can", "export", "a", "secretkey", "using", "the", "getencoded", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getencoded <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "getencoded"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getencoded", "label": "API", "asoc": []}]}
{"text": "this way you skip future odd behaviours if java decides to return directories with a slash in the end or if your directory string comes from somewhere else than file", "tokens": ["this", "way", "you", "skip", "future", "odd", "behaviours", "if", "java", "decides", "to", "return", "directories", "with", "a", "slash", "in", "the", "end", "or", "if", "your", "directory", "string", "comes", "from", "somewhere", "else", "than", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [29], "text": "file"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file", "label": "API", "asoc": []}]}
{"text": "you can also call gc() to suggest that the garbage collector run immediately", "tokens": ["you", "can", "also", "call", "gc()", "to", "suggest", "that", "the", "garbage", "collector", "run", "immediately", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> gc() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "gc()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "gc()", "label": "API", "asoc": []}]}
{"text": "you can also call gc to suggest that the garbage collector run immediately", "tokens": ["you", "can", "also", "call", "gc", "to", "suggest", "that", "the", "garbage", "collector", "run", "immediately", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> gc <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "gc"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "gc", "label": "API", "asoc": []}]}
{"text": "you can also call system.gc to suggest that the garbage collector run immediately", "tokens": ["you", "can", "also", "call", "system.gc", "to", "suggest", "that", "the", "garbage", "collector", "run", "immediately", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.gc <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.gc"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.gc", "label": "API", "asoc": []}]}
{"text": "create a bullet  ,  or change the location of the bullet  ,  or whatever)  ,  and then call repaint", "tokens": ["create", "a", "bullet", "", ",", "", "or", "change", "the", "location", "of", "the", "bullet", "", ",", "", "or", "whatever)", "", ",", "", "and", "then", "call", "repaint", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [24], "text": "repaint"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint", "label": "API", "asoc": []}]}
{"text": "to preserve insertion order  ,  instead use linkedhashmap (javadoc)", "tokens": ["to", "preserve", "insertion", "order", "", ",", "", "instead", "use", "linkedhashmap", "(javadoc)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> linkedhashmap <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "linkedhashmap"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "linkedhashmap", "label": "API", "asoc": []}]}
{"text": "for example  ,  this is a perfectly valid clone implementation", "tokens": ["for", "example", "", ",", "", "this", "is", "a", "perfectly", "valid", "clone", "implementation", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> clone <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "clone"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "clone", "label": "API", "asoc": []}]}
{"text": "normal ways would be tostring(i) or valueof(i)", "tokens": ["normal", "ways", "would", "be", "tostring(i)", "or", "valueof(i)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring(i) <extra_id_0> function similarity <extra_id_5> valueof(i) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> valueof(i) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "tostring(i)"}, {"type": "API", "offset": [6], "text": "valueof(i)"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [4], "text": "tostring(i)"}, {"type": "API", "offset": [6], "text": "valueof(i)"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "tostring(i)", "label": "API", "asoc": [["function similarity", "valueof(i)"]]}, {"span": "valueof(i)", "label": "API", "asoc": []}]}
{"text": "normal ways would be tostring(i) or valueof", "tokens": ["normal", "ways", "would", "be", "tostring(i)", "or", "valueof", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring(i) <extra_id_0> function similarity <extra_id_5> valueof <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> valueof <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "tostring(i)"}, {"type": "API", "offset": [6], "text": "valueof"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [4], "text": "tostring(i)"}, {"type": "API", "offset": [6], "text": "valueof"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "tostring(i)", "label": "API", "asoc": [["function similarity", "valueof"]]}, {"span": "valueof", "label": "API", "asoc": []}]}
{"text": "normal ways would be tostring(i) or string.valueof", "tokens": ["normal", "ways", "would", "be", "tostring(i)", "or", "string.valueof", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring(i) <extra_id_0> function similarity <extra_id_5> string.valueof <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> string.valueof <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "tostring(i)"}, {"type": "API", "offset": [6], "text": "string.valueof"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [4], "text": "tostring(i)"}, {"type": "API", "offset": [6], "text": "string.valueof"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "tostring(i)", "label": "API", "asoc": [["function similarity", "string.valueof"]]}, {"span": "string.valueof", "label": "API", "asoc": []}]}
{"text": "normal ways would be tostring or valueof(i)", "tokens": ["normal", "ways", "would", "be", "tostring", "or", "valueof(i)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring <extra_id_0> function similarity <extra_id_5> valueof(i) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> valueof(i) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "tostring"}, {"type": "API", "offset": [6], "text": "valueof(i)"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [4], "text": "tostring"}, {"type": "API", "offset": [6], "text": "valueof(i)"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "tostring", "label": "API", "asoc": [["function similarity", "valueof(i)"]]}, {"span": "valueof(i)", "label": "API", "asoc": []}]}
{"text": "normal ways would be tostring or valueof", "tokens": ["normal", "ways", "would", "be", "tostring", "or", "valueof", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring <extra_id_0> function similarity <extra_id_5> valueof <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> valueof <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "tostring"}, {"type": "API", "offset": [6], "text": "valueof"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [4], "text": "tostring"}, {"type": "API", "offset": [6], "text": "valueof"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "tostring", "label": "API", "asoc": [["function similarity", "valueof"]]}, {"span": "valueof", "label": "API", "asoc": []}]}
{"text": "normal ways would be tostring or string.valueof", "tokens": ["normal", "ways", "would", "be", "tostring", "or", "string.valueof", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring <extra_id_0> function similarity <extra_id_5> string.valueof <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> string.valueof <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "tostring"}, {"type": "API", "offset": [6], "text": "string.valueof"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [4], "text": "tostring"}, {"type": "API", "offset": [6], "text": "string.valueof"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "tostring", "label": "API", "asoc": [["function similarity", "string.valueof"]]}, {"span": "string.valueof", "label": "API", "asoc": []}]}
{"text": "normal ways would be integer.tostring or valueof(i)", "tokens": ["normal", "ways", "would", "be", "integer.tostring", "or", "valueof(i)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> integer.tostring <extra_id_0> function similarity <extra_id_5> valueof(i) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> valueof(i) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "integer.tostring"}, {"type": "API", "offset": [6], "text": "valueof(i)"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [4], "text": "integer.tostring"}, {"type": "API", "offset": [6], "text": "valueof(i)"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "integer.tostring", "label": "API", "asoc": [["function similarity", "valueof(i)"]]}, {"span": "valueof(i)", "label": "API", "asoc": []}]}
{"text": "normal ways would be integer.tostring or valueof", "tokens": ["normal", "ways", "would", "be", "integer.tostring", "or", "valueof", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> integer.tostring <extra_id_0> function similarity <extra_id_5> valueof <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> valueof <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "integer.tostring"}, {"type": "API", "offset": [6], "text": "valueof"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [4], "text": "integer.tostring"}, {"type": "API", "offset": [6], "text": "valueof"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "integer.tostring", "label": "API", "asoc": [["function similarity", "valueof"]]}, {"span": "valueof", "label": "API", "asoc": []}]}
{"text": "normal ways would be integer.tostring or string.valueof", "tokens": ["normal", "ways", "would", "be", "integer.tostring", "or", "string.valueof", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> integer.tostring <extra_id_0> function similarity <extra_id_5> string.valueof <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> string.valueof <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "integer.tostring"}, {"type": "API", "offset": [6], "text": "string.valueof"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [4], "text": "integer.tostring"}, {"type": "API", "offset": [6], "text": "string.valueof"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "integer.tostring", "label": "API", "asoc": [["function similarity", "string.valueof"]]}, {"span": "string.valueof", "label": "API", "asoc": []}]}
{"text": "however  ,  you can treat it as a path", "tokens": ["however", "", ",", "", "you", "can", "treat", "it", "as", "a", "path", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> path <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "path"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "path", "label": "API", "asoc": []}]}
{"text": "replace doesn't change the string you call it on - it returns a new string with the changes", "tokens": ["replace", "doesn't", "change", "the", "string", "you", "call", "it", "on", "-", "it", "returns", "a", "new", "string", "with", "the", "changes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replace <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "replace"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replace", "label": "API", "asoc": []}]}
{"text": "to sort the whole array  ,  just call sort(p)", "tokens": ["to", "sort", "the", "whole", "array", "", ",", "", "just", "call", "sort(p)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> sort(p) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "sort(p)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "sort(p)", "label": "API", "asoc": []}]}
{"text": "to sort the whole array  ,  just call sort", "tokens": ["to", "sort", "the", "whole", "array", "", ",", "", "just", "call", "sort", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> sort <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "sort"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "sort", "label": "API", "asoc": []}]}
{"text": "to sort the whole array  ,  just call arrays.sort", "tokens": ["to", "sort", "the", "whole", "array", "", ",", "", "just", "call", "arrays.sort", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "arrays.sort"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort", "label": "API", "asoc": []}]}
{"text": "my experience with larger files sizes has been that nio is faster than io", "tokens": ["my", "experience", "with", "larger", "files", "sizes", "has", "been", "that", "nio", "is", "faster", "than", "io", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nio <extra_id_0> efficiency comparison <extra_id_5> io <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> io <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "nio"}, {"type": "API", "offset": [13], "text": "io"}], "relation": [{"type": "efficiency comparison", "args": [{"type": "API", "offset": [9], "text": "nio"}, {"type": "API", "offset": [13], "text": "io"}]}], "event": [], "spot": ["API"], "asoc": ["efficiency comparison"], "spot_asoc": [{"span": "nio", "label": "API", "asoc": [["efficiency comparison", "io"]]}, {"span": "io", "label": "API", "asoc": []}]}
{"text": "then i discovered the with method  .", "tokens": ["then", "i", "discovered", "the", "with", "method", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> with <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "with"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "with", "label": "API", "asoc": []}]}
{"text": "java has the concurrent package  ,  and there's also the fork/join framework", "tokens": ["java", "has", "the", "concurrent", "package", "", ",", "", "and", "there's", "also", "the", "fork/join", "framework", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> concurrent <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "concurrent"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "concurrent", "label": "API", "asoc": []}]}
{"text": "you'll find this in remove methods aswell", "tokens": ["you'll", "find", "this", "in", "remove", "methods", "aswell", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "remove"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove", "label": "API", "asoc": []}]}
{"text": "enum constants are encoded differently than instances of normal classes  ,  so readobject() can deserialize them without calling their readobject method", "tokens": ["enum", "constants", "are", "encoded", "differently", "than", "instances", "of", "normal", "classes", "", ",", "", "so", "readobject()", "can", "deserialize", "them", "without", "calling", "their", "readobject", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> readobject() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "readobject()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "readobject()", "label": "API", "asoc": []}]}
{"text": "enum constants are encoded differently than instances of normal classes  ,  so readobject can deserialize them without calling their readobject method", "tokens": ["enum", "constants", "are", "encoded", "differently", "than", "instances", "of", "normal", "classes", "", ",", "", "so", "readobject", "can", "deserialize", "them", "without", "calling", "their", "readobject", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> readobject <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "readobject"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "readobject", "label": "API", "asoc": []}]}
{"text": "enum constants are encoded differently than instances of normal classes  ,  so objectinputstream.readobject can deserialize them without calling their readobject method", "tokens": ["enum", "constants", "are", "encoded", "differently", "than", "instances", "of", "normal", "classes", "", ",", "", "so", "objectinputstream.readobject", "can", "deserialize", "them", "without", "calling", "their", "readobject", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> objectinputstream.readobject <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "objectinputstream.readobject"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "objectinputstream.readobject", "label": "API", "asoc": []}]}
{"text": "it is simple enough to create your own itemwriter that does a simple println()  .", "tokens": ["it", "is", "simple", "enough", "to", "create", "your", "own", "itemwriter", "that", "does", "a", "simple", "println()", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> println() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "println()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "println()", "label": "API", "asoc": []}]}
{"text": "it is simple enough to create your own itemwriter that does a simple println  .", "tokens": ["it", "is", "simple", "enough", "to", "create", "your", "own", "itemwriter", "that", "does", "a", "simple", "println", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> println <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "println"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "println", "label": "API", "asoc": []}]}
{"text": "it is simple enough to create your own itemwriter that does a simple system.out.println  .", "tokens": ["it", "is", "simple", "enough", "to", "create", "your", "own", "itemwriter", "that", "does", "a", "simple", "system.out.println", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.out.println <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "system.out.println"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.out.println", "label": "API", "asoc": []}]}
{"text": "those are not regular files nor directories nor symlinks so both isfile() and isdirectory() will return false", "tokens": ["those", "are", "not", "regular", "files", "nor", "directories", "nor", "symlinks", "so", "both", "isfile()", "and", "isdirectory()", "will", "return", "false", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> isfile() <extra_id_0> function similarity <extra_id_5> isdirectory() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> isdirectory() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "isfile()"}, {"type": "API", "offset": [13], "text": "isdirectory()"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [11], "text": "isfile()"}, {"type": "API", "offset": [13], "text": "isdirectory()"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "isfile()", "label": "API", "asoc": [["function similarity", "isdirectory()"]]}, {"span": "isdirectory()", "label": "API", "asoc": []}]}
{"text": "those are not regular files nor directories nor symlinks so both isfile() and isdirectory will return false", "tokens": ["those", "are", "not", "regular", "files", "nor", "directories", "nor", "symlinks", "so", "both", "isfile()", "and", "isdirectory", "will", "return", "false", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> isfile() <extra_id_0> function similarity <extra_id_5> isdirectory <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> isdirectory <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "isfile()"}, {"type": "API", "offset": [13], "text": "isdirectory"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [11], "text": "isfile()"}, {"type": "API", "offset": [13], "text": "isdirectory"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "isfile()", "label": "API", "asoc": [["function similarity", "isdirectory"]]}, {"span": "isdirectory", "label": "API", "asoc": []}]}
{"text": "those are not regular files nor directories nor symlinks so both isfile() and file.isdirectory will return false", "tokens": ["those", "are", "not", "regular", "files", "nor", "directories", "nor", "symlinks", "so", "both", "isfile()", "and", "file.isdirectory", "will", "return", "false", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> isfile() <extra_id_0> function similarity <extra_id_5> file.isdirectory <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> file.isdirectory <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "isfile()"}, {"type": "API", "offset": [13], "text": "file.isdirectory"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [11], "text": "isfile()"}, {"type": "API", "offset": [13], "text": "file.isdirectory"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "isfile()", "label": "API", "asoc": [["function similarity", "file.isdirectory"]]}, {"span": "file.isdirectory", "label": "API", "asoc": []}]}
{"text": "those are not regular files nor directories nor symlinks so both isfile and isdirectory() will return false", "tokens": ["those", "are", "not", "regular", "files", "nor", "directories", "nor", "symlinks", "so", "both", "isfile", "and", "isdirectory()", "will", "return", "false", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> isfile <extra_id_0> function similarity <extra_id_5> isdirectory() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> isdirectory() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "isfile"}, {"type": "API", "offset": [13], "text": "isdirectory()"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [11], "text": "isfile"}, {"type": "API", "offset": [13], "text": "isdirectory()"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "isfile", "label": "API", "asoc": [["function similarity", "isdirectory()"]]}, {"span": "isdirectory()", "label": "API", "asoc": []}]}
{"text": "those are not regular files nor directories nor symlinks so both isfile and isdirectory will return false", "tokens": ["those", "are", "not", "regular", "files", "nor", "directories", "nor", "symlinks", "so", "both", "isfile", "and", "isdirectory", "will", "return", "false", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> isfile <extra_id_0> function similarity <extra_id_5> isdirectory <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> isdirectory <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "isfile"}, {"type": "API", "offset": [13], "text": "isdirectory"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [11], "text": "isfile"}, {"type": "API", "offset": [13], "text": "isdirectory"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "isfile", "label": "API", "asoc": [["function similarity", "isdirectory"]]}, {"span": "isdirectory", "label": "API", "asoc": []}]}
{"text": "those are not regular files nor directories nor symlinks so both isfile and file.isdirectory will return false", "tokens": ["those", "are", "not", "regular", "files", "nor", "directories", "nor", "symlinks", "so", "both", "isfile", "and", "file.isdirectory", "will", "return", "false", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> isfile <extra_id_0> function similarity <extra_id_5> file.isdirectory <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> file.isdirectory <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "isfile"}, {"type": "API", "offset": [13], "text": "file.isdirectory"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [11], "text": "isfile"}, {"type": "API", "offset": [13], "text": "file.isdirectory"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "isfile", "label": "API", "asoc": [["function similarity", "file.isdirectory"]]}, {"span": "file.isdirectory", "label": "API", "asoc": []}]}
{"text": "those are not regular files nor directories nor symlinks so both file.isfile and isdirectory() will return false", "tokens": ["those", "are", "not", "regular", "files", "nor", "directories", "nor", "symlinks", "so", "both", "file.isfile", "and", "isdirectory()", "will", "return", "false", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.isfile <extra_id_0> function similarity <extra_id_5> isdirectory() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> isdirectory() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "file.isfile"}, {"type": "API", "offset": [13], "text": "isdirectory()"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [11], "text": "file.isfile"}, {"type": "API", "offset": [13], "text": "isdirectory()"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "file.isfile", "label": "API", "asoc": [["function similarity", "isdirectory()"]]}, {"span": "isdirectory()", "label": "API", "asoc": []}]}
{"text": "those are not regular files nor directories nor symlinks so both file.isfile and isdirectory will return false", "tokens": ["those", "are", "not", "regular", "files", "nor", "directories", "nor", "symlinks", "so", "both", "file.isfile", "and", "isdirectory", "will", "return", "false", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.isfile <extra_id_0> function similarity <extra_id_5> isdirectory <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> isdirectory <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "file.isfile"}, {"type": "API", "offset": [13], "text": "isdirectory"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [11], "text": "file.isfile"}, {"type": "API", "offset": [13], "text": "isdirectory"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "file.isfile", "label": "API", "asoc": [["function similarity", "isdirectory"]]}, {"span": "isdirectory", "label": "API", "asoc": []}]}
{"text": "those are not regular files nor directories nor symlinks so both file.isfile and file.isdirectory will return false", "tokens": ["those", "are", "not", "regular", "files", "nor", "directories", "nor", "symlinks", "so", "both", "file.isfile", "and", "file.isdirectory", "will", "return", "false", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.isfile <extra_id_0> function similarity <extra_id_5> file.isdirectory <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> file.isdirectory <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "file.isfile"}, {"type": "API", "offset": [13], "text": "file.isdirectory"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [11], "text": "file.isfile"}, {"type": "API", "offset": [13], "text": "file.isdirectory"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "file.isfile", "label": "API", "asoc": [["function similarity", "file.isdirectory"]]}, {"span": "file.isdirectory", "label": "API", "asoc": []}]}
{"text": "use the replaceall() method: hope this helps  .", "tokens": ["use", "the", "replaceall()", "method:", "hope", "this", "helps", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replaceall() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "replaceall()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replaceall()", "label": "API", "asoc": []}]}
{"text": "use the replaceall method: hope this helps  .", "tokens": ["use", "the", "replaceall", "method:", "hope", "this", "helps", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replaceall <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "replaceall"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replaceall", "label": "API", "asoc": []}]}
{"text": "use the string.replaceall method: hope this helps  .", "tokens": ["use", "the", "string.replaceall", "method:", "hope", "this", "helps", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.replaceall <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "string.replaceall"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.replaceall", "label": "API", "asoc": []}]}
{"text": "readline blocks until  the connection had been shutdown or close or it received a new-line \\n  ,  which never is sent by the server  .", "tokens": ["readline", "blocks", "until", "", "the", "connection", "had", "been", "shutdown", "or", "close", "or", "it", "received", "a", "new-line", "\\n", "", ",", "", "which", "never", "is", "sent", "by", "the", "server", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> readline <extra_id_0> logic constraint <extra_id_5> shutdown <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> shutdown <extra_id_1> <extra_id_0> API <extra_id_5> close <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "readline"}, {"type": "API", "offset": [8], "text": "shutdown"}, {"type": "API", "offset": [10], "text": "close"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [0], "text": "readline"}, {"type": "API", "offset": [8], "text": "shutdown"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "readline", "label": "API", "asoc": [["logic constraint", "shutdown"]]}, {"span": "shutdown", "label": "API", "asoc": []}, {"span": "close", "label": "API", "asoc": []}]}
{"text": "you need to call gettime to get the date out of it", "tokens": ["you", "need", "to", "call", "gettime", "to", "get", "the", "date", "out", "of", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> gettime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "gettime"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "gettime", "label": "API", "asoc": []}]}
{"text": "this approach has the advantage of not needing to explicitly initialize a random instance  ,  which can be a source of confusion and error if used inappropriately", "tokens": ["this", "approach", "has", "the", "advantage", "of", "not", "needing", "to", "explicitly", "initialize", "a", "random", "instance", "", ",", "", "which", "can", "be", "a", "source", "of", "confusion", "and", "error", "if", "used", "inappropriately", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "random"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "random", "label": "API", "asoc": []}]}
{"text": "first of all  ,  to persist a date into a database in java  ,  you will have to convert it to date", "tokens": ["first", "of", "all", "", ",", "", "to", "persist", "a", "date", "into", "a", "database", "in", "java", "", ",", "", "you", "will", "have", "to", "convert", "it", "to", "date", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> date <extra_id_0> type conversion <extra_id_5> date <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> date <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "date"}, {"type": "API", "offset": [9], "text": "date"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [9], "text": "date"}, {"type": "API", "offset": [9], "text": "date"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "date", "label": "API", "asoc": [["type conversion", "date"]]}, {"span": "date", "label": "API", "asoc": []}]}
{"text": "the caching happens only if you use valueof(int)  ,  not if you use new integer", "tokens": ["the", "caching", "happens", "only", "if", "you", "use", "valueof(int)", "", ",", "", "not", "if", "you", "use", "new", "integer", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> valueof(int) <extra_id_0> behavior difference <extra_id_5> integer <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> integer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "valueof(int)"}, {"type": "API", "offset": [16], "text": "integer"}], "relation": [{"type": "behavior difference", "args": [{"type": "API", "offset": [7], "text": "valueof(int)"}, {"type": "API", "offset": [16], "text": "integer"}]}], "event": [], "spot": ["API"], "asoc": ["behavior difference"], "spot_asoc": [{"span": "valueof(int)", "label": "API", "asoc": [["behavior difference", "integer"]]}, {"span": "integer", "label": "API", "asoc": []}]}
{"text": "the caching happens only if you use valueof  ,  not if you use new integer", "tokens": ["the", "caching", "happens", "only", "if", "you", "use", "valueof", "", ",", "", "not", "if", "you", "use", "new", "integer", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> valueof <extra_id_0> behavior difference <extra_id_5> integer <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> integer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "valueof"}, {"type": "API", "offset": [16], "text": "integer"}], "relation": [{"type": "behavior difference", "args": [{"type": "API", "offset": [7], "text": "valueof"}, {"type": "API", "offset": [16], "text": "integer"}]}], "event": [], "spot": ["API"], "asoc": ["behavior difference"], "spot_asoc": [{"span": "valueof", "label": "API", "asoc": [["behavior difference", "integer"]]}, {"span": "integer", "label": "API", "asoc": []}]}
{"text": "the caching happens only if you use integer.valueof  ,  not if you use new integer", "tokens": ["the", "caching", "happens", "only", "if", "you", "use", "integer.valueof", "", ",", "", "not", "if", "you", "use", "new", "integer", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> integer.valueof <extra_id_0> behavior difference <extra_id_5> integer <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> integer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "integer.valueof"}, {"type": "API", "offset": [16], "text": "integer"}], "relation": [{"type": "behavior difference", "args": [{"type": "API", "offset": [7], "text": "integer.valueof"}, {"type": "API", "offset": [16], "text": "integer"}]}], "event": [], "spot": ["API"], "asoc": ["behavior difference"], "spot_asoc": [{"span": "integer.valueof", "label": "API", "asoc": [["behavior difference", "integer"]]}, {"span": "integer", "label": "API", "asoc": []}]}
{"text": "the argument passed to exit() will be used as the return value of the jvm process on most os", "tokens": ["the", "argument", "passed", "to", "exit()", "will", "be", "used", "as", "the", "return", "value", "of", "the", "jvm", "process", "on", "most", "os", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> exit() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "exit()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "exit()", "label": "API", "asoc": []}]}
{"text": "the argument passed to exit will be used as the return value of the jvm process on most os", "tokens": ["the", "argument", "passed", "to", "exit", "will", "be", "used", "as", "the", "return", "value", "of", "the", "jvm", "process", "on", "most", "os", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> exit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "exit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "exit", "label": "API", "asoc": []}]}
{"text": "the argument passed to system.exit will be used as the return value of the jvm process on most os", "tokens": ["the", "argument", "passed", "to", "system.exit", "will", "be", "used", "as", "the", "return", "value", "of", "the", "jvm", "process", "on", "most", "os", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.exit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.exit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.exit", "label": "API", "asoc": []}]}
{"text": "this is in contrast to nanotime()  .", "tokens": ["this", "is", "in", "contrast", "to", "nanotime()", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nanotime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "nanotime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nanotime()", "label": "API", "asoc": []}]}
{"text": "this is in contrast to nanotime  .", "tokens": ["this", "is", "in", "contrast", "to", "nanotime", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nanotime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "nanotime"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nanotime", "label": "API", "asoc": []}]}
{"text": "this is in contrast to system.nanotime  .", "tokens": ["this", "is", "in", "contrast", "to", "system.nanotime", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.nanotime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "system.nanotime"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.nanotime", "label": "API", "asoc": []}]}
{"text": "you can write the acl info to standard output  ,  and use the streams available on the process to read the process output", "tokens": ["you", "can", "write", "the", "acl", "info", "to", "standard", "output", "", ",", "", "and", "use", "the", "streams", "available", "on", "the", "process", "to", "read", "the", "process", "output", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> process <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "process"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "process", "label": "API", "asoc": []}]}
{"text": "a static inner class: the entry class used by my triemap class does not need to refer to the object that created it so it can be made static to save the unnecessary reference", "tokens": ["a", "static", "inner", "class:", "the", "entry", "class", "used", "by", "my", "triemap", "class", "does", "not", "need", "to", "refer", "to", "the", "object", "that", "created", "it", "so", "it", "can", "be", "made", "static", "to", "save", "the", "unnecessary", "reference", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> entry <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "entry"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "entry", "label": "API", "asoc": []}]}
{"text": "to get a current download url  ,  use getdownloadur()", "tokens": ["to", "get", "a", "current", "download", "url", "", ",", "", "use", "getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to get a current download url  ,  use getdownloadur", "tokens": ["to", "get", "a", "current", "download", "url", "", ",", "", "use", "getdownloadur", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getdownloadur <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getdownloadur"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getdownloadur", "label": "API", "asoc": []}]}
{"text": "to get a current download url  ,  use storagereference.getdownloadur", "tokens": ["to", "get", "a", "current", "download", "url", "", ",", "", "use", "storagereference.getdownloadur", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "storagereference.getdownloadur"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur", "label": "API", "asoc": []}]}
{"text": "here is the detailed explanation of why \" nextint(n) is both more efficient and less biased than random() \"", "tokens": ["here", "is", "the", "detailed", "explanation", "of", "why", "\"", "nextint(n)", "is", "both", "more", "efficient", "and", "less", "biased", "than", "random()", "\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextint(n) <extra_id_0> efficiency comparison <extra_id_5> random() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> random() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "nextint(n)"}, {"type": "API", "offset": [17], "text": "random()"}], "relation": [{"type": "efficiency comparison", "args": [{"type": "API", "offset": [8], "text": "nextint(n)"}, {"type": "API", "offset": [17], "text": "random()"}]}], "event": [], "spot": ["API"], "asoc": ["efficiency comparison"], "spot_asoc": [{"span": "nextint(n)", "label": "API", "asoc": [["efficiency comparison", "random()"]]}, {"span": "random()", "label": "API", "asoc": []}]}
{"text": "here is the detailed explanation of why \" nextint(n) is both more efficient and less biased than random \"", "tokens": ["here", "is", "the", "detailed", "explanation", "of", "why", "\"", "nextint(n)", "is", "both", "more", "efficient", "and", "less", "biased", "than", "random", "\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextint(n) <extra_id_0> efficiency comparison <extra_id_5> random <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "nextint(n)"}, {"type": "API", "offset": [17], "text": "random"}], "relation": [{"type": "efficiency comparison", "args": [{"type": "API", "offset": [8], "text": "nextint(n)"}, {"type": "API", "offset": [17], "text": "random"}]}], "event": [], "spot": ["API"], "asoc": ["efficiency comparison"], "spot_asoc": [{"span": "nextint(n)", "label": "API", "asoc": [["efficiency comparison", "random"]]}, {"span": "random", "label": "API", "asoc": []}]}
{"text": "here is the detailed explanation of why \" nextint(n) is both more efficient and less biased than math.random \"", "tokens": ["here", "is", "the", "detailed", "explanation", "of", "why", "\"", "nextint(n)", "is", "both", "more", "efficient", "and", "less", "biased", "than", "math.random", "\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextint(n) <extra_id_0> efficiency comparison <extra_id_5> math.random <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> math.random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "nextint(n)"}, {"type": "API", "offset": [17], "text": "math.random"}], "relation": [{"type": "efficiency comparison", "args": [{"type": "API", "offset": [8], "text": "nextint(n)"}, {"type": "API", "offset": [17], "text": "math.random"}]}], "event": [], "spot": ["API"], "asoc": ["efficiency comparison"], "spot_asoc": [{"span": "nextint(n)", "label": "API", "asoc": [["efficiency comparison", "math.random"]]}, {"span": "math.random", "label": "API", "asoc": []}]}
{"text": "here is the detailed explanation of why \" nextint is both more efficient and less biased than random() \"", "tokens": ["here", "is", "the", "detailed", "explanation", "of", "why", "\"", "nextint", "is", "both", "more", "efficient", "and", "less", "biased", "than", "random()", "\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextint <extra_id_0> efficiency comparison <extra_id_5> random() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> random() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "nextint"}, {"type": "API", "offset": [17], "text": "random()"}], "relation": [{"type": "efficiency comparison", "args": [{"type": "API", "offset": [8], "text": "nextint"}, {"type": "API", "offset": [17], "text": "random()"}]}], "event": [], "spot": ["API"], "asoc": ["efficiency comparison"], "spot_asoc": [{"span": "nextint", "label": "API", "asoc": [["efficiency comparison", "random()"]]}, {"span": "random()", "label": "API", "asoc": []}]}
{"text": "here is the detailed explanation of why \" nextint is both more efficient and less biased than random \"", "tokens": ["here", "is", "the", "detailed", "explanation", "of", "why", "\"", "nextint", "is", "both", "more", "efficient", "and", "less", "biased", "than", "random", "\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextint <extra_id_0> efficiency comparison <extra_id_5> random <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "nextint"}, {"type": "API", "offset": [17], "text": "random"}], "relation": [{"type": "efficiency comparison", "args": [{"type": "API", "offset": [8], "text": "nextint"}, {"type": "API", "offset": [17], "text": "random"}]}], "event": [], "spot": ["API"], "asoc": ["efficiency comparison"], "spot_asoc": [{"span": "nextint", "label": "API", "asoc": [["efficiency comparison", "random"]]}, {"span": "random", "label": "API", "asoc": []}]}
{"text": "here is the detailed explanation of why \" nextint is both more efficient and less biased than math.random \"", "tokens": ["here", "is", "the", "detailed", "explanation", "of", "why", "\"", "nextint", "is", "both", "more", "efficient", "and", "less", "biased", "than", "math.random", "\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextint <extra_id_0> efficiency comparison <extra_id_5> math.random <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> math.random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "nextint"}, {"type": "API", "offset": [17], "text": "math.random"}], "relation": [{"type": "efficiency comparison", "args": [{"type": "API", "offset": [8], "text": "nextint"}, {"type": "API", "offset": [17], "text": "math.random"}]}], "event": [], "spot": ["API"], "asoc": ["efficiency comparison"], "spot_asoc": [{"span": "nextint", "label": "API", "asoc": [["efficiency comparison", "math.random"]]}, {"span": "math.random", "label": "API", "asoc": []}]}
{"text": "here is the detailed explanation of why \" random.nextint is both more efficient and less biased than random() \"", "tokens": ["here", "is", "the", "detailed", "explanation", "of", "why", "\"", "random.nextint", "is", "both", "more", "efficient", "and", "less", "biased", "than", "random()", "\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> random.nextint <extra_id_0> efficiency comparison <extra_id_5> random() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> random() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "random.nextint"}, {"type": "API", "offset": [17], "text": "random()"}], "relation": [{"type": "efficiency comparison", "args": [{"type": "API", "offset": [8], "text": "random.nextint"}, {"type": "API", "offset": [17], "text": "random()"}]}], "event": [], "spot": ["API"], "asoc": ["efficiency comparison"], "spot_asoc": [{"span": "random.nextint", "label": "API", "asoc": [["efficiency comparison", "random()"]]}, {"span": "random()", "label": "API", "asoc": []}]}
{"text": "here is the detailed explanation of why \" random.nextint is both more efficient and less biased than random \"", "tokens": ["here", "is", "the", "detailed", "explanation", "of", "why", "\"", "random.nextint", "is", "both", "more", "efficient", "and", "less", "biased", "than", "random", "\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> random.nextint <extra_id_0> efficiency comparison <extra_id_5> random <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "random.nextint"}, {"type": "API", "offset": [17], "text": "random"}], "relation": [{"type": "efficiency comparison", "args": [{"type": "API", "offset": [8], "text": "random.nextint"}, {"type": "API", "offset": [17], "text": "random"}]}], "event": [], "spot": ["API"], "asoc": ["efficiency comparison"], "spot_asoc": [{"span": "random.nextint", "label": "API", "asoc": [["efficiency comparison", "random"]]}, {"span": "random", "label": "API", "asoc": []}]}
{"text": "here is the detailed explanation of why \" random.nextint is both more efficient and less biased than math.random \"", "tokens": ["here", "is", "the", "detailed", "explanation", "of", "why", "\"", "random.nextint", "is", "both", "more", "efficient", "and", "less", "biased", "than", "math.random", "\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> random.nextint <extra_id_0> efficiency comparison <extra_id_5> math.random <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> math.random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "random.nextint"}, {"type": "API", "offset": [17], "text": "math.random"}], "relation": [{"type": "efficiency comparison", "args": [{"type": "API", "offset": [8], "text": "random.nextint"}, {"type": "API", "offset": [17], "text": "math.random"}]}], "event": [], "spot": ["API"], "asoc": ["efficiency comparison"], "spot_asoc": [{"span": "random.nextint", "label": "API", "asoc": [["efficiency comparison", "math.random"]]}, {"span": "math.random", "label": "API", "asoc": []}]}
{"text": "once we call pow recursively  ,  it's always with positive numbers and the sign doesn't change until it reaches 0", "tokens": ["once", "we", "call", "pow", "recursively", "", ",", "", "it's", "always", "with", "positive", "numbers", "and", "the", "sign", "doesn't", "change", "until", "it", "reaches", "0", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pow <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pow"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pow", "label": "API", "asoc": []}]}
{"text": "contains() method uses the equals method to evaluate if two objects are the same", "tokens": ["contains()", "method", "uses", "the", "equals", "method", "to", "evaluate", "if", "two", "objects", "are", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> contains() <extra_id_0> logic constraint <extra_id_5> equals <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> equals <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "contains()"}, {"type": "API", "offset": [4], "text": "equals"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [0], "text": "contains()"}, {"type": "API", "offset": [4], "text": "equals"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "contains()", "label": "API", "asoc": [["logic constraint", "equals"]]}, {"span": "equals", "label": "API", "asoc": []}]}
{"text": "contains method uses the equals method to evaluate if two objects are the same", "tokens": ["contains", "method", "uses", "the", "equals", "method", "to", "evaluate", "if", "two", "objects", "are", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> contains <extra_id_0> logic constraint <extra_id_5> equals <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> equals <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "contains"}, {"type": "API", "offset": [4], "text": "equals"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [0], "text": "contains"}, {"type": "API", "offset": [4], "text": "equals"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "contains", "label": "API", "asoc": [["logic constraint", "equals"]]}, {"span": "equals", "label": "API", "asoc": []}]}
{"text": "list.contains method uses the equals method to evaluate if two objects are the same", "tokens": ["list.contains", "method", "uses", "the", "equals", "method", "to", "evaluate", "if", "two", "objects", "are", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> list.contains <extra_id_0> logic constraint <extra_id_5> equals <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> equals <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "list.contains"}, {"type": "API", "offset": [4], "text": "equals"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [0], "text": "list.contains"}, {"type": "API", "offset": [4], "text": "equals"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "list.contains", "label": "API", "asoc": [["logic constraint", "equals"]]}, {"span": "equals", "label": "API", "asoc": []}]}
{"text": "the action specified in foreach is required to be non-interfering", "tokens": ["the", "action", "specified", "in", "foreach", "is", "required", "to", "be", "non-interfering", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> foreach <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "foreach"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "foreach", "label": "API", "asoc": []}]}
{"text": "use the list interface's listiterator method to get a listiterator object", "tokens": ["use", "the", "list", "interface's", "listiterator", "method", "to", "get", "a", "listiterator", "object", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> listiterator <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "listiterator"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "listiterator", "label": "API", "asoc": []}]}
{"text": "exit(0) doesn't return  ,  and the finally block is not executed", "tokens": ["exit(0)", "doesn't", "return", "", ",", "", "and", "the", "finally", "block", "is", "not", "executed", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> exit(0) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "exit(0)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "exit(0)", "label": "API", "asoc": []}]}
{"text": "exit doesn't return  ,  and the finally block is not executed", "tokens": ["exit", "doesn't", "return", "", ",", "", "and", "the", "finally", "block", "is", "not", "executed", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> exit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "exit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "exit", "label": "API", "asoc": []}]}
{"text": "system.exit doesn't return  ,  and the finally block is not executed", "tokens": ["system.exit", "doesn't", "return", "", ",", "", "and", "the", "finally", "block", "is", "not", "executed", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.exit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "system.exit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.exit", "label": "API", "asoc": []}]}
{"text": "this way your en masse results gathering will be optimised rather than waiting on the next slow future result in the order of calling get", "tokens": ["this", "way", "your", "en", "masse", "results", "gathering", "will", "be", "optimised", "rather", "than", "waiting", "on", "the", "next", "slow", "future", "result", "in", "the", "order", "of", "calling", "get", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> get <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [24], "text": "get"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "get", "label": "API", "asoc": []}]}
{"text": "you can remedy this using invokelater from within your run() method; e.g", "tokens": ["you", "can", "remedy", "this", "using", "invokelater", "from", "within", "your", "run()", "method;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> invokelater <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "invokelater"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "invokelater", "label": "API", "asoc": []}]}
{"text": "string is present in package lang which is imported by default in all java programs  .", "tokens": ["string", "is", "present", "in", "package", "lang", "which", "is", "imported", "by", "default", "in", "all", "java", "programs", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> lang <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "lang"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "lang", "label": "API", "asoc": []}]}
{"text": "would .trim work  ?  and if so  ,  how would i use that  ?  yes  ,   trim will work  ,  it will remove leading and trailing spaces from string  ,", "tokens": ["would", ".trim", "work", "", "?", "", "and", "if", "so", "", ",", "", "how", "would", "i", "use", "that", "", "?", "", "yes", "", ",", "", "", "trim", "will", "work", "", ",", "", "it", "will", "remove", "leading", "and", "trailing", "spaces", "from", "string", "", ",", "", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> trim <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [25], "text": "trim"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "trim", "label": "API", "asoc": []}]}
{"text": "i would argue that sort() is better for readability  .", "tokens": ["i", "would", "argue", "that", "sort()", "is", "better", "for", "readability", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> sort() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "sort()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "sort()", "label": "API", "asoc": []}]}
{"text": "i would argue that sort is better for readability  .", "tokens": ["i", "would", "argue", "that", "sort", "is", "better", "for", "readability", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> sort <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "sort"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "sort", "label": "API", "asoc": []}]}
{"text": "i would argue that arrays.sort is better for readability  .", "tokens": ["i", "would", "argue", "that", "arrays.sort", "is", "better", "for", "readability", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "arrays.sort"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort", "label": "API", "asoc": []}]}
{"text": "note that every call to values returns a newly cloned array which might impact performance in a negative way", "tokens": ["note", "that", "every", "call", "to", "values", "returns", "a", "newly", "cloned", "array", "which", "might", "impact", "performance", "in", "a", "negative", "way", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> values <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "values"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "values", "label": "API", "asoc": []}]}
{"text": "you might be able to do this via aspect should you not want to use the instrument", "tokens": ["you", "might", "be", "able", "to", "do", "this", "via", "aspect", "should", "you", "not", "want", "to", "use", "the", "instrument", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> instrument <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "instrument"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "instrument", "label": "API", "asoc": []}]}
{"text": "you have to use the overload of tomap that accepts a merge function", "tokens": ["you", "have", "to", "use", "the", "overload", "of", "tomap", "that", "accepts", "a", "merge", "function", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tomap <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "tomap"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tomap", "label": "API", "asoc": []}]}
{"text": "while the following approach works and is quite fun  ,  in your case it's probably much better to refactor all calls to the sleep into a separate method and add the logging there", "tokens": ["while", "the", "following", "approach", "works", "and", "is", "quite", "fun", "", ",", "", "in", "your", "case", "it's", "probably", "much", "better", "to", "refactor", "all", "calls", "to", "the", "sleep", "into", "a", "separate", "method", "and", "add", "the", "logging", "there", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> sleep <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [25], "text": "sleep"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "sleep", "label": "API", "asoc": []}]}
{"text": "however  ,  examine this example: consider that the first signature of min allows the call to compile whereas the second does not", "tokens": ["however", "", ",", "", "examine", "this", "example:", "consider", "that", "the", "first", "signature", "of", "min", "allows", "the", "call", "to", "compile", "whereas", "the", "second", "does", "not", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> min <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "min"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "min", "label": "API", "asoc": []}]}
{"text": "to use removeall  ,  you'll have to copy the set then use it", "tokens": ["to", "use", "removeall", "", ",", "", "you'll", "have", "to", "copy", "the", "set", "then", "use", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> removeall <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "removeall"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "removeall", "label": "API", "asoc": []}]}
{"text": "for example  ,  this will cause it: in this case you must use the remove() method instead", "tokens": ["for", "example", "", ",", "", "this", "will", "cause", "it:", "in", "this", "case", "you", "must", "use", "the", "remove()", "method", "instead", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "remove()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove()", "label": "API", "asoc": []}]}
{"text": "for example  ,  this will cause it: in this case you must use the remove method instead", "tokens": ["for", "example", "", ",", "", "this", "will", "cause", "it:", "in", "this", "case", "you", "must", "use", "the", "remove", "method", "instead", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "remove"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove", "label": "API", "asoc": []}]}
{"text": "for example  ,  this will cause it: in this case you must use the iterator.remove method instead", "tokens": ["for", "example", "", ",", "", "this", "will", "cause", "it:", "in", "this", "case", "you", "must", "use", "the", "iterator.remove", "method", "instead", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> iterator.remove <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "iterator.remove"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "iterator.remove", "label": "API", "asoc": []}]}
{"text": "let's take the consumer functional interface as an example", "tokens": ["let's", "take", "the", "consumer", "functional", "interface", "as", "an", "example", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> consumer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "consumer"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "consumer", "label": "API", "asoc": []}]}
{"text": "now you can use substring and the like on the data or search it with index  ,  run regexp's on it  ,  etc", "tokens": ["now", "you", "can", "use", "substring", "and", "the", "like", "on", "the", "data", "or", "search", "it", "with", "index", "", ",", "", "run", "regexp's", "on", "it", "", ",", "", "etc", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> substring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "substring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "substring", "label": "API", "asoc": []}]}
{"text": "i will show you few examples  ,  together with hashcode of each string and hashcode of internal char[] value field (i will call it text to distinguish it from string)", "tokens": ["i", "will", "show", "you", "few", "examples", "", ",", "", "together", "with", "hashcode", "of", "each", "string", "and", "hashcode", "of", "internal", "char[]", "value", "field", "(i", "will", "call", "it", "text", "to", "distinguish", "it", "from", "string)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hashcode <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "hashcode"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "hashcode", "label": "API", "asoc": []}]}
{"text": "use the replaceall() method to replace all matches in the string", "tokens": ["use", "the", "replaceall()", "method", "to", "replace", "all", "matches", "in", "the", "string", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replaceall() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "replaceall()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replaceall()", "label": "API", "asoc": []}]}
{"text": "use the replaceall method to replace all matches in the string", "tokens": ["use", "the", "replaceall", "method", "to", "replace", "all", "matches", "in", "the", "string", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replaceall <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "replaceall"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replaceall", "label": "API", "asoc": []}]}
{"text": "use the matcher.replaceall method to replace all matches in the string", "tokens": ["use", "the", "matcher.replaceall", "method", "to", "replace", "all", "matches", "in", "the", "string", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> matcher.replaceall <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "matcher.replaceall"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "matcher.replaceall", "label": "API", "asoc": []}]}
{"text": "and then i set the color using the setcolor function of the graphics  .", "tokens": ["and", "then", "i", "set", "the", "color", "using", "the", "setcolor", "function", "of", "the", "graphics", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> setcolor <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "setcolor"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "setcolor", "label": "API", "asoc": []}]}
{"text": "you can do this with the setclip method in graphics", "tokens": ["you", "can", "do", "this", "with", "the", "setclip", "method", "in", "graphics", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> setclip <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "setclip"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "setclip", "label": "API", "asoc": []}]}
{"text": "you have to override the default tostring method", "tokens": ["you", "have", "to", "override", "the", "default", "tostring", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "tostring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring", "label": "API", "asoc": []}]}
{"text": "you can remove quote() if you want to use regex  ,  but i don't guarantee anything if you do that", "tokens": ["you", "can", "remove", "quote()", "if", "you", "want", "to", "use", "regex", "", ",", "", "but", "i", "don't", "guarantee", "anything", "if", "you", "do", "that", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> quote() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "quote()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "quote()", "label": "API", "asoc": []}]}
{"text": "you can remove quote if you want to use regex  ,  but i don't guarantee anything if you do that", "tokens": ["you", "can", "remove", "quote", "if", "you", "want", "to", "use", "regex", "", ",", "", "but", "i", "don't", "guarantee", "anything", "if", "you", "do", "that", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> quote <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "quote"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "quote", "label": "API", "asoc": []}]}
{"text": "you can remove pattern.quote if you want to use regex  ,  but i don't guarantee anything if you do that", "tokens": ["you", "can", "remove", "pattern.quote", "if", "you", "want", "to", "use", "regex", "", ",", "", "but", "i", "don't", "guarantee", "anything", "if", "you", "do", "that", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pattern.quote <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pattern.quote"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pattern.quote", "label": "API", "asoc": []}]}
{"text": "java supports it via nio and very few people are aware of  ,  the class in question is abstract but that's no issue: abstractinterruptiblechannel", "tokens": ["java", "supports", "it", "via", "nio", "and", "very", "few", "people", "are", "aware", "of", "", ",", "", "the", "class", "in", "question", "is", "abstract", "but", "that's", "no", "issue:", "abstractinterruptiblechannel", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> abstractinterruptiblechannel <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [25], "text": "abstractinterruptiblechannel"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "abstractinterruptiblechannel", "label": "API", "asoc": []}]}
{"text": "to use the pattern attribute in current version of jasper-report for date/time object you need a date class or one of it's subclasses", "tokens": ["to", "use", "the", "pattern", "attribute", "in", "current", "version", "of", "jasper-report", "for", "date/time", "object", "you", "need", "a", "date", "class", "or", "one", "of", "it's", "subclasses", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> date <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "date"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "date", "label": "API", "asoc": []}]}
{"text": "however  ,  the tostring method is still looking at the instance's version of the var variable", "tokens": ["however", "", ",", "", "the", "tostring", "method", "is", "still", "looking", "at", "the", "instance's", "version", "of", "the", "var", "variable", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "tostring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring", "label": "API", "asoc": []}]}
{"text": "now  ,  let's take a look at the implementation of emptylist : this implementation doesn't need the parameter t at all", "tokens": ["now", "", ",", "", "let's", "take", "a", "look", "at", "the", "implementation", "of", "emptylist", ":", "this", "implementation", "doesn't", "need", "the", "parameter", "t", "at", "all", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> emptylist <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "emptylist"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "emptylist", "label": "API", "asoc": []}]}
{"text": "and it does have a reachable reference until (at least) the point at which the start call returns", "tokens": ["and", "it", "does", "have", "a", "reachable", "reference", "until", "(at", "least)", "the", "point", "at", "which", "the", "start", "call", "returns", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> start <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "start"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "start", "label": "API", "asoc": []}]}
{"text": "you need to call next ; when you get the error", "tokens": ["you", "need", "to", "call", "next", ";", "when", "you", "get", "the", "error", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "next"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "next", "label": "API", "asoc": []}]}
{"text": "the equals method checks for value equality  ,  which means that it compares the contents of two objects  .", "tokens": ["the", "equals", "method", "checks", "for", "value", "equality", "", ",", "", "which", "means", "that", "it", "compares", "the", "contents", "of", "two", "objects", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "equals"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "equals", "label": "API", "asoc": []}]}
{"text": "everything you want to know can be found within the stream javadoc", "tokens": ["everything", "you", "want", "to", "know", "can", "be", "found", "within", "the", "stream", "javadoc", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> stream <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "stream"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "stream", "label": "API", "asoc": []}]}
{"text": "the parent container's layout or pack may be involved", "tokens": ["the", "parent", "container's", "layout", "or", "pack", "may", "be", "involved", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pack <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "pack"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pack", "label": "API", "asoc": []}]}
{"text": "here is the createimage method of gifanim", "tokens": ["here", "is", "the", "createimage", "method", "of", "gifanim", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> createimage <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "createimage"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "createimage", "label": "API", "asoc": []}]}
{"text": "use the sort() method: output: here the third element of the array \"is\" should be \"is\"  ,  otherwise it will come in last after sorting", "tokens": ["use", "the", "sort()", "method:", "output:", "here", "the", "third", "element", "of", "the", "array", "\"is\"", "should", "be", "\"is\"", "", ",", "", "otherwise", "it", "will", "come", "in", "last", "after", "sorting", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> sort() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "sort()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "sort()", "label": "API", "asoc": []}]}
{"text": "use the sort method: output: here the third element of the array \"is\" should be \"is\"  ,  otherwise it will come in last after sorting", "tokens": ["use", "the", "sort", "method:", "output:", "here", "the", "third", "element", "of", "the", "array", "\"is\"", "should", "be", "\"is\"", "", ",", "", "otherwise", "it", "will", "come", "in", "last", "after", "sorting", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> sort <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "sort"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "sort", "label": "API", "asoc": []}]}
{"text": "use the arrays.sort method: output: here the third element of the array \"is\" should be \"is\"  ,  otherwise it will come in last after sorting", "tokens": ["use", "the", "arrays.sort", "method:", "output:", "here", "the", "third", "element", "of", "the", "array", "\"is\"", "should", "be", "\"is\"", "", ",", "", "otherwise", "it", "will", "come", "in", "last", "after", "sorting", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "arrays.sort"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort", "label": "API", "asoc": []}]}
{"text": "you get a class from that by accessing its java property", "tokens": ["you", "get", "a", "class", "from", "that", "by", "accessing", "its", "java", "property", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> class <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "class"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "class", "label": "API", "asoc": []}]}
{"text": "the implementation in clone() doesn't call a constructor", "tokens": ["the", "implementation", "in", "clone()", "doesn't", "call", "a", "constructor", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> clone() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "clone()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "clone()", "label": "API", "asoc": []}]}
{"text": "the implementation in clone doesn't call a constructor", "tokens": ["the", "implementation", "in", "clone", "doesn't", "call", "a", "constructor", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> clone <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "clone"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "clone", "label": "API", "asoc": []}]}
{"text": "the implementation in object.clone doesn't call a constructor", "tokens": ["the", "implementation", "in", "object.clone", "doesn't", "call", "a", "constructor", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> object.clone <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "object.clone"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "object.clone", "label": "API", "asoc": []}]}
{"text": "here's the working code: add an import timeunit", "tokens": ["here's", "the", "working", "code:", "add", "an", "import", "timeunit", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timeunit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "timeunit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "timeunit", "label": "API", "asoc": []}]}
{"text": "nextline automatically moves the scanner down after returning the current line", "tokens": ["nextline", "automatically", "moves", "the", "scanner", "down", "after", "returning", "the", "current", "line", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextline <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "nextline"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nextline", "label": "API", "asoc": []}]}
{"text": "random() returns a double value between 0 (inclusive) and 1 (exclusive)", "tokens": ["random()", "returns", "a", "double", "value", "between", "0", "(inclusive)", "and", "1", "(exclusive)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> random() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "random()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "random()", "label": "API", "asoc": []}]}
{"text": "random returns a double value between 0 (inclusive) and 1 (exclusive)", "tokens": ["random", "returns", "a", "double", "value", "between", "0", "(inclusive)", "and", "1", "(exclusive)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "random"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "random", "label": "API", "asoc": []}]}
{"text": "math.random returns a double value between 0 (inclusive) and 1 (exclusive)", "tokens": ["math.random", "returns", "a", "double", "value", "between", "0", "(inclusive)", "and", "1", "(exclusive)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> math.random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "math.random"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "math.random", "label": "API", "asoc": []}]}
{"text": "if you look at size method in alarmmanagerservice.batch.class  ,  it never should be a null", "tokens": ["if", "you", "look", "at", "size", "method", "in", "alarmmanagerservice.batch.class", "", ",", "", "it", "never", "should", "be", "a", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> size <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "size"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "size", "label": "API", "asoc": []}]}
{"text": "since these are iterables  ,  you can call the iterator method more than once", "tokens": ["since", "these", "are", "iterables", "", ",", "", "you", "can", "call", "the", "iterator", "method", "more", "than", "once", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> iterator <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "iterator"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "iterator", "label": "API", "asoc": []}]}
{"text": "linear time for the remove", "tokens": ["linear", "time", "for", "the", "remove", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "remove"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove", "label": "API", "asoc": []}]}
{"text": "when you pass primitive array to stream  ,  the following code is invoked and when you pass primitive array to of the following code is invoked hence you get different results", "tokens": ["when", "you", "pass", "primitive", "array", "to", "stream", "", ",", "", "the", "following", "code", "is", "invoked", "and", "when", "you", "pass", "primitive", "array", "to", "of", "the", "following", "code", "is", "invoked", "hence", "you", "get", "different", "results", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> stream <extra_id_0> behavior difference <extra_id_5> of <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> of <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "stream"}, {"type": "API", "offset": [22], "text": "of"}], "relation": [{"type": "behavior difference", "args": [{"type": "API", "offset": [6], "text": "stream"}, {"type": "API", "offset": [22], "text": "of"}]}], "event": [], "spot": ["API"], "asoc": ["behavior difference"], "spot_asoc": [{"span": "stream", "label": "API", "asoc": [["behavior difference", "of"]]}, {"span": "of", "label": "API", "asoc": []}]}
{"text": "you need to use the url and urlconnection classes", "tokens": ["you", "need", "to", "use", "the", "url", "and", "urlconnection", "classes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> url <extra_id_0> function collaboration <extra_id_5> urlconnection <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> urlconnection <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "url"}, {"type": "API", "offset": [7], "text": "urlconnection"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [5], "text": "url"}, {"type": "API", "offset": [7], "text": "urlconnection"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "url", "label": "API", "asoc": [["function collaboration", "urlconnection"]]}, {"span": "urlconnection", "label": "API", "asoc": []}]}
{"text": "let's try to understand it with an example of what would happen if we override equals without overriding hashcode and attempt to use a map", "tokens": ["let's", "try", "to", "understand", "it", "with", "an", "example", "of", "what", "would", "happen", "if", "we", "override", "equals", "without", "overriding", "hashcode", "and", "attempt", "to", "use", "a", "map", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals <extra_id_0> logic constraint <extra_id_5> hashcode <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> hashcode <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "equals"}, {"type": "API", "offset": [18], "text": "hashcode"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [15], "text": "equals"}, {"type": "API", "offset": [18], "text": "hashcode"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "equals", "label": "API", "asoc": [["logic constraint", "hashcode"]]}, {"span": "hashcode", "label": "API", "asoc": []}]}
{"text": "isconnected() only tells you about the state of the socket", "tokens": ["isconnected()", "only", "tells", "you", "about", "the", "state", "of", "the", "socket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> isconnected() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "isconnected()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "isconnected()", "label": "API", "asoc": []}]}
{"text": "isconnected only tells you about the state of the socket", "tokens": ["isconnected", "only", "tells", "you", "about", "the", "state", "of", "the", "socket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> isconnected <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "isconnected"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "isconnected", "label": "API", "asoc": []}]}
{"text": "socket.isconnected only tells you about the state of the socket", "tokens": ["socket.isconnected", "only", "tells", "you", "about", "the", "state", "of", "the", "socket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> socket.isconnected <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "socket.isconnected"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "socket.isconnected", "label": "API", "asoc": []}]}
{"text": "queue is an interface so you cannot instantiate it directly", "tokens": ["queue", "is", "an", "interface", "so", "you", "cannot", "instantiate", "it", "directly", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> queue <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "queue"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "queue", "label": "API", "asoc": []}]}
{"text": "your thread is finishing immediately because it does not have a run method defined so it is started and finishes", "tokens": ["your", "thread", "is", "finishing", "immediately", "because", "it", "does", "not", "have", "a", "run", "method", "defined", "so", "it", "is", "started", "and", "finishes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> run <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "run"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "run", "label": "API", "asoc": []}]}
{"text": "enqueue is explicitly for making an asychronous call  .", "tokens": ["enqueue", "is", "explicitly", "for", "making", "an", "asychronous", "call", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> enqueue <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "enqueue"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "enqueue", "label": "API", "asoc": []}]}
{"text": "arraylist is a different class than arraylist  .", "tokens": ["arraylist", "is", "a", "different", "class", "than", "arraylist", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arraylist <extra_id_0> behavior difference <extra_id_5> arraylist <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> arraylist <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "arraylist"}, {"type": "API", "offset": [0], "text": "arraylist"}], "relation": [{"type": "behavior difference", "args": [{"type": "API", "offset": [0], "text": "arraylist"}, {"type": "API", "offset": [0], "text": "arraylist"}]}], "event": [], "spot": ["API"], "asoc": ["behavior difference"], "spot_asoc": [{"span": "arraylist", "label": "API", "asoc": [["behavior difference", "arraylist"]]}, {"span": "arraylist", "label": "API", "asoc": []}]}
{"text": "however  ,  i think that is less likely since you experience it on add", "tokens": ["however", "", ",", "", "i", "think", "that", "is", "less", "likely", "since", "you", "experience", "it", "on", "add", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> add <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "add"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "add", "label": "API", "asoc": []}]}
{"text": "it also gets along with only a single system call that hides behind readallbytes", "tokens": ["it", "also", "gets", "along", "with", "only", "a", "single", "system", "call", "that", "hides", "behind", "readallbytes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> readallbytes <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "readallbytes"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "readallbytes", "label": "API", "asoc": []}]}
{"text": "the tostring method was designed to return a readable representation of an object  ,  not a full representation", "tokens": ["the", "tostring", "method", "was", "designed", "to", "return", "a", "readable", "representation", "of", "an", "object", "", ",", "", "not", "a", "full", "representation", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "tostring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring", "label": "API", "asoc": []}]}
{"text": "but in fact findfirst drives the whole operation  ,  so it efficiently stops after finding one item", "tokens": ["but", "in", "fact", "findfirst", "drives", "the", "whole", "operation", "", ",", "", "so", "it", "efficiently", "stops", "after", "finding", "one", "item", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> findfirst <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "findfirst"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "findfirst", "label": "API", "asoc": []}]}
{"text": "use this function for delays if you do not use interrupt()  ,  as it will preserve the interrupted state of the thread  .", "tokens": ["use", "this", "function", "for", "delays", "if", "you", "do", "not", "use", "interrupt()", "", ",", "", "as", "it", "will", "preserve", "the", "interrupted", "state", "of", "the", "thread", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> interrupt() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "interrupt()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "interrupt()", "label": "API", "asoc": []}]}
{"text": "use this function for delays if you do not use interrupt  ,  as it will preserve the interrupted state of the thread  .", "tokens": ["use", "this", "function", "for", "delays", "if", "you", "do", "not", "use", "interrupt", "", ",", "", "as", "it", "will", "preserve", "the", "interrupted", "state", "of", "the", "thread", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> interrupt <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "interrupt"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "interrupt", "label": "API", "asoc": []}]}
{"text": "use this function for delays if you do not use thread.interrupt  ,  as it will preserve the interrupted state of the thread  .", "tokens": ["use", "this", "function", "for", "delays", "if", "you", "do", "not", "use", "thread.interrupt", "", ",", "", "as", "it", "will", "preserve", "the", "interrupted", "state", "of", "the", "thread", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.interrupt <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "thread.interrupt"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.interrupt", "label": "API", "asoc": []}]}
{"text": "use the keys iterator to iterate over all the properties  ,  and call get for each  .", "tokens": ["use", "the", "keys", "iterator", "to", "iterate", "over", "all", "the", "properties", "", ",", "", "and", "call", "get", "for", "each", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> keys <extra_id_0> logic constraint <extra_id_5> get <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> get <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "keys"}, {"type": "API", "offset": [15], "text": "get"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [2], "text": "keys"}, {"type": "API", "offset": [15], "text": "get"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "keys", "label": "API", "asoc": [["logic constraint", "get"]]}, {"span": "get", "label": "API", "asoc": []}]}
{"text": "arrays contains a bunch of static methods", "tokens": ["arrays", "contains", "a", "bunch", "of", "static", "methods", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "arrays"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays", "label": "API", "asoc": []}]}
{"text": "i wanted to point out that objects has a nice method for this in a broad case  ,  so you can do this: which will clear out your null objects", "tokens": ["i", "wanted", "to", "point", "out", "that", "objects", "has", "a", "nice", "method", "for", "this", "in", "a", "broad", "case", "", ",", "", "so", "you", "can", "do", "this:", "which", "will", "clear", "out", "your", "null", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> objects <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "objects"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "objects", "label": "API", "asoc": []}]}
{"text": "the api docs for the process class say: the created subprocess does not have its own terminal or console", "tokens": ["the", "api", "docs", "for", "the", "process", "class", "say:", "the", "created", "subprocess", "does", "not", "have", "its", "own", "terminal", "or", "console", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> process <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "process"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "process", "label": "API", "asoc": []}]}
{"text": "the method getgridbutton shows how to obtain a button reference efficiently based on its grid coordinates  ,  and the action listener shows that the clicked and found buttons are identical", "tokens": ["the", "method", "getgridbutton", "shows", "how", "to", "obtain", "a", "button", "reference", "efficiently", "based", "on", "its", "grid", "coordinates", "", ",", "", "and", "the", "action", "listener", "shows", "that", "the", "clicked", "and", "found", "buttons", "are", "identical", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getgridbutton <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "getgridbutton"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getgridbutton", "label": "API", "asoc": []}]}
{"text": "calling notify puts one of the threads (if any) from the wait queue (waiting for the condition) into the blocked queue (waiting for the lock)", "tokens": ["calling", "notify", "puts", "one", "of", "the", "threads", "(if", "any)", "from", "the", "wait", "queue", "(waiting", "for", "the", "condition)", "into", "the", "blocked", "queue", "(waiting", "for", "the", "lock)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> notify <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "notify"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "notify", "label": "API", "asoc": []}]}
{"text": "this file contains the name of the jdbc drivers implementation of driver", "tokens": ["this", "file", "contains", "the", "name", "of", "the", "jdbc", "drivers", "implementation", "of", "driver", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> driver <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "driver"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "driver", "label": "API", "asoc": []}]}
{"text": "that string is produced by the default tostring() method", "tokens": ["that", "string", "is", "produced", "by", "the", "default", "tostring()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "that string is produced by the default tostring method", "tokens": ["that", "string", "is", "produced", "by", "the", "default", "tostring", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "tostring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring", "label": "API", "asoc": []}]}
{"text": "that string is produced by the default object.tostring method", "tokens": ["that", "string", "is", "produced", "by", "the", "default", "object.tostring", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> object.tostring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "object.tostring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "object.tostring", "label": "API", "asoc": []}]}
{"text": "the reason for your problem is that following the preceding nextint  ,  you're still on the same line  ,  and nextline returns the rest of the current line", "tokens": ["the", "reason", "for", "your", "problem", "is", "that", "following", "the", "preceding", "nextint", "", ",", "", "you're", "still", "on", "the", "same", "line", "", ",", "", "and", "nextline", "returns", "the", "rest", "of", "the", "current", "line", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextint <extra_id_0> logic constraint <extra_id_5> nextline <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> nextline <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "nextint"}, {"type": "API", "offset": [24], "text": "nextline"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [10], "text": "nextint"}, {"type": "API", "offset": [24], "text": "nextline"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "nextint", "label": "API", "asoc": [["logic constraint", "nextline"]]}, {"span": "nextline", "label": "API", "asoc": []}]}
{"text": "the reflection tutorial suggest the use of isassignablefrom() sample for finding print(string)", "tokens": ["the", "reflection", "tutorial", "suggest", "the", "use", "of", "isassignablefrom()", "sample", "for", "finding", "print(string)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> isassignablefrom() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "isassignablefrom()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "isassignablefrom()", "label": "API", "asoc": []}]}
{"text": "the reflection tutorial suggest the use of isassignablefrom sample for finding print(string)", "tokens": ["the", "reflection", "tutorial", "suggest", "the", "use", "of", "isassignablefrom", "sample", "for", "finding", "print(string)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> isassignablefrom <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "isassignablefrom"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "isassignablefrom", "label": "API", "asoc": []}]}
{"text": "the reflection tutorial suggest the use of class.isassignablefrom sample for finding print(string)", "tokens": ["the", "reflection", "tutorial", "suggest", "the", "use", "of", "class.isassignablefrom", "sample", "for", "finding", "print(string)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> class.isassignablefrom <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "class.isassignablefrom"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "class.isassignablefrom", "label": "API", "asoc": []}]}
{"text": "in fact  ,  if you look at the source of compare()  ,  you will find that it's slightly more complicated than you might think", "tokens": ["in", "fact", "", ",", "", "if", "you", "look", "at", "the", "source", "of", "compare()", "", ",", "", "you", "will", "find", "that", "it's", "slightly", "more", "complicated", "than", "you", "might", "think", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> compare() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "compare()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "compare()", "label": "API", "asoc": []}]}
{"text": "in fact  ,  if you look at the source of compare  ,  you will find that it's slightly more complicated than you might think", "tokens": ["in", "fact", "", ",", "", "if", "you", "look", "at", "the", "source", "of", "compare", "", ",", "", "you", "will", "find", "that", "it's", "slightly", "more", "complicated", "than", "you", "might", "think", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> compare <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "compare"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "compare", "label": "API", "asoc": []}]}
{"text": "in fact  ,  if you look at the source of double.compare  ,  you will find that it's slightly more complicated than you might think", "tokens": ["in", "fact", "", ",", "", "if", "you", "look", "at", "the", "source", "of", "double.compare", "", ",", "", "you", "will", "find", "that", "it's", "slightly", "more", "complicated", "than", "you", "might", "think", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> double.compare <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "double.compare"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "double.compare", "label": "API", "asoc": []}]}
{"text": "you are right in that the tostring method will just return the unformatted string contents of the hssfrichtextstring", "tokens": ["you", "are", "right", "in", "that", "the", "tostring", "method", "will", "just", "return", "the", "unformatted", "string", "contents", "of", "the", "hssfrichtextstring", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "tostring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring", "label": "API", "asoc": []}]}
{"text": "the interrupt method sets an interrupt flag", "tokens": ["the", "interrupt", "method", "sets", "an", "interrupt", "flag", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> interrupt <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "interrupt"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "interrupt", "label": "API", "asoc": []}]}
{"text": "according to the documentation for listfiles()  ,  it will return null if the file is not a directory", "tokens": ["according", "to", "the", "documentation", "for", "listfiles()", "", ",", "", "it", "will", "return", "null", "if", "the", "file", "is", "not", "a", "directory", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> listfiles() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "listfiles()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "listfiles()", "label": "API", "asoc": []}]}
{"text": "according to the documentation for listfiles  ,  it will return null if the file is not a directory", "tokens": ["according", "to", "the", "documentation", "for", "listfiles", "", ",", "", "it", "will", "return", "null", "if", "the", "file", "is", "not", "a", "directory", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> listfiles <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "listfiles"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "listfiles", "label": "API", "asoc": []}]}
{"text": "according to the documentation for file.listfiles  ,  it will return null if the file is not a directory", "tokens": ["according", "to", "the", "documentation", "for", "file.listfiles", "", ",", "", "it", "will", "return", "null", "if", "the", "file", "is", "not", "a", "directory", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.listfiles <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "file.listfiles"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.listfiles", "label": "API", "asoc": []}]}
{"text": "if you want a one-shot alarm  ,  you would just use set", "tokens": ["if", "you", "want", "a", "one-shot", "alarm", "", ",", "", "you", "would", "just", "use", "set", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> set <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "set"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "set", "label": "API", "asoc": []}]}
{"text": "i would recommend using the time package  ,  which has a precision of nanoseconds  ,  like your input", "tokens": ["i", "would", "recommend", "using", "the", "time", "package", "", ",", "", "which", "has", "a", "precision", "of", "nanoseconds", "", ",", "", "like", "your", "input", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "time", "label": "API", "asoc": []}]}
{"text": "override the equals and hashcode methods in the fraction class", "tokens": ["override", "the", "equals", "and", "hashcode", "methods", "in", "the", "fraction", "class", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals <extra_id_0> function collaboration <extra_id_5> hashcode <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> hashcode <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "equals"}, {"type": "API", "offset": [4], "text": "hashcode"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [2], "text": "equals"}, {"type": "API", "offset": [4], "text": "hashcode"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "equals", "label": "API", "asoc": [["function collaboration", "hashcode"]]}, {"span": "hashcode", "label": "API", "asoc": []}]}
{"text": "if your class happens to not override equals  ,  then it will use equals that ends using java == for equality check", "tokens": ["if", "your", "class", "happens", "to", "not", "override", "equals", "", ",", "", "then", "it", "will", "use", "equals", "that", "ends", "using", "java", "==", "for", "equality", "check", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "equals"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "equals", "label": "API", "asoc": []}]}
{"text": "you can use java inbuilt method urlencoder to construct url with param data", "tokens": ["you", "can", "use", "java", "inbuilt", "method", "urlencoder", "to", "construct", "url", "with", "param", "data", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> urlencoder <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "urlencoder"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "urlencoder", "label": "API", "asoc": []}]}
{"text": "when the beginning of a string matches the regex pattern in split()  ,  it results in an additional empty string", "tokens": ["when", "the", "beginning", "of", "a", "string", "matches", "the", "regex", "pattern", "in", "split()", "", ",", "", "it", "results", "in", "an", "additional", "empty", "string", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> split() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "split()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "split()", "label": "API", "asoc": []}]}
{"text": "when the beginning of a string matches the regex pattern in split  ,  it results in an additional empty string", "tokens": ["when", "the", "beginning", "of", "a", "string", "matches", "the", "regex", "pattern", "in", "split", "", ",", "", "it", "results", "in", "an", "additional", "empty", "string", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> split <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "split"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "split", "label": "API", "asoc": []}]}
{"text": "when the beginning of a string matches the regex pattern in string.split  ,  it results in an additional empty string", "tokens": ["when", "the", "beginning", "of", "a", "string", "matches", "the", "regex", "pattern", "in", "string.split", "", ",", "", "it", "results", "in", "an", "additional", "empty", "string", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.split <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "string.split"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.split", "label": "API", "asoc": []}]}
{"text": "you haven't said what you expect it to be  ,  but i suspect you wanted august ( which is month 7 in calendar )", "tokens": ["you", "haven't", "said", "what", "you", "expect", "it", "to", "be", "", ",", "", "but", "i", "suspect", "you", "wanted", "august", "(", "which", "is", "month", "7", "in", "calendar", ")", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> calendar <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [24], "text": "calendar"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "calendar", "label": "API", "asoc": []}]}
{"text": "finally  ,  you could avoid the need to declare a local variable in the take method by using try {} finally {}", "tokens": ["finally", "", ",", "", "you", "could", "avoid", "the", "need", "to", "declare", "a", "local", "variable", "in", "the", "take", "method", "by", "using", "try", "{}", "finally", "{}", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> take <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "take"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "take", "label": "API", "asoc": []}]}
{"text": "btw to make your code cleaner and avoid expensive operations like creating exceptions you should use methods like hasnextint", "tokens": ["btw", "to", "make", "your", "code", "cleaner", "and", "avoid", "expensive", "operations", "like", "creating", "exceptions", "you", "should", "use", "methods", "like", "hasnextint", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hasnextint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "hasnextint"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "hasnextint", "label": "API", "asoc": []}]}
{"text": "if you look at the source  ,  you see that writeobject does not save the backing array", "tokens": ["if", "you", "look", "at", "the", "source", "", ",", "", "you", "see", "that", "writeobject", "does", "not", "save", "the", "backing", "array", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> writeobject <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "writeobject"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "writeobject", "label": "API", "asoc": []}]}
{"text": "the repaint refreshes the view (component)  ,  so whenever you make any change on the component  ,  you must call it", "tokens": ["the", "repaint", "refreshes", "the", "view", "(component)", "", ",", "", "so", "whenever", "you", "make", "any", "change", "on", "the", "component", "", ",", "", "you", "must", "call", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "repaint"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint", "label": "API", "asoc": []}]}
{"text": "you can rewrite the code of run method like this:", "tokens": ["you", "can", "rewrite", "the", "code", "of", "run", "method", "like", "this:", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> run <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "run"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "run", "label": "API", "asoc": []}]}
{"text": "nextdouble() uses next() twice to generate a double that has approximately uniformly distributed bits in its mantissa  ,  so it is uniformly distributed in the range 0 to 1-(2^-53)", "tokens": ["nextdouble()", "uses", "next()", "twice", "to", "generate", "a", "double", "that", "has", "approximately", "uniformly", "distributed", "bits", "in", "its", "mantissa", "", ",", "", "so", "it", "is", "uniformly", "distributed", "in", "the", "range", "0", "to", "1-(2^-53)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextdouble() <extra_id_0> logic constraint <extra_id_5> next() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> next() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "nextdouble()"}, {"type": "API", "offset": [2], "text": "next()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [0], "text": "nextdouble()"}, {"type": "API", "offset": [2], "text": "next()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "nextdouble()", "label": "API", "asoc": [["logic constraint", "next()"]]}, {"span": "next()", "label": "API", "asoc": []}]}
{"text": "nextdouble() uses next twice to generate a double that has approximately uniformly distributed bits in its mantissa  ,  so it is uniformly distributed in the range 0 to 1-(2^-53)", "tokens": ["nextdouble()", "uses", "next", "twice", "to", "generate", "a", "double", "that", "has", "approximately", "uniformly", "distributed", "bits", "in", "its", "mantissa", "", ",", "", "so", "it", "is", "uniformly", "distributed", "in", "the", "range", "0", "to", "1-(2^-53)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextdouble() <extra_id_0> logic constraint <extra_id_5> next <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> next <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "nextdouble()"}, {"type": "API", "offset": [2], "text": "next"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [0], "text": "nextdouble()"}, {"type": "API", "offset": [2], "text": "next"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "nextdouble()", "label": "API", "asoc": [["logic constraint", "next"]]}, {"span": "next", "label": "API", "asoc": []}]}
{"text": "nextdouble() uses random.next twice to generate a double that has approximately uniformly distributed bits in its mantissa  ,  so it is uniformly distributed in the range 0 to 1-(2^-53)", "tokens": ["nextdouble()", "uses", "random.next", "twice", "to", "generate", "a", "double", "that", "has", "approximately", "uniformly", "distributed", "bits", "in", "its", "mantissa", "", ",", "", "so", "it", "is", "uniformly", "distributed", "in", "the", "range", "0", "to", "1-(2^-53)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextdouble() <extra_id_0> logic constraint <extra_id_5> random.next <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> random.next <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "nextdouble()"}, {"type": "API", "offset": [2], "text": "random.next"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [0], "text": "nextdouble()"}, {"type": "API", "offset": [2], "text": "random.next"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "nextdouble()", "label": "API", "asoc": [["logic constraint", "random.next"]]}, {"span": "random.next", "label": "API", "asoc": []}]}
{"text": "nextdouble uses next() twice to generate a double that has approximately uniformly distributed bits in its mantissa  ,  so it is uniformly distributed in the range 0 to 1-(2^-53)", "tokens": ["nextdouble", "uses", "next()", "twice", "to", "generate", "a", "double", "that", "has", "approximately", "uniformly", "distributed", "bits", "in", "its", "mantissa", "", ",", "", "so", "it", "is", "uniformly", "distributed", "in", "the", "range", "0", "to", "1-(2^-53)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextdouble <extra_id_0> logic constraint <extra_id_5> next() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> next() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "nextdouble"}, {"type": "API", "offset": [2], "text": "next()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [0], "text": "nextdouble"}, {"type": "API", "offset": [2], "text": "next()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "nextdouble", "label": "API", "asoc": [["logic constraint", "next()"]]}, {"span": "next()", "label": "API", "asoc": []}]}
{"text": "nextdouble uses next twice to generate a double that has approximately uniformly distributed bits in its mantissa  ,  so it is uniformly distributed in the range 0 to 1-(2^-53)", "tokens": ["nextdouble", "uses", "next", "twice", "to", "generate", "a", "double", "that", "has", "approximately", "uniformly", "distributed", "bits", "in", "its", "mantissa", "", ",", "", "so", "it", "is", "uniformly", "distributed", "in", "the", "range", "0", "to", "1-(2^-53)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextdouble <extra_id_0> logic constraint <extra_id_5> next <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> next <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "nextdouble"}, {"type": "API", "offset": [2], "text": "next"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [0], "text": "nextdouble"}, {"type": "API", "offset": [2], "text": "next"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "nextdouble", "label": "API", "asoc": [["logic constraint", "next"]]}, {"span": "next", "label": "API", "asoc": []}]}
{"text": "nextdouble uses random.next twice to generate a double that has approximately uniformly distributed bits in its mantissa  ,  so it is uniformly distributed in the range 0 to 1-(2^-53)", "tokens": ["nextdouble", "uses", "random.next", "twice", "to", "generate", "a", "double", "that", "has", "approximately", "uniformly", "distributed", "bits", "in", "its", "mantissa", "", ",", "", "so", "it", "is", "uniformly", "distributed", "in", "the", "range", "0", "to", "1-(2^-53)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextdouble <extra_id_0> logic constraint <extra_id_5> random.next <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> random.next <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "nextdouble"}, {"type": "API", "offset": [2], "text": "random.next"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [0], "text": "nextdouble"}, {"type": "API", "offset": [2], "text": "random.next"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "nextdouble", "label": "API", "asoc": [["logic constraint", "random.next"]]}, {"span": "random.next", "label": "API", "asoc": []}]}
{"text": "random.nextdouble uses next() twice to generate a double that has approximately uniformly distributed bits in its mantissa  ,  so it is uniformly distributed in the range 0 to 1-(2^-53)", "tokens": ["random.nextdouble", "uses", "next()", "twice", "to", "generate", "a", "double", "that", "has", "approximately", "uniformly", "distributed", "bits", "in", "its", "mantissa", "", ",", "", "so", "it", "is", "uniformly", "distributed", "in", "the", "range", "0", "to", "1-(2^-53)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> random.nextdouble <extra_id_0> logic constraint <extra_id_5> next() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> next() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "random.nextdouble"}, {"type": "API", "offset": [2], "text": "next()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [0], "text": "random.nextdouble"}, {"type": "API", "offset": [2], "text": "next()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "random.nextdouble", "label": "API", "asoc": [["logic constraint", "next()"]]}, {"span": "next()", "label": "API", "asoc": []}]}
{"text": "random.nextdouble uses next twice to generate a double that has approximately uniformly distributed bits in its mantissa  ,  so it is uniformly distributed in the range 0 to 1-(2^-53)", "tokens": ["random.nextdouble", "uses", "next", "twice", "to", "generate", "a", "double", "that", "has", "approximately", "uniformly", "distributed", "bits", "in", "its", "mantissa", "", ",", "", "so", "it", "is", "uniformly", "distributed", "in", "the", "range", "0", "to", "1-(2^-53)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> random.nextdouble <extra_id_0> logic constraint <extra_id_5> next <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> next <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "random.nextdouble"}, {"type": "API", "offset": [2], "text": "next"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [0], "text": "random.nextdouble"}, {"type": "API", "offset": [2], "text": "next"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "random.nextdouble", "label": "API", "asoc": [["logic constraint", "next"]]}, {"span": "next", "label": "API", "asoc": []}]}
{"text": "random.nextdouble uses random.next twice to generate a double that has approximately uniformly distributed bits in its mantissa  ,  so it is uniformly distributed in the range 0 to 1-(2^-53)", "tokens": ["random.nextdouble", "uses", "random.next", "twice", "to", "generate", "a", "double", "that", "has", "approximately", "uniformly", "distributed", "bits", "in", "its", "mantissa", "", ",", "", "so", "it", "is", "uniformly", "distributed", "in", "the", "range", "0", "to", "1-(2^-53)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> random.nextdouble <extra_id_0> logic constraint <extra_id_5> random.next <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> random.next <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "random.nextdouble"}, {"type": "API", "offset": [2], "text": "random.next"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [0], "text": "random.nextdouble"}, {"type": "API", "offset": [2], "text": "random.next"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "random.nextdouble", "label": "API", "asoc": [["logic constraint", "random.next"]]}, {"span": "random.next", "label": "API", "asoc": []}]}
{"text": "by utilising a single timer it should be more capable of supporting a growing number of random balls", "tokens": ["by", "utilising", "a", "single", "timer", "it", "should", "be", "more", "capable", "of", "supporting", "a", "growing", "number", "of", "random", "balls", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "timer"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "timer", "label": "API", "asoc": []}]}
{"text": "there is a bug in xp where the os call nanotime() uses is not consistent between sockets so as the thread switches which socket it is running on  ,  you can expect to see this jumping around", "tokens": ["there", "is", "a", "bug", "in", "xp", "where", "the", "os", "call", "nanotime()", "uses", "is", "not", "consistent", "between", "sockets", "so", "as", "the", "thread", "switches", "which", "socket", "it", "is", "running", "on", "", ",", "", "you", "can", "expect", "to", "see", "this", "jumping", "around", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nanotime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "nanotime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nanotime()", "label": "API", "asoc": []}]}
{"text": "there is a bug in xp where the os call nanotime uses is not consistent between sockets so as the thread switches which socket it is running on  ,  you can expect to see this jumping around", "tokens": ["there", "is", "a", "bug", "in", "xp", "where", "the", "os", "call", "nanotime", "uses", "is", "not", "consistent", "between", "sockets", "so", "as", "the", "thread", "switches", "which", "socket", "it", "is", "running", "on", "", ",", "", "you", "can", "expect", "to", "see", "this", "jumping", "around", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nanotime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "nanotime"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nanotime", "label": "API", "asoc": []}]}
{"text": "there is a bug in xp where the os call system.nanotime uses is not consistent between sockets so as the thread switches which socket it is running on  ,  you can expect to see this jumping around", "tokens": ["there", "is", "a", "bug", "in", "xp", "where", "the", "os", "call", "system.nanotime", "uses", "is", "not", "consistent", "between", "sockets", "so", "as", "the", "thread", "switches", "which", "socket", "it", "is", "running", "on", "", ",", "", "you", "can", "expect", "to", "see", "this", "jumping", "around", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.nanotime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "system.nanotime"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.nanotime", "label": "API", "asoc": []}]}
{"text": "for others with the same error (does not answer this exact question) i experienced this error with hibernate 4.3 and 5.0.5 due to fields of type localdatetime", "tokens": ["for", "others", "with", "the", "same", "error", "(does", "not", "answer", "this", "exact", "question)", "i", "experienced", "this", "error", "with", "hibernate", "4.3", "and", "5.0.5", "due", "to", "fields", "of", "type", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [26], "text": "localdatetime"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for sorting primarily by age  ,  and then by name in case of ties: combine that with sort  ,  and you are done  .", "tokens": ["for", "sorting", "primarily", "by", "age", "", ",", "", "and", "then", "by", "name", "in", "case", "of", "ties:", "combine", "that", "with", "sort", "", ",", "", "and", "you", "are", "done", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> sort <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "sort"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "sort", "label": "API", "asoc": []}]}
{"text": "the exception in your stacktrace says which essentially means that getcolumnindex could not find the specified column in the cursor and -1 was returned as column index", "tokens": ["the", "exception", "in", "your", "stacktrace", "says", "which", "essentially", "means", "that", "getcolumnindex", "could", "not", "find", "the", "specified", "column", "in", "the", "cursor", "and", "-1", "was", "returned", "as", "column", "index", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumnindex <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolumnindex"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumnindex", "label": "API", "asoc": []}]}
{"text": "the majority of questions about scanner are of the how can i get my program to quit when i enter some specific input category", "tokens": ["the", "majority", "of", "questions", "about", "scanner", "are", "of", "the", "how", "can", "i", "get", "my", "program", "to", "quit", "when", "i", "enter", "some", "specific", "input", "category", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> scanner <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "scanner"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "scanner", "label": "API", "asoc": []}]}
{"text": "as you can see  ,  it doesn't make your transactions actually read-only since you still can persist changes by calling flush manually", "tokens": ["as", "you", "can", "see", "", ",", "", "it", "doesn't", "make", "your", "transactions", "actually", "read-only", "since", "you", "still", "can", "persist", "changes", "by", "calling", "flush", "manually", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> flush <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "flush"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "flush", "label": "API", "asoc": []}]}
{"text": "the repaint method just adds a paint request to the repaintmanager", "tokens": ["the", "repaint", "method", "just", "adds", "a", "paint", "request", "to", "the", "repaintmanager", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "repaint"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint", "label": "API", "asoc": []}]}
{"text": "in hotspot jvm by default on the first invocation of non-overloaded hashcode or identityhashcode a random number is generated and stored in the object header", "tokens": ["in", "hotspot", "jvm", "by", "default", "on", "the", "first", "invocation", "of", "non-overloaded", "hashcode", "or", "identityhashcode", "a", "random", "number", "is", "generated", "and", "stored", "in", "the", "object", "header", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hashcode <extra_id_0> function similarity <extra_id_5> identityhashcode <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> identityhashcode <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "hashcode"}, {"type": "API", "offset": [13], "text": "identityhashcode"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [11], "text": "hashcode"}, {"type": "API", "offset": [13], "text": "identityhashcode"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "hashcode", "label": "API", "asoc": [["function similarity", "identityhashcode"]]}, {"span": "identityhashcode", "label": "API", "asoc": []}]}
{"text": "using next will only return what comes before the delimiter (defaults to whitespace)", "tokens": ["using", "next", "will", "only", "return", "what", "comes", "before", "the", "delimiter", "(defaults", "to", "whitespace)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "next"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "next", "label": "API", "asoc": []}]}
{"text": "you will need to prevent close from being called somehow", "tokens": ["you", "will", "need", "to", "prevent", "close", "from", "being", "called", "somehow", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> close <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "close"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "close", "label": "API", "asoc": []}]}
{"text": "in this case you need to request such a synchronization explicitly by calling refresh  .", "tokens": ["in", "this", "case", "you", "need", "to", "request", "such", "a", "synchronization", "explicitly", "by", "calling", "refresh", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> refresh <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "refresh"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "refresh", "label": "API", "asoc": []}]}
{"text": "the method  as you can see it uses either getcolor or getselectioncolor", "tokens": ["the", "method", "", "as", "you", "can", "see", "it", "uses", "either", "getcolor", "or", "getselectioncolor", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolor <extra_id_0> function similarity <extra_id_5> getselectioncolor <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> getselectioncolor <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolor"}, {"type": "API", "offset": [12], "text": "getselectioncolor"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [10], "text": "getcolor"}, {"type": "API", "offset": [12], "text": "getselectioncolor"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "getcolor", "label": "API", "asoc": [["function similarity", "getselectioncolor"]]}, {"span": "getselectioncolor", "label": "API", "asoc": []}]}
{"text": "but most likely  ,  you'll need to get real familiar with formatter", "tokens": ["but", "most", "likely", "", ",", "", "you'll", "need", "to", "get", "real", "familiar", "with", "formatter", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> formatter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "formatter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "formatter", "label": "API", "asoc": []}]}
{"text": "so try checking exists before you do anything with the file  .", "tokens": ["so", "try", "checking", "exists", "before", "you", "do", "anything", "with", "the", "file", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> exists <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "exists"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "exists", "label": "API", "asoc": []}]}
{"text": "from the source code of random", "tokens": ["from", "the", "source", "code", "of", "random", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "random"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "random", "label": "API", "asoc": []}]}
{"text": "one thing you could do is use nextline instead  ,  then explicitly try and parse the returned string into an integer", "tokens": ["one", "thing", "you", "could", "do", "is", "use", "nextline", "instead", "", ",", "", "then", "explicitly", "try", "and", "parse", "the", "returned", "string", "into", "an", "integer", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextline <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "nextline"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nextline", "label": "API", "asoc": []}]}
{"text": "sort method takes two parameters", "tokens": ["sort", "method", "takes", "two", "parameters", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> sort <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "sort"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "sort", "label": "API", "asoc": []}]}
{"text": "well  ,  the api for valueof(string) does indeed say that the string is interpreted exactly as if it were given to parseint(string)", "tokens": ["well", "", ",", "", "the", "api", "for", "valueof(string)", "does", "indeed", "say", "that", "the", "string", "is", "interpreted", "exactly", "as", "if", "it", "were", "given", "to", "parseint(string)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> valueof(string) <extra_id_0> function similarity <extra_id_5> parseint(string) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> parseint(string) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "valueof(string)"}, {"type": "API", "offset": [23], "text": "parseint(string)"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [7], "text": "valueof(string)"}, {"type": "API", "offset": [23], "text": "parseint(string)"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "valueof(string)", "label": "API", "asoc": [["function similarity", "parseint(string)"]]}, {"span": "parseint(string)", "label": "API", "asoc": []}]}
{"text": "well  ,  the api for valueof(string) does indeed say that the string is interpreted exactly as if it were given to parseint", "tokens": ["well", "", ",", "", "the", "api", "for", "valueof(string)", "does", "indeed", "say", "that", "the", "string", "is", "interpreted", "exactly", "as", "if", "it", "were", "given", "to", "parseint", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> valueof(string) <extra_id_0> function similarity <extra_id_5> parseint <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> parseint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "valueof(string)"}, {"type": "API", "offset": [23], "text": "parseint"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [7], "text": "valueof(string)"}, {"type": "API", "offset": [23], "text": "parseint"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "valueof(string)", "label": "API", "asoc": [["function similarity", "parseint"]]}, {"span": "parseint", "label": "API", "asoc": []}]}
{"text": "well  ,  the api for valueof(string) does indeed say that the string is interpreted exactly as if it were given to integer.parseint", "tokens": ["well", "", ",", "", "the", "api", "for", "valueof(string)", "does", "indeed", "say", "that", "the", "string", "is", "interpreted", "exactly", "as", "if", "it", "were", "given", "to", "integer.parseint", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> valueof(string) <extra_id_0> function similarity <extra_id_5> integer.parseint <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> integer.parseint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "valueof(string)"}, {"type": "API", "offset": [23], "text": "integer.parseint"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [7], "text": "valueof(string)"}, {"type": "API", "offset": [23], "text": "integer.parseint"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "valueof(string)", "label": "API", "asoc": [["function similarity", "integer.parseint"]]}, {"span": "integer.parseint", "label": "API", "asoc": []}]}
{"text": "well  ,  the api for valueof does indeed say that the string is interpreted exactly as if it were given to parseint(string)", "tokens": ["well", "", ",", "", "the", "api", "for", "valueof", "does", "indeed", "say", "that", "the", "string", "is", "interpreted", "exactly", "as", "if", "it", "were", "given", "to", "parseint(string)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> valueof <extra_id_0> function similarity <extra_id_5> parseint(string) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> parseint(string) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "valueof"}, {"type": "API", "offset": [23], "text": "parseint(string)"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [7], "text": "valueof"}, {"type": "API", "offset": [23], "text": "parseint(string)"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "valueof", "label": "API", "asoc": [["function similarity", "parseint(string)"]]}, {"span": "parseint(string)", "label": "API", "asoc": []}]}
{"text": "well  ,  the api for valueof does indeed say that the string is interpreted exactly as if it were given to parseint", "tokens": ["well", "", ",", "", "the", "api", "for", "valueof", "does", "indeed", "say", "that", "the", "string", "is", "interpreted", "exactly", "as", "if", "it", "were", "given", "to", "parseint", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> valueof <extra_id_0> function similarity <extra_id_5> parseint <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> parseint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "valueof"}, {"type": "API", "offset": [23], "text": "parseint"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [7], "text": "valueof"}, {"type": "API", "offset": [23], "text": "parseint"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "valueof", "label": "API", "asoc": [["function similarity", "parseint"]]}, {"span": "parseint", "label": "API", "asoc": []}]}
{"text": "well  ,  the api for valueof does indeed say that the string is interpreted exactly as if it were given to integer.parseint", "tokens": ["well", "", ",", "", "the", "api", "for", "valueof", "does", "indeed", "say", "that", "the", "string", "is", "interpreted", "exactly", "as", "if", "it", "were", "given", "to", "integer.parseint", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> valueof <extra_id_0> function similarity <extra_id_5> integer.parseint <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> integer.parseint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "valueof"}, {"type": "API", "offset": [23], "text": "integer.parseint"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [7], "text": "valueof"}, {"type": "API", "offset": [23], "text": "integer.parseint"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "valueof", "label": "API", "asoc": [["function similarity", "integer.parseint"]]}, {"span": "integer.parseint", "label": "API", "asoc": []}]}
{"text": "well  ,  the api for integer.valueof does indeed say that the string is interpreted exactly as if it were given to parseint(string)", "tokens": ["well", "", ",", "", "the", "api", "for", "integer.valueof", "does", "indeed", "say", "that", "the", "string", "is", "interpreted", "exactly", "as", "if", "it", "were", "given", "to", "parseint(string)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> integer.valueof <extra_id_0> function similarity <extra_id_5> parseint(string) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> parseint(string) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "integer.valueof"}, {"type": "API", "offset": [23], "text": "parseint(string)"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [7], "text": "integer.valueof"}, {"type": "API", "offset": [23], "text": "parseint(string)"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "integer.valueof", "label": "API", "asoc": [["function similarity", "parseint(string)"]]}, {"span": "parseint(string)", "label": "API", "asoc": []}]}
{"text": "well  ,  the api for integer.valueof does indeed say that the string is interpreted exactly as if it were given to parseint", "tokens": ["well", "", ",", "", "the", "api", "for", "integer.valueof", "does", "indeed", "say", "that", "the", "string", "is", "interpreted", "exactly", "as", "if", "it", "were", "given", "to", "parseint", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> integer.valueof <extra_id_0> function similarity <extra_id_5> parseint <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> parseint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "integer.valueof"}, {"type": "API", "offset": [23], "text": "parseint"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [7], "text": "integer.valueof"}, {"type": "API", "offset": [23], "text": "parseint"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "integer.valueof", "label": "API", "asoc": [["function similarity", "parseint"]]}, {"span": "parseint", "label": "API", "asoc": []}]}
{"text": "well  ,  the api for integer.valueof does indeed say that the string is interpreted exactly as if it were given to integer.parseint", "tokens": ["well", "", ",", "", "the", "api", "for", "integer.valueof", "does", "indeed", "say", "that", "the", "string", "is", "interpreted", "exactly", "as", "if", "it", "were", "given", "to", "integer.parseint", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> integer.valueof <extra_id_0> function similarity <extra_id_5> integer.parseint <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> integer.parseint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "integer.valueof"}, {"type": "API", "offset": [23], "text": "integer.parseint"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [7], "text": "integer.valueof"}, {"type": "API", "offset": [23], "text": "integer.parseint"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "integer.valueof", "label": "API", "asoc": [["function similarity", "integer.parseint"]]}, {"span": "integer.parseint", "label": "API", "asoc": []}]}
{"text": "if you want this \"as a string\"  ,  the closest thing is to call tostring on the jsonobject location", "tokens": ["if", "you", "want", "this", "\"as", "a", "string\"", "", ",", "", "the", "closest", "thing", "is", "to", "call", "tostring", "on", "the", "jsonobject", "location", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "tostring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring", "label": "API", "asoc": []}]}
{"text": "alternatively  ,  use getresource and the createimage method that takes an url parameter  .", "tokens": ["alternatively", "", ",", "", "use", "getresource", "and", "the", "createimage", "method", "that", "takes", "an", "url", "parameter", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getresource <extra_id_0> function collaboration <extra_id_5> createimage <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> createimage <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "getresource"}, {"type": "API", "offset": [8], "text": "createimage"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [5], "text": "getresource"}, {"type": "API", "offset": [8], "text": "createimage"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "getresource", "label": "API", "asoc": [["function collaboration", "createimage"]]}, {"span": "createimage", "label": "API", "asoc": []}]}
{"text": "perhaps something is calling get while the array list is making its copy with the iterator  .", "tokens": ["perhaps", "something", "is", "calling", "get", "while", "the", "array", "list", "is", "making", "its", "copy", "with", "the", "iterator", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> get <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "get"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "get", "label": "API", "asoc": []}]}
{"text": "i always thought that clone creates an object without calling a constructor", "tokens": ["i", "always", "thought", "that", "clone", "creates", "an", "object", "without", "calling", "a", "constructor", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> clone <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "clone"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "clone", "label": "API", "asoc": []}]}
{"text": "you should use format instead", "tokens": ["you", "should", "use", "format", "instead", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> format <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "format"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "format", "label": "API", "asoc": []}]}
{"text": "and   ,  override the method compareto as per your need", "tokens": ["and", "", "", ",", "", "override", "the", "method", "compareto", "as", "per", "your", "need", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> compareto <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "compareto"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "compareto", "label": "API", "asoc": []}]}
{"text": "in your case  ,  you should be overriding paint", "tokens": ["in", "your", "case", "", ",", "", "you", "should", "be", "overriding", "paint", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> paint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "paint"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "paint", "label": "API", "asoc": []}]}
{"text": "look at the signature of ofnullable()", "tokens": ["look", "at", "the", "signature", "of", "ofnullable()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> ofnullable() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "ofnullable()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "ofnullable()", "label": "API", "asoc": []}]}
{"text": "look at the signature of ofnullable", "tokens": ["look", "at", "the", "signature", "of", "ofnullable", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> ofnullable <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "ofnullable"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "ofnullable", "label": "API", "asoc": []}]}
{"text": "look at the signature of converter.ofnullable", "tokens": ["look", "at", "the", "signature", "of", "converter.ofnullable", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> converter.ofnullable <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "converter.ofnullable"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "converter.ofnullable", "label": "API", "asoc": []}]}
{"text": "appends using invokelater will be processed in the order in which they are enqueued", "tokens": ["appends", "using", "invokelater", "will", "be", "processed", "in", "the", "order", "in", "which", "they", "are", "enqueued", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> invokelater <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "invokelater"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "invokelater", "label": "API", "asoc": []}]}
{"text": "just use the appropriately named method: split()", "tokens": ["just", "use", "the", "appropriately", "named", "method:", "split()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> split() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "split()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "split()", "label": "API", "asoc": []}]}
{"text": "just use the appropriately named method: split", "tokens": ["just", "use", "the", "appropriately", "named", "method:", "split", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> split <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "split"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "split", "label": "API", "asoc": []}]}
{"text": "just use the appropriately named method: string.split", "tokens": ["just", "use", "the", "appropriately", "named", "method:", "string.split", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.split <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "string.split"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.split", "label": "API", "asoc": []}]}
{"text": "in that case you have to also override hashcode", "tokens": ["in", "that", "case", "you", "have", "to", "also", "override", "hashcode", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hashcode <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "hashcode"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "hashcode", "label": "API", "asoc": []}]}
{"text": "you can do it with the following method which only iterates over the map once: the add method on hashset will return false if a value has already been added to the set", "tokens": ["you", "can", "do", "it", "with", "the", "following", "method", "which", "only", "iterates", "over", "the", "map", "once:", "the", "add", "method", "on", "hashset", "will", "return", "false", "if", "a", "value", "has", "already", "been", "added", "to", "the", "set", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> add <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "add"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "add", "label": "API", "asoc": []}]}
{"text": "(and the only place you can sleep() in a swing application is inside a swingworker's doinbackground method", "tokens": ["(and", "the", "only", "place", "you", "can", "sleep()", "in", "a", "swing", "application", "is", "inside", "a", "swingworker's", "doinbackground", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> sleep() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "sleep()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "sleep()", "label": "API", "asoc": []}]}
{"text": "(and the only place you can sleep in a swing application is inside a swingworker's doinbackground method", "tokens": ["(and", "the", "only", "place", "you", "can", "sleep", "in", "a", "swing", "application", "is", "inside", "a", "swingworker's", "doinbackground", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> sleep <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "sleep"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "sleep", "label": "API", "asoc": []}]}
{"text": "(and the only place you can thread.sleep in a swing application is inside a swingworker's doinbackground method", "tokens": ["(and", "the", "only", "place", "you", "can", "thread.sleep", "in", "a", "swing", "application", "is", "inside", "a", "swingworker's", "doinbackground", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "thread.sleep"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep", "label": "API", "asoc": []}]}
{"text": "i added below part below is the source code  ,  it might be not efficient  ,  but it work: look at hashcode()", "tokens": ["i", "added", "below", "part", "below", "is", "the", "source", "code", "", ",", "", "it", "might", "be", "not", "efficient", "", ",", "", "but", "it", "work:", "look", "at", "hashcode()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [25], "text": "hashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "hashcode()", "label": "API", "asoc": []}]}
{"text": "i added below part below is the source code  ,  it might be not efficient  ,  but it work: look at hashcode", "tokens": ["i", "added", "below", "part", "below", "is", "the", "source", "code", "", ",", "", "it", "might", "be", "not", "efficient", "", ",", "", "but", "it", "work:", "look", "at", "hashcode", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hashcode <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [25], "text": "hashcode"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "hashcode", "label": "API", "asoc": []}]}
{"text": "i added below part below is the source code  ,  it might be not efficient  ,  but it work: look at string.hashcode", "tokens": ["i", "added", "below", "part", "below", "is", "the", "source", "code", "", ",", "", "it", "might", "be", "not", "efficient", "", ",", "", "but", "it", "work:", "look", "at", "string.hashcode", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.hashcode <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [25], "text": "string.hashcode"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.hashcode", "label": "API", "asoc": []}]}
{"text": "it might be worthwhile to create a constant for log(2) so you aren't constantly recalculating it  .", "tokens": ["it", "might", "be", "worthwhile", "to", "create", "a", "constant", "for", "log(2)", "so", "you", "aren't", "constantly", "recalculating", "it", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> log(2) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "log(2)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "log(2)", "label": "API", "asoc": []}]}
{"text": "it might be worthwhile to create a constant for log so you aren't constantly recalculating it  .", "tokens": ["it", "might", "be", "worthwhile", "to", "create", "a", "constant", "for", "log", "so", "you", "aren't", "constantly", "recalculating", "it", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> log <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "log"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "log", "label": "API", "asoc": []}]}
{"text": "it might be worthwhile to create a constant for math.log so you aren't constantly recalculating it  .", "tokens": ["it", "might", "be", "worthwhile", "to", "create", "a", "constant", "for", "math.log", "so", "you", "aren't", "constantly", "recalculating", "it", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> math.log <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "math.log"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "math.log", "label": "API", "asoc": []}]}
{"text": "nextint doesn't consume invalid input so it will try read same invalid value over and over again  .", "tokens": ["nextint", "doesn't", "consume", "invalid", "input", "so", "it", "will", "try", "read", "same", "invalid", "value", "over", "and", "over", "again", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "nextint"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nextint", "label": "API", "asoc": []}]}
{"text": "as java rule finally will always be executed except in case when jvm crashes or exit() is called", "tokens": ["as", "java", "rule", "finally", "will", "always", "be", "executed", "except", "in", "case", "when", "jvm", "crashes", "or", "exit()", "is", "called", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> exit() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "exit()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "exit()", "label": "API", "asoc": []}]}
{"text": "as java rule finally will always be executed except in case when jvm crashes or exit is called", "tokens": ["as", "java", "rule", "finally", "will", "always", "be", "executed", "except", "in", "case", "when", "jvm", "crashes", "or", "exit", "is", "called", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> exit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "exit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "exit", "label": "API", "asoc": []}]}
{"text": "as java rule finally will always be executed except in case when jvm crashes or system.exit is called", "tokens": ["as", "java", "rule", "finally", "will", "always", "be", "executed", "except", "in", "case", "when", "jvm", "crashes", "or", "system.exit", "is", "called", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.exit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "system.exit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.exit", "label": "API", "asoc": []}]}
{"text": "you might wanna to have a look at the file package description to get further details on this", "tokens": ["you", "might", "wanna", "to", "have", "a", "look", "at", "the", "file", "package", "description", "to", "get", "further", "details", "on", "this", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "file"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file", "label": "API", "asoc": []}]}
{"text": "and i don't mean a date  ,  which is really an instant", "tokens": ["and", "i", "don't", "mean", "a", "date", "", ",", "", "which", "is", "really", "an", "instant", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> date <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "date"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "date", "label": "API", "asoc": []}]}
{"text": "to avoid direct use of flow control statements like if or while you can use min and max", "tokens": ["to", "avoid", "direct", "use", "of", "flow", "control", "statements", "like", "if", "or", "while", "you", "can", "use", "min", "and", "max", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> min <extra_id_0> function collaboration <extra_id_5> max <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> max <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "min"}, {"type": "API", "offset": [17], "text": "max"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [15], "text": "min"}, {"type": "API", "offset": [17], "text": "max"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "min", "label": "API", "asoc": [["function collaboration", "max"]]}, {"span": "max", "label": "API", "asoc": []}]}
{"text": "instead use instant for a moment in utc with a resolution as fine as nanoseconds", "tokens": ["instead", "use", "instant", "for", "a", "moment", "in", "utc", "with", "a", "resolution", "as", "fine", "as", "nanoseconds", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> instant <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "instant"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "instant", "label": "API", "asoc": []}]}
{"text": "joshua bloch says on effective java you must override hashcode in every class that overrides equals", "tokens": ["joshua", "bloch", "says", "on", "effective", "java", "you", "must", "override", "hashcode", "in", "every", "class", "that", "overrides", "equals", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hashcode <extra_id_0> logic constraint <extra_id_5> equals <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> equals <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "hashcode"}, {"type": "API", "offset": [15], "text": "equals"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [9], "text": "hashcode"}, {"type": "API", "offset": [15], "text": "equals"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "hashcode", "label": "API", "asoc": [["logic constraint", "equals"]]}, {"span": "equals", "label": "API", "asoc": []}]}
{"text": "practice and you'll see it quality code such as concurrent structures  .", "tokens": ["practice", "and", "you'll", "see", "it", "quality", "code", "such", "as", "concurrent", "structures", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> concurrent <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "concurrent"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "concurrent", "label": "API", "asoc": []}]}
{"text": "join() was a perfectly fine way of resolving your issue before countdownlatch and the other synchronizers were created", "tokens": ["join()", "was", "a", "perfectly", "fine", "way", "of", "resolving", "your", "issue", "before", "countdownlatch", "and", "the", "other", "synchronizers", "were", "created", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> join() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "join()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "join()", "label": "API", "asoc": []}]}
{"text": "join was a perfectly fine way of resolving your issue before countdownlatch and the other synchronizers were created", "tokens": ["join", "was", "a", "perfectly", "fine", "way", "of", "resolving", "your", "issue", "before", "countdownlatch", "and", "the", "other", "synchronizers", "were", "created", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> join <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "join"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "join", "label": "API", "asoc": []}]}
{"text": "thread.join was a perfectly fine way of resolving your issue before countdownlatch and the other synchronizers were created", "tokens": ["thread.join", "was", "a", "perfectly", "fine", "way", "of", "resolving", "your", "issue", "before", "countdownlatch", "and", "the", "other", "synchronizers", "were", "created", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.join <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "thread.join"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.join", "label": "API", "asoc": []}]}
{"text": "the painting of the background is done in the paint method", "tokens": ["the", "painting", "of", "the", "background", "is", "done", "in", "the", "paint", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> paint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "paint"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "paint", "label": "API", "asoc": []}]}
{"text": "as further comment  ,  you should be aware of this term in the equals contract: from equals(object)", "tokens": ["as", "further", "comment", "", ",", "", "you", "should", "be", "aware", "of", "this", "term", "in", "the", "equals", "contract:", "from", "equals(object)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals(object) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "equals(object)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "equals(object)", "label": "API", "asoc": []}]}
{"text": "as further comment  ,  you should be aware of this term in the equals contract: from equals", "tokens": ["as", "further", "comment", "", ",", "", "you", "should", "be", "aware", "of", "this", "term", "in", "the", "equals", "contract:", "from", "equals", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "equals"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "equals", "label": "API", "asoc": []}]}
{"text": "as further comment  ,  you should be aware of this term in the equals contract: from object.equals", "tokens": ["as", "further", "comment", "", ",", "", "you", "should", "be", "aware", "of", "this", "term", "in", "the", "equals", "contract:", "from", "object.equals", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> object.equals <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "object.equals"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "object.equals", "label": "API", "asoc": []}]}
{"text": "the intvalue method is however available on the double  ,  as shown in the javadoc some more reading on those primitive types can be found here", "tokens": ["the", "intvalue", "method", "is", "however", "available", "on", "the", "double", "", ",", "", "as", "shown", "in", "the", "javadoc", "some", "more", "reading", "on", "those", "primitive", "types", "can", "be", "found", "here", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> intvalue <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "intvalue"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "intvalue", "label": "API", "asoc": []}]}
{"text": "since java doesn't support primitive collections there is no easy way to use aslist to wrap a primitive array", "tokens": ["since", "java", "doesn't", "support", "primitive", "collections", "there", "is", "no", "easy", "way", "to", "use", "aslist", "to", "wrap", "a", "primitive", "array", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> aslist <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "aslist"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "aslist", "label": "API", "asoc": []}]}
{"text": "firstly  ,  calling flush is not going to do you any good: flush does not commit anything and  ,  as you are logging the error in the same transaction  ,  the insert will be rolled back", "tokens": ["firstly", "", ",", "", "calling", "flush", "is", "not", "going", "to", "do", "you", "any", "good:", "flush", "does", "not", "commit", "anything", "and", "", ",", "", "as", "you", "are", "logging", "the", "error", "in", "the", "same", "transaction", "", ",", "", "the", "insert", "will", "be", "rolled", "back", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> flush <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "flush"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "flush", "label": "API", "asoc": []}]}
{"text": "so when you call aslist(ar) the arrays creates a list with exactly one item - the int array ar", "tokens": ["so", "when", "you", "call", "aslist(ar)", "the", "arrays", "creates", "a", "list", "with", "exactly", "one", "item", "-", "the", "int", "array", "ar", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> aslist(ar) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "aslist(ar)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "aslist(ar)", "label": "API", "asoc": []}]}
{"text": "so when you call aslist the arrays creates a list with exactly one item - the int array ar", "tokens": ["so", "when", "you", "call", "aslist", "the", "arrays", "creates", "a", "list", "with", "exactly", "one", "item", "-", "the", "int", "array", "ar", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> aslist <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "aslist"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "aslist", "label": "API", "asoc": []}]}
{"text": "so when you call arrays.aslist the arrays creates a list with exactly one item - the int array ar", "tokens": ["so", "when", "you", "call", "arrays.aslist", "the", "arrays", "creates", "a", "list", "with", "exactly", "one", "item", "-", "the", "int", "array", "ar", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.aslist <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "arrays.aslist"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.aslist", "label": "API", "asoc": []}]}
{"text": "the following uses the invoke package", "tokens": ["the", "following", "uses", "the", "invoke", "package", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> invoke <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "invoke"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "invoke", "label": "API", "asoc": []}]}
{"text": "what is the potential damage if it was possible to invoke wait outside a synchronized block", "tokens": ["what", "is", "the", "potential", "damage", "if", "it", "was", "possible", "to", "invoke", "wait", "outside", "a", "synchronized", "block", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "wait"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait", "label": "API", "asoc": []}]}
{"text": "it especially initializes the loading of fonts (on the os or included in jar) in a cache by using font implement in awt", "tokens": ["it", "especially", "initializes", "the", "loading", "of", "fonts", "(on", "the", "os", "or", "included", "in", "jar)", "in", "a", "cache", "by", "using", "font", "implement", "in", "awt", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> awt <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "awt"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "awt", "label": "API", "asoc": []}]}
{"text": "in the second and third lines  ,  the target typing is disrupted by the presence of the call to reversed", "tokens": ["in", "the", "second", "and", "third", "lines", "", ",", "", "the", "target", "typing", "is", "disrupted", "by", "the", "presence", "of", "the", "call", "to", "reversed", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> reversed <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "reversed"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "reversed", "label": "API", "asoc": []}]}
{"text": "however  ,  as pointed out below println also does a few other things such as causing a memory barrier  ,  so this isn't a foolproof test", "tokens": ["however", "", ",", "", "as", "pointed", "out", "below", "println", "also", "does", "a", "few", "other", "things", "such", "as", "causing", "a", "memory", "barrier", "", ",", "", "so", "this", "isn't", "a", "foolproof", "test", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> println <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "println"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "println", "label": "API", "asoc": []}]}
{"text": "update: extending simpleformatter did the trick", "tokens": ["update:", "extending", "simpleformatter", "did", "the", "trick", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> simpleformatter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "simpleformatter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "simpleformatter", "label": "API", "asoc": []}]}
{"text": "the full formatting options are documented as part of formatter  .", "tokens": ["the", "full", "formatting", "options", "are", "documented", "as", "part", "of", "formatter", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> formatter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "formatter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "formatter", "label": "API", "asoc": []}]}
{"text": "to do that  ,  you must synchronize on it: the same rule applies to notify / notifyall as well", "tokens": ["to", "do", "that", "", ",", "", "you", "must", "synchronize", "on", "it:", "the", "same", "rule", "applies", "to", "notify", "/", "notifyall", "as", "well", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> notify <extra_id_0> function similarity <extra_id_5> notifyall <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> notifyall <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "notify"}, {"type": "API", "offset": [18], "text": "notifyall"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [16], "text": "notify"}, {"type": "API", "offset": [18], "text": "notifyall"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "notify", "label": "API", "asoc": [["function similarity", "notifyall"]]}, {"span": "notifyall", "label": "API", "asoc": []}]}
{"text": "so hashcode is executed exactly once on the key object you pass as a parameter", "tokens": ["so", "hashcode", "is", "executed", "exactly", "once", "on", "the", "key", "object", "you", "pass", "as", "a", "parameter", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hashcode <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "hashcode"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "hashcode", "label": "API", "asoc": []}]}
{"text": "if you want to parse a url  ,  use uri", "tokens": ["if", "you", "want", "to", "parse", "a", "url", "", ",", "", "use", "uri", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> uri <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "uri"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "uri", "label": "API", "asoc": []}]}
{"text": "a date represents a moment in utc", "tokens": ["a", "date", "represents", "a", "moment", "in", "utc", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> date <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "date"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "date", "label": "API", "asoc": []}]}
{"text": "i had to initialize the variable to new nextint() to prevent it from optimizing away a lot of code  .", "tokens": ["i", "had", "to", "initialize", "the", "variable", "to", "new", "nextint()", "to", "prevent", "it", "from", "optimizing", "away", "a", "lot", "of", "code", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "nextint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nextint()", "label": "API", "asoc": []}]}
{"text": "i had to initialize the variable to new nextint to prevent it from optimizing away a lot of code  .", "tokens": ["i", "had", "to", "initialize", "the", "variable", "to", "new", "nextint", "to", "prevent", "it", "from", "optimizing", "away", "a", "lot", "of", "code", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "nextint"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nextint", "label": "API", "asoc": []}]}
{"text": "i had to initialize the variable to new java.util.random.nextint to prevent it from optimizing away a lot of code  .", "tokens": ["i", "had", "to", "initialize", "the", "variable", "to", "new", "java.util.random.nextint", "to", "prevent", "it", "from", "optimizing", "away", "a", "lot", "of", "code", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.random.nextint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "java.util.random.nextint"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.random.nextint", "label": "API", "asoc": []}]}
{"text": "apparently the interrupt approach doesn't work on \"most\" modern java platforms", "tokens": ["apparently", "the", "interrupt", "approach", "doesn't", "work", "on", "\"most\"", "modern", "java", "platforms", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> interrupt <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "interrupt"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "interrupt", "label": "API", "asoc": []}]}
{"text": "note that you can call unordered to release the ordering contract and potentially increase performance", "tokens": ["note", "that", "you", "can", "call", "unordered", "to", "release", "the", "ordering", "contract", "and", "potentially", "increase", "performance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> unordered <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "unordered"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "unordered", "label": "API", "asoc": []}]}
{"text": "the constructor invocation itself will use  ,  behind the scenes  ,  arraycopy", "tokens": ["the", "constructor", "invocation", "itself", "will", "use", "", ",", "", "behind", "the", "scenes", "", ",", "", "arraycopy", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arraycopy <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "arraycopy"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arraycopy", "label": "API", "asoc": []}]}
{"text": "but i think a work-around for your specific case would be to specify type as object   ,  since this should work ok", "tokens": ["but", "i", "think", "a", "work-around", "for", "your", "specific", "case", "would", "be", "to", "specify", "type", "as", "object", "", "", ",", "", "since", "this", "should", "work", "ok", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> object <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "object"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "object", "label": "API", "asoc": []}]}
{"text": "if the consumer has already begun to wait  ,  he has acquired the lock to the q instance through the synchronized get method and then releases it while he waits", "tokens": ["if", "the", "consumer", "has", "already", "begun", "to", "wait", "", ",", "", "he", "has", "acquired", "the", "lock", "to", "the", "q", "instance", "through", "the", "synchronized", "get", "method", "and", "then", "releases", "it", "while", "he", "waits", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> get <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "get"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "get", "label": "API", "asoc": []}]}
{"text": "this is actually a frequent pattern: have a static getinstance and keep the constructor private", "tokens": ["this", "is", "actually", "a", "frequent", "pattern:", "have", "a", "static", "getinstance", "and", "keep", "the", "constructor", "private", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getinstance <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "getinstance"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getinstance", "label": "API", "asoc": []}]}
{"text": "implementations of charsequence (such as the string class)  ,  and implementations of characteriterator", "tokens": ["implementations", "of", "charsequence", "(such", "as", "the", "string", "class)", "", ",", "", "and", "implementations", "of", "characteriterator", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> charsequence <extra_id_0> function similarity <extra_id_5> characteriterator <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> characteriterator <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "charsequence"}, {"type": "API", "offset": [14], "text": "characteriterator"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [2], "text": "charsequence"}, {"type": "API", "offset": [14], "text": "characteriterator"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "charsequence", "label": "API", "asoc": [["function similarity", "characteriterator"]]}, {"span": "characteriterator", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments  ,  to make getcontext always return null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", "", ",", "", "to", "make", "getcontext", "always", "return", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "getcontext"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext", "label": "API", "asoc": []}]}
{"text": "also keep in mind that parseint() can throw a numberformatexception if it is not able to parse the data in the scores column as an integer  .", "tokens": ["also", "keep", "in", "mind", "that", "parseint()", "can", "throw", "a", "numberformatexception", "if", "it", "is", "not", "able", "to", "parse", "the", "data", "in", "the", "scores", "column", "as", "an", "integer", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> parseint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "parseint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "parseint()", "label": "API", "asoc": []}]}
{"text": "also keep in mind that parseint can throw a numberformatexception if it is not able to parse the data in the scores column as an integer  .", "tokens": ["also", "keep", "in", "mind", "that", "parseint", "can", "throw", "a", "numberformatexception", "if", "it", "is", "not", "able", "to", "parse", "the", "data", "in", "the", "scores", "column", "as", "an", "integer", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> parseint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "parseint"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "parseint", "label": "API", "asoc": []}]}
{"text": "also keep in mind that integer.parseint can throw a numberformatexception if it is not able to parse the data in the scores column as an integer  .", "tokens": ["also", "keep", "in", "mind", "that", "integer.parseint", "can", "throw", "a", "numberformatexception", "if", "it", "is", "not", "able", "to", "parse", "the", "data", "in", "the", "scores", "column", "as", "an", "integer", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> integer.parseint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "integer.parseint"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "integer.parseint", "label": "API", "asoc": []}]}
{"text": "let's take a look at an example: in this example  ,  the show method looks like this: this is the output: page 3 (see line 4 in code sample 3.8) is an a4 page just like page 1  ,  but it's oriented in landscape", "tokens": ["let's", "take", "a", "look", "at", "an", "example:", "in", "this", "example", "", ",", "", "the", "show", "method", "looks", "like", "this:", "this", "is", "the", "output:", "page", "3", "(see", "line", "4", "in", "code", "sample", "3.8)", "is", "an", "a4", "page", "just", "like", "page", "1", "", ",", "", "but", "it's", "oriented", "in", "landscape", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> show <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "show"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "show", "label": "API", "asoc": []}]}
{"text": "calling shutdownoutput on a socket actually sends something on the network (fin) that wakes up my selector on the other side", "tokens": ["calling", "shutdownoutput", "on", "a", "socket", "actually", "sends", "something", "on", "the", "network", "(fin)", "that", "wakes", "up", "my", "selector", "on", "the", "other", "side", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> shutdownoutput <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "shutdownoutput"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "shutdownoutput", "label": "API", "asoc": []}]}
{"text": "don't understand why  ,  since hasnext is supposed to look at something  ,  not change  ,  but it worked", "tokens": ["don't", "understand", "why", "", ",", "", "since", "hasnext", "is", "supposed", "to", "look", "at", "something", "", ",", "", "not", "change", "", ",", "", "but", "it", "worked", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hasnext <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "hasnext"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "hasnext", "label": "API", "asoc": []}]}
{"text": "note that you should not use new file for this", "tokens": ["note", "that", "you", "should", "not", "use", "new", "file", "for", "this", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "file"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file", "label": "API", "asoc": []}]}
{"text": "i would prefer to use suggested timeunit class  .", "tokens": ["i", "would", "prefer", "to", "use", "suggested", "timeunit", "class", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timeunit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "timeunit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "timeunit", "label": "API", "asoc": []}]}
{"text": "i would do it like that: if you want to use the getidentifier method:", "tokens": ["i", "would", "do", "it", "like", "that:", "if", "you", "want", "to", "use", "the", "getidentifier", "method:", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getidentifier <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "getidentifier"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getidentifier", "label": "API", "asoc": []}]}
{"text": "the normally fast set operations ( especially contains ) are quite slow here  ,  as the arrays will be searched in linear time", "tokens": ["the", "normally", "fast", "set", "operations", "(", "especially", "contains", ")", "are", "quite", "slow", "here", "", ",", "", "as", "the", "arrays", "will", "be", "searched", "in", "linear", "time", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> contains <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "contains"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "contains", "label": "API", "asoc": []}]}
{"text": "however  ,  the xml package contains classes that can deal with this format", "tokens": ["however", "", ",", "", "the", "xml", "package", "contains", "classes", "that", "can", "deal", "with", "this", "format", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> xml <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "xml"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "xml", "label": "API", "asoc": []}]}
{"text": "if this is the case  ,  we will use the floor() function", "tokens": ["if", "this", "is", "the", "case", "", ",", "", "we", "will", "use", "the", "floor()", "function", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> floor() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "floor()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "floor()", "label": "API", "asoc": []}]}
{"text": "if this is the case  ,  we will use the floor function", "tokens": ["if", "this", "is", "the", "case", "", ",", "", "we", "will", "use", "the", "floor", "function", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> floor <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "floor"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "floor", "label": "API", "asoc": []}]}
{"text": "if this is the case  ,  we will use the math.floor function", "tokens": ["if", "this", "is", "the", "case", "", ",", "", "we", "will", "use", "the", "math.floor", "function", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> math.floor <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "math.floor"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "math.floor", "label": "API", "asoc": []}]}
{"text": "also note that available() is not documented to mean the same thing as total size", "tokens": ["also", "note", "that", "available()", "is", "not", "documented", "to", "mean", "the", "same", "thing", "as", "total", "size", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "also note that available is not documented to mean the same thing as total size", "tokens": ["also", "note", "that", "available", "is", "not", "documented", "to", "mean", "the", "same", "thing", "as", "total", "size", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "available"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available", "label": "API", "asoc": []}]}
{"text": "also note that fileinputstream.available is not documented to mean the same thing as total size", "tokens": ["also", "note", "that", "fileinputstream.available", "is", "not", "documented", "to", "mean", "the", "same", "thing", "as", "total", "size", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> fileinputstream.available <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "fileinputstream.available"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "fileinputstream.available", "label": "API", "asoc": []}]}
{"text": "as defined by system specification the user.dir property returns the current working directory (i.e", "tokens": ["as", "defined", "by", "system", "specification", "the", "user.dir", "property", "returns", "the", "current", "working", "directory", "(i.e", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "system"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system", "label": "API", "asoc": []}]}
{"text": "edit: i just realized i can simplify the regex quite a bit by putting the alternation inside the lookahead: by the way  ,  have you considered using format to build the regex instead of replace  ?", "tokens": ["edit:", "i", "just", "realized", "i", "can", "simplify", "the", "regex", "quite", "a", "bit", "by", "putting", "the", "alternation", "inside", "the", "lookahead:", "by", "the", "way", "", ",", "", "have", "you", "considered", "using", "format", "to", "build", "the", "regex", "instead", "of", "replace", "", "?", "", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> format <extra_id_0> function replace <extra_id_5> replace <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> replace <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [29], "text": "format"}, {"type": "API", "offset": [36], "text": "replace"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [29], "text": "format"}, {"type": "API", "offset": [36], "text": "replace"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "format", "label": "API", "asoc": [["function replace", "replace"]]}, {"span": "replace", "label": "API", "asoc": []}]}
{"text": "also  ,  any time you do custom painting you need to override the getpreferredsize method of the custom component so the layout managers can do their job  .", "tokens": ["also", "", ",", "", "any", "time", "you", "do", "custom", "painting", "you", "need", "to", "override", "the", "getpreferredsize", "method", "of", "the", "custom", "component", "so", "the", "layout", "managers", "can", "do", "their", "job", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getpreferredsize <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "getpreferredsize"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getpreferredsize", "label": "API", "asoc": []}]}
{"text": "this still does not explain the behavior but it further confirms that sleep is not necessarily the reason behind the consumer suddenly seeing the updates made to the queue", "tokens": ["this", "still", "does", "not", "explain", "the", "behavior", "but", "it", "further", "confirms", "that", "sleep", "is", "not", "necessarily", "the", "reason", "behind", "the", "consumer", "suddenly", "seeing", "the", "updates", "made", "to", "the", "queue", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> sleep <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "sleep"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "sleep", "label": "API", "asoc": []}]}
{"text": "without putting my brain fully into gear  ,  from a quick scan of what you say it looks as though you need to intern your strings", "tokens": ["without", "putting", "my", "brain", "fully", "into", "gear", "", ",", "", "from", "a", "quick", "scan", "of", "what", "you", "say", "it", "looks", "as", "though", "you", "need", "to", "intern", "your", "strings", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> intern <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [25], "text": "intern"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "intern", "label": "API", "asoc": []}]}
{"text": "see the comments for an explanation  ,  but here is an example program that continuously generates objects until it finds two with the same identityhashcode()", "tokens": ["see", "the", "comments", "for", "an", "explanation", "", ",", "", "but", "here", "is", "an", "example", "program", "that", "continuously", "generates", "objects", "until", "it", "finds", "two", "with", "the", "same", "identityhashcode()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [26], "text": "identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "identityhashcode()", "label": "API", "asoc": []}]}
{"text": "see the comments for an explanation  ,  but here is an example program that continuously generates objects until it finds two with the same identityhashcode", "tokens": ["see", "the", "comments", "for", "an", "explanation", "", ",", "", "but", "here", "is", "an", "example", "program", "that", "continuously", "generates", "objects", "until", "it", "finds", "two", "with", "the", "same", "identityhashcode", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> identityhashcode <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [26], "text": "identityhashcode"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "identityhashcode", "label": "API", "asoc": []}]}
{"text": "see the comments for an explanation  ,  but here is an example program that continuously generates objects until it finds two with the same system.identityhashcode", "tokens": ["see", "the", "comments", "for", "an", "explanation", "", ",", "", "but", "here", "is", "an", "example", "program", "that", "continuously", "generates", "objects", "until", "it", "finds", "two", "with", "the", "same", "system.identityhashcode", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [26], "text": "system.identityhashcode"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode", "label": "API", "asoc": []}]}
{"text": "i've performed 100 runs with the same file  ,  and measured each run with nanotime()", "tokens": ["i've", "performed", "100", "runs", "with", "the", "same", "file", "", ",", "", "and", "measured", "each", "run", "with", "nanotime()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nanotime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "nanotime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nanotime()", "label": "API", "asoc": []}]}
{"text": "i've performed 100 runs with the same file  ,  and measured each run with nanotime", "tokens": ["i've", "performed", "100", "runs", "with", "the", "same", "file", "", ",", "", "and", "measured", "each", "run", "with", "nanotime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nanotime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "nanotime"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nanotime", "label": "API", "asoc": []}]}
{"text": "i've performed 100 runs with the same file  ,  and measured each run with system.nanotime", "tokens": ["i've", "performed", "100", "runs", "with", "the", "same", "file", "", ",", "", "and", "measured", "each", "run", "with", "system.nanotime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.nanotime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "system.nanotime"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.nanotime", "label": "API", "asoc": []}]}
{"text": "the time classes use the standard formats by default when parsing/generating strings", "tokens": ["the", "time", "classes", "use", "the", "standard", "formats", "by", "default", "when", "parsing/generating", "strings", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "time", "label": "API", "asoc": []}]}
{"text": "getinetaddress() returns an inetaddress object that contains the ip address of the remote machine", "tokens": ["getinetaddress()", "returns", "an", "inetaddress", "object", "that", "contains", "the", "ip", "address", "of", "the", "remote", "machine", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getinetaddress() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "getinetaddress()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getinetaddress()", "label": "API", "asoc": []}]}
{"text": "getinetaddress returns an inetaddress object that contains the ip address of the remote machine", "tokens": ["getinetaddress", "returns", "an", "inetaddress", "object", "that", "contains", "the", "ip", "address", "of", "the", "remote", "machine", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getinetaddress <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "getinetaddress"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getinetaddress", "label": "API", "asoc": []}]}
{"text": "socket.getinetaddress returns an inetaddress object that contains the ip address of the remote machine", "tokens": ["socket.getinetaddress", "returns", "an", "inetaddress", "object", "that", "contains", "the", "ip", "address", "of", "the", "remote", "machine", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> socket.getinetaddress <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "socket.getinetaddress"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "socket.getinetaddress", "label": "API", "asoc": []}]}
{"text": "when the client exits  ,  readline gives you back the data it read thus far  .", "tokens": ["when", "the", "client", "exits", "", ",", "", "readline", "gives", "you", "back", "the", "data", "it", "read", "thus", "far", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> readline <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "readline"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "readline", "label": "API", "asoc": []}]}
{"text": "surrogate key)  ,  we have to use business/natural key to implement equals method", "tokens": ["surrogate", "key)", "", ",", "", "we", "have", "to", "use", "business/natural", "key", "to", "implement", "equals", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "equals"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "equals", "label": "API", "asoc": []}]}
{"text": "there's an input stream decorator  ,  digestinputstream  ,  so that you can compute the digest while using the input stream as you normally would", "tokens": ["there's", "an", "input", "stream", "decorator", "", ",", "", "digestinputstream", "", ",", "", "so", "that", "you", "can", "compute", "the", "digest", "while", "using", "the", "input", "stream", "as", "you", "normally", "would", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> digestinputstream <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "digestinputstream"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "digestinputstream", "label": "API", "asoc": []}]}
{"text": "the time classes use these standard formats by default when parsing/generating strings", "tokens": ["the", "time", "classes", "use", "these", "standard", "formats", "by", "default", "when", "parsing/generating", "strings", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "time", "label": "API", "asoc": []}]}
{"text": "the static methods valueof and values are created at compile time and do not appear in source code", "tokens": ["the", "static", "methods", "valueof", "and", "values", "are", "created", "at", "compile", "time", "and", "do", "not", "appear", "in", "source", "code", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> valueof <extra_id_0> function similarity <extra_id_5> values <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> values <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "valueof"}, {"type": "API", "offset": [5], "text": "values"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [3], "text": "valueof"}, {"type": "API", "offset": [5], "text": "values"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "valueof", "label": "API", "asoc": [["function similarity", "values"]]}, {"span": "values", "label": "API", "asoc": []}]}
{"text": "calling flush() after printing the first two stack traces and then flush() after printing to the std output stream should get consistent results  .", "tokens": ["calling", "flush()", "after", "printing", "the", "first", "two", "stack", "traces", "and", "then", "flush()", "after", "printing", "to", "the", "std", "output", "stream", "should", "get", "consistent", "results", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> flush() <extra_id_0> logic constraint <extra_id_5> flush() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> flush() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "flush()"}, {"type": "API", "offset": [1], "text": "flush()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [1], "text": "flush()"}, {"type": "API", "offset": [1], "text": "flush()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "flush()", "label": "API", "asoc": [["logic constraint", "flush()"]]}, {"span": "flush()", "label": "API", "asoc": []}]}
{"text": "calling flush() after printing the first two stack traces and then flush after printing to the std output stream should get consistent results  .", "tokens": ["calling", "flush()", "after", "printing", "the", "first", "two", "stack", "traces", "and", "then", "flush", "after", "printing", "to", "the", "std", "output", "stream", "should", "get", "consistent", "results", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> flush() <extra_id_0> logic constraint <extra_id_5> flush <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> flush <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "flush()"}, {"type": "API", "offset": [11], "text": "flush"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [1], "text": "flush()"}, {"type": "API", "offset": [11], "text": "flush"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "flush()", "label": "API", "asoc": [["logic constraint", "flush"]]}, {"span": "flush", "label": "API", "asoc": []}]}
{"text": "calling flush() after printing the first two stack traces and then system.out.flush after printing to the std output stream should get consistent results  .", "tokens": ["calling", "flush()", "after", "printing", "the", "first", "two", "stack", "traces", "and", "then", "system.out.flush", "after", "printing", "to", "the", "std", "output", "stream", "should", "get", "consistent", "results", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> flush() <extra_id_0> logic constraint <extra_id_5> system.out.flush <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> system.out.flush <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "flush()"}, {"type": "API", "offset": [11], "text": "system.out.flush"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [1], "text": "flush()"}, {"type": "API", "offset": [11], "text": "system.out.flush"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "flush()", "label": "API", "asoc": [["logic constraint", "system.out.flush"]]}, {"span": "system.out.flush", "label": "API", "asoc": []}]}
{"text": "calling flush after printing the first two stack traces and then flush() after printing to the std output stream should get consistent results  .", "tokens": ["calling", "flush", "after", "printing", "the", "first", "two", "stack", "traces", "and", "then", "flush()", "after", "printing", "to", "the", "std", "output", "stream", "should", "get", "consistent", "results", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> flush <extra_id_0> logic constraint <extra_id_5> flush() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> flush() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "flush"}, {"type": "API", "offset": [11], "text": "flush()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [1], "text": "flush"}, {"type": "API", "offset": [11], "text": "flush()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "flush", "label": "API", "asoc": [["logic constraint", "flush()"]]}, {"span": "flush()", "label": "API", "asoc": []}]}
{"text": "calling flush after printing the first two stack traces and then flush after printing to the std output stream should get consistent results  .", "tokens": ["calling", "flush", "after", "printing", "the", "first", "two", "stack", "traces", "and", "then", "flush", "after", "printing", "to", "the", "std", "output", "stream", "should", "get", "consistent", "results", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> flush <extra_id_0> logic constraint <extra_id_5> flush <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> flush <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "flush"}, {"type": "API", "offset": [1], "text": "flush"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [1], "text": "flush"}, {"type": "API", "offset": [1], "text": "flush"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "flush", "label": "API", "asoc": [["logic constraint", "flush"]]}, {"span": "flush", "label": "API", "asoc": []}]}
{"text": "calling flush after printing the first two stack traces and then system.out.flush after printing to the std output stream should get consistent results  .", "tokens": ["calling", "flush", "after", "printing", "the", "first", "two", "stack", "traces", "and", "then", "system.out.flush", "after", "printing", "to", "the", "std", "output", "stream", "should", "get", "consistent", "results", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> flush <extra_id_0> logic constraint <extra_id_5> system.out.flush <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> system.out.flush <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "flush"}, {"type": "API", "offset": [11], "text": "system.out.flush"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [1], "text": "flush"}, {"type": "API", "offset": [11], "text": "system.out.flush"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "flush", "label": "API", "asoc": [["logic constraint", "system.out.flush"]]}, {"span": "system.out.flush", "label": "API", "asoc": []}]}
{"text": "calling system.err.flush after printing the first two stack traces and then flush() after printing to the std output stream should get consistent results  .", "tokens": ["calling", "system.err.flush", "after", "printing", "the", "first", "two", "stack", "traces", "and", "then", "flush()", "after", "printing", "to", "the", "std", "output", "stream", "should", "get", "consistent", "results", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.err.flush <extra_id_0> logic constraint <extra_id_5> flush() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> flush() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "system.err.flush"}, {"type": "API", "offset": [11], "text": "flush()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [1], "text": "system.err.flush"}, {"type": "API", "offset": [11], "text": "flush()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "system.err.flush", "label": "API", "asoc": [["logic constraint", "flush()"]]}, {"span": "flush()", "label": "API", "asoc": []}]}
{"text": "calling system.err.flush after printing the first two stack traces and then flush after printing to the std output stream should get consistent results  .", "tokens": ["calling", "system.err.flush", "after", "printing", "the", "first", "two", "stack", "traces", "and", "then", "flush", "after", "printing", "to", "the", "std", "output", "stream", "should", "get", "consistent", "results", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.err.flush <extra_id_0> logic constraint <extra_id_5> flush <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> flush <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "system.err.flush"}, {"type": "API", "offset": [11], "text": "flush"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [1], "text": "system.err.flush"}, {"type": "API", "offset": [11], "text": "flush"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "system.err.flush", "label": "API", "asoc": [["logic constraint", "flush"]]}, {"span": "flush", "label": "API", "asoc": []}]}
{"text": "calling system.err.flush after printing the first two stack traces and then system.out.flush after printing to the std output stream should get consistent results  .", "tokens": ["calling", "system.err.flush", "after", "printing", "the", "first", "two", "stack", "traces", "and", "then", "system.out.flush", "after", "printing", "to", "the", "std", "output", "stream", "should", "get", "consistent", "results", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.err.flush <extra_id_0> logic constraint <extra_id_5> system.out.flush <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> system.out.flush <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "system.err.flush"}, {"type": "API", "offset": [11], "text": "system.out.flush"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [1], "text": "system.err.flush"}, {"type": "API", "offset": [11], "text": "system.out.flush"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "system.err.flush", "label": "API", "asoc": [["logic constraint", "system.out.flush"]]}, {"span": "system.out.flush", "label": "API", "asoc": []}]}
{"text": "this is just the api though  ,  not the storage format inside date", "tokens": ["this", "is", "just", "the", "api", "though", "", ",", "", "not", "the", "storage", "format", "inside", "date", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> date <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "date"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "date", "label": "API", "asoc": []}]}
{"text": "so here  ,  readline will be executed  ,  and its return value stored in line", "tokens": ["so", "here", "", ",", "", "readline", "will", "be", "executed", "", ",", "", "and", "its", "return", "value", "stored", "in", "line", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> readline <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "readline"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "readline", "label": "API", "asoc": []}]}
{"text": "so when nextline is called  ,  it sees that there are no characters before the end-of-line character  ,  so it thinks that an empty line was entered  ,  and you get an empty string back", "tokens": ["so", "when", "nextline", "is", "called", "", ",", "", "it", "sees", "that", "there", "are", "no", "characters", "before", "the", "end-of-line", "character", "", ",", "", "so", "it", "thinks", "that", "an", "empty", "line", "was", "entered", "", ",", "", "and", "you", "get", "an", "empty", "string", "back", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextline <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "nextline"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nextline", "label": "API", "asoc": []}]}
{"text": "when some other thread calls interrupt() the method sets thread's interrupt status flag (initially false) to true", "tokens": ["when", "some", "other", "thread", "calls", "interrupt()", "the", "method", "sets", "thread's", "interrupt", "status", "flag", "(initially", "false)", "to", "true", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> interrupt() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "interrupt()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "interrupt()", "label": "API", "asoc": []}]}
{"text": "when some other thread calls interrupt the method sets thread's interrupt status flag (initially false) to true", "tokens": ["when", "some", "other", "thread", "calls", "interrupt", "the", "method", "sets", "thread's", "interrupt", "status", "flag", "(initially", "false)", "to", "true", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> interrupt <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "interrupt"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "interrupt", "label": "API", "asoc": []}]}
{"text": "when some other thread calls thread.interrupt the method sets thread's interrupt status flag (initially false) to true", "tokens": ["when", "some", "other", "thread", "calls", "thread.interrupt", "the", "method", "sets", "thread's", "interrupt", "status", "flag", "(initially", "false)", "to", "true", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.interrupt <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "thread.interrupt"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.interrupt", "label": "API", "asoc": []}]}
{"text": "give java nio a try: using transferfrom is potentially much more efficient than a simple loop that reads from the source channel and writes to this channel", "tokens": ["give", "java", "nio", "a", "try:", "using", "transferfrom", "is", "potentially", "much", "more", "efficient", "than", "a", "simple", "loop", "that", "reads", "from", "the", "source", "channel", "and", "writes", "to", "this", "channel", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> transferfrom <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "transferfrom"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "transferfrom", "label": "API", "asoc": []}]}
{"text": "the issue is the nextdouble function", "tokens": ["the", "issue", "is", "the", "nextdouble", "function", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextdouble <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "nextdouble"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nextdouble", "label": "API", "asoc": []}]}
{"text": "the second problem is that when you close a scanner that also closes the input source", "tokens": ["the", "second", "problem", "is", "that", "when", "you", "close", "a", "scanner", "that", "also", "closes", "the", "input", "source", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> close <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "close"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "close", "label": "API", "asoc": []}]}
{"text": "he makes a false assertion about cancel", "tokens": ["he", "makes", "a", "false", "assertion", "about", "cancel", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> cancel <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "cancel"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "cancel", "label": "API", "asoc": []}]}
{"text": "if the matcher() were to match the pattern  ,  then there has to be some way to define various ways to match  ,  as matching can be in different ways", "tokens": ["if", "the", "matcher()", "were", "to", "match", "the", "pattern", "", ",", "", "then", "there", "has", "to", "be", "some", "way", "to", "define", "various", "ways", "to", "match", "", ",", "", "as", "matching", "can", "be", "in", "different", "ways", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> matcher() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "matcher()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "matcher()", "label": "API", "asoc": []}]}
{"text": "if the matcher were to match the pattern  ,  then there has to be some way to define various ways to match  ,  as matching can be in different ways", "tokens": ["if", "the", "matcher", "were", "to", "match", "the", "pattern", "", ",", "", "then", "there", "has", "to", "be", "some", "way", "to", "define", "various", "ways", "to", "match", "", ",", "", "as", "matching", "can", "be", "in", "different", "ways", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> matcher <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "matcher"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "matcher", "label": "API", "asoc": []}]}
{"text": "if the pattern.matcher were to match the pattern  ,  then there has to be some way to define various ways to match  ,  as matching can be in different ways", "tokens": ["if", "the", "pattern.matcher", "were", "to", "match", "the", "pattern", "", ",", "", "then", "there", "has", "to", "be", "some", "way", "to", "define", "various", "ways", "to", "match", "", ",", "", "as", "matching", "can", "be", "in", "different", "ways", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pattern.matcher <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "pattern.matcher"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pattern.matcher", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put call clear() does not give you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put", "call", "clear()", "does", "not", "give", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put <extra_id_0> logic constraint <extra_id_5> clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put"}, {"type": "API", "offset": [14], "text": "clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put"}, {"type": "API", "offset": [14], "text": "clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put", "label": "API", "asoc": [["logic constraint", "clear()"]]}, {"span": "clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put call clear does not give you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put", "call", "clear", "does", "not", "give", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put <extra_id_0> logic constraint <extra_id_5> clear <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> clear <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put"}, {"type": "API", "offset": [14], "text": "clear"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put"}, {"type": "API", "offset": [14], "text": "clear"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put", "label": "API", "asoc": [["logic constraint", "clear"]]}, {"span": "clear", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put call map.clear does not give you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put", "call", "map.clear", "does", "not", "give", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put <extra_id_0> logic constraint <extra_id_5> map.clear <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put"}, {"type": "API", "offset": [14], "text": "map.clear"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put"}, {"type": "API", "offset": [14], "text": "map.clear"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put", "label": "API", "asoc": [["logic constraint", "map.clear"]]}, {"span": "map.clear", "label": "API", "asoc": []}]}
{"text": "when reading using read(file) you are effectively stripping away any meta data in the jpeg file  ,  like xmp  ,  exif or icc profiles", "tokens": ["when", "reading", "using", "read(file)", "you", "are", "effectively", "stripping", "away", "any", "meta", "data", "in", "the", "jpeg", "file", "", ",", "", "like", "xmp", "", ",", "", "exif", "or", "icc", "profiles", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> read(file) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "read(file)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "read(file)", "label": "API", "asoc": []}]}
{"text": "when reading using read you are effectively stripping away any meta data in the jpeg file  ,  like xmp  ,  exif or icc profiles", "tokens": ["when", "reading", "using", "read", "you", "are", "effectively", "stripping", "away", "any", "meta", "data", "in", "the", "jpeg", "file", "", ",", "", "like", "xmp", "", ",", "", "exif", "or", "icc", "profiles", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> read <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "read"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "read", "label": "API", "asoc": []}]}
{"text": "when reading using imageio.read you are effectively stripping away any meta data in the jpeg file  ,  like xmp  ,  exif or icc profiles", "tokens": ["when", "reading", "using", "imageio.read", "you", "are", "effectively", "stripping", "away", "any", "meta", "data", "in", "the", "jpeg", "file", "", ",", "", "like", "xmp", "", ",", "", "exif", "or", "icc", "profiles", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> imageio.read <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "imageio.read"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "imageio.read", "label": "API", "asoc": []}]}
{"text": "the isfile() call deals with these cases", "tokens": ["the", "isfile()", "call", "deals", "with", "these", "cases", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> isfile() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "isfile()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "isfile()", "label": "API", "asoc": []}]}
{"text": "the isfile call deals with these cases", "tokens": ["the", "isfile", "call", "deals", "with", "these", "cases", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> isfile <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "isfile"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "isfile", "label": "API", "asoc": []}]}
{"text": "the file.isfile call deals with these cases", "tokens": ["the", "file.isfile", "call", "deals", "with", "these", "cases", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.isfile <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.isfile"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.isfile", "label": "API", "asoc": []}]}
{"text": "if you want to print the contents of an array  ,  try for custom classes  ,  you should always implement (override) your own custom tostring method", "tokens": ["if", "you", "want", "to", "print", "the", "contents", "of", "an", "array", "", ",", "", "try", "for", "custom", "classes", "", ",", "", "you", "should", "always", "implement", "(override)", "your", "own", "custom", "tostring", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [28], "text": "tostring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring", "label": "API", "asoc": []}]}
{"text": "i have explained in my answer from this post a recommended way in which you can paginate queries by combining query cursors with the limit method", "tokens": ["i", "have", "explained", "in", "my", "answer", "from", "this", "post", "a", "recommended", "way", "in", "which", "you", "can", "paginate", "queries", "by", "combining", "query", "cursors", "with", "the", "limit", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> limit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [24], "text": "limit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "limit", "label": "API", "asoc": []}]}
{"text": "if i were to add a new runnable to the code base  ,  i would have to also include that line", "tokens": ["if", "i", "were", "to", "add", "a", "new", "runnable", "to", "the", "code", "base", "", ",", "", "i", "would", "have", "to", "also", "include", "that", "line", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> runnable <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "runnable"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "runnable", "label": "API", "asoc": []}]}
{"text": "whatever you get when you do forname() are stored there", "tokens": ["whatever", "you", "get", "when", "you", "do", "forname()", "are", "stored", "there", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> forname() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "forname()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "forname()", "label": "API", "asoc": []}]}
{"text": "whatever you get when you do forname are stored there", "tokens": ["whatever", "you", "get", "when", "you", "do", "forname", "are", "stored", "there", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> forname <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "forname"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "forname", "label": "API", "asoc": []}]}
{"text": "whatever you get when you do class.forname are stored there", "tokens": ["whatever", "you", "get", "when", "you", "do", "class.forname", "are", "stored", "there", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> class.forname <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "class.forname"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "class.forname", "label": "API", "asoc": []}]}
{"text": "the one-arg parse has parsed the 00 seconds", "tokens": ["the", "one-arg", "parse", "has", "parsed", "the", "00", "seconds", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> parse <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "parse"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "parse", "label": "API", "asoc": []}]}
{"text": "the exception is thrown because you are adding/removing things from the map while you are iterating it: you should use remove() instead  .", "tokens": ["the", "exception", "is", "thrown", "because", "you", "are", "adding/removing", "things", "from", "the", "map", "while", "you", "are", "iterating", "it:", "you", "should", "use", "remove()", "instead", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [20], "text": "remove()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove()", "label": "API", "asoc": []}]}
{"text": "the exception is thrown because you are adding/removing things from the map while you are iterating it: you should use remove instead  .", "tokens": ["the", "exception", "is", "thrown", "because", "you", "are", "adding/removing", "things", "from", "the", "map", "while", "you", "are", "iterating", "it:", "you", "should", "use", "remove", "instead", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [20], "text": "remove"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove", "label": "API", "asoc": []}]}
{"text": "the exception is thrown because you are adding/removing things from the map while you are iterating it: you should use iterator.remove instead  .", "tokens": ["the", "exception", "is", "thrown", "because", "you", "are", "adding/removing", "things", "from", "the", "map", "while", "you", "are", "iterating", "it:", "you", "should", "use", "iterator.remove", "instead", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> iterator.remove <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [20], "text": "iterator.remove"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "iterator.remove", "label": "API", "asoc": []}]}
{"text": "as told by many a wonderful stackoverflow users  ,  the right idea in here is to use the timer", "tokens": ["as", "told", "by", "many", "a", "wonderful", "stackoverflow", "users", "", ",", "", "the", "right", "idea", "in", "here", "is", "to", "use", "the", "timer", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [20], "text": "timer"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "timer", "label": "API", "asoc": []}]}
{"text": "point   ,  you can put the weights into a map: then  ,  you make an image  ,  and for each x , y coordinate  ,  find the best score", "tokens": ["point", "", "", ",", "", "you", "can", "put", "the", "weights", "into", "a", "map:", "then", "", ",", "", "you", "make", "an", "image", "", ",", "", "and", "for", "each", "x", ",", "y", "coordinate", "", ",", "", "find", "the", "best", "score", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> point <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "point"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "point", "label": "API", "asoc": []}]}
{"text": "something like: you can probably use something like: that assumes the time represents the number of milliseconds since midnight  .", "tokens": ["something", "like:", "you", "can", "probably", "use", "something", "like:", "that", "assumes", "the", "time", "represents", "the", "number", "of", "milliseconds", "since", "midnight", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "time", "label": "API", "asoc": []}]}
{"text": "you need collections : if you have to write your own  ,  have that class implement the list interface and throw exceptions for the methods that modify contents  .", "tokens": ["you", "need", "collections", ":", "if", "you", "have", "to", "write", "your", "own", "", ",", "", "have", "that", "class", "implement", "the", "list", "interface", "and", "throw", "exceptions", "for", "the", "methods", "that", "modify", "contents", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> collections <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "collections"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "collections", "label": "API", "asoc": []}]}
{"text": "from the javadoc for scheduleatfixedrate() : throws: illegalstateexception - if task was already scheduled or cancelled  ,  timer was cancelled  ,  or timer thread terminated", "tokens": ["from", "the", "javadoc", "for", "scheduleatfixedrate()", ":", "throws:", "illegalstateexception", "-", "if", "task", "was", "already", "scheduled", "or", "cancelled", "", ",", "", "timer", "was", "cancelled", "", ",", "", "or", "timer", "thread", "terminated", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> scheduleatfixedrate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "scheduleatfixedrate()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "scheduleatfixedrate()", "label": "API", "asoc": []}]}
{"text": "from the javadoc for scheduleatfixedrate : throws: illegalstateexception - if task was already scheduled or cancelled  ,  timer was cancelled  ,  or timer thread terminated", "tokens": ["from", "the", "javadoc", "for", "scheduleatfixedrate", ":", "throws:", "illegalstateexception", "-", "if", "task", "was", "already", "scheduled", "or", "cancelled", "", ",", "", "timer", "was", "cancelled", "", ",", "", "or", "timer", "thread", "terminated", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> scheduleatfixedrate <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "scheduleatfixedrate"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "scheduleatfixedrate", "label": "API", "asoc": []}]}
{"text": "from the javadoc for timer.scheduleatfixedrate : throws: illegalstateexception - if task was already scheduled or cancelled  ,  timer was cancelled  ,  or timer thread terminated", "tokens": ["from", "the", "javadoc", "for", "timer.scheduleatfixedrate", ":", "throws:", "illegalstateexception", "-", "if", "task", "was", "already", "scheduled", "or", "cancelled", "", ",", "", "timer", "was", "cancelled", "", ",", "", "or", "timer", "thread", "terminated", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timer.scheduleatfixedrate <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "timer.scheduleatfixedrate"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "timer.scheduleatfixedrate", "label": "API", "asoc": []}]}
{"text": "split takes a regex as it's argument", "tokens": ["split", "takes", "a", "regex", "as", "it's", "argument", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> split <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "split"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "split", "label": "API", "asoc": []}]}
{"text": "just call dispose method:  for instance: you can dispatch a new windowevent like this: if the window has attached a windowlistener it will be notified", "tokens": ["just", "call", "dispose", "method:", "", "for", "instance:", "you", "can", "dispatch", "a", "new", "windowevent", "like", "this:", "if", "the", "window", "has", "attached", "a", "windowlistener", "it", "will", "be", "notified", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> dispose <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "dispose"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "dispose", "label": "API", "asoc": []}]}
{"text": "as already noted  ,  the parameters to tomap have to be functions  ,  so you have to change 0 to name -&gt;", "tokens": ["as", "already", "noted", "", ",", "", "the", "parameters", "to", "tomap", "have", "to", "be", "functions", "", ",", "", "so", "you", "have", "to", "change", "0", "to", "name", "-&gt;", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tomap <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "tomap"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tomap", "label": "API", "asoc": []}]}
{"text": "and count may not process any elements at all when it can determine the size of the stream without processing the items", "tokens": ["and", "count", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "determine", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count", "label": "API", "asoc": []}]}
{"text": "the relationship between these are documented in the ref package documentation  .", "tokens": ["the", "relationship", "between", "these", "are", "documented", "in", "the", "ref", "package", "documentation", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> ref <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "ref"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "ref", "label": "API", "asoc": []}]}
{"text": "is it safe to use getbytes()   ?  no", "tokens": ["is", "it", "safe", "to", "use", "getbytes()", "", "", "?", "", "no", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getbytes() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "getbytes()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getbytes()", "label": "API", "asoc": []}]}
{"text": "is it safe to use getbytes   ?  no", "tokens": ["is", "it", "safe", "to", "use", "getbytes", "", "", "?", "", "no", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getbytes <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "getbytes"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getbytes", "label": "API", "asoc": []}]}
{"text": "is it safe to use string.getbytes   ?  no", "tokens": ["is", "it", "safe", "to", "use", "string.getbytes", "", "", "?", "", "no", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.getbytes <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "string.getbytes"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.getbytes", "label": "API", "asoc": []}]}
{"text": "you're using readline which expects a newline character", "tokens": ["you're", "using", "readline", "which", "expects", "a", "newline", "character", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> readline <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "readline"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "readline", "label": "API", "asoc": []}]}
{"text": "with that information in your head  ,  a google search for list will take you to the javadoc for the class", "tokens": ["with", "that", "information", "in", "your", "head", "", ",", "", "a", "google", "search", "for", "list", "will", "take", "you", "to", "the", "javadoc", "for", "the", "class", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> list <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "list"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "list", "label": "API", "asoc": []}]}
{"text": "as both rely on a timer thread  ,  neither is a solution  ,  but the techniques may prove useful  .", "tokens": ["as", "both", "rely", "on", "a", "timer", "thread", "", ",", "", "neither", "is", "a", "solution", "", ",", "", "but", "the", "techniques", "may", "prove", "useful", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "timer"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "timer", "label": "API", "asoc": []}]}
{"text": "the old classes are outmoded by time", "tokens": ["the", "old", "classes", "are", "outmoded", "by", "time", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "time", "label": "API", "asoc": []}]}
{"text": "unfortunately the delete() method provides very little information as to why; it's pretty much up to you to poke around and figure it out", "tokens": ["unfortunately", "the", "delete()", "method", "provides", "very", "little", "information", "as", "to", "why;", "it's", "pretty", "much", "up", "to", "you", "to", "poke", "around", "and", "figure", "it", "out", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> delete() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "delete()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "delete()", "label": "API", "asoc": []}]}
{"text": "unfortunately the delete method provides very little information as to why; it's pretty much up to you to poke around and figure it out", "tokens": ["unfortunately", "the", "delete", "method", "provides", "very", "little", "information", "as", "to", "why;", "it's", "pretty", "much", "up", "to", "you", "to", "poke", "around", "and", "figure", "it", "out", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> delete <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "delete"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "delete", "label": "API", "asoc": []}]}
{"text": "unfortunately the file.delete method provides very little information as to why; it's pretty much up to you to poke around and figure it out", "tokens": ["unfortunately", "the", "file.delete", "method", "provides", "very", "little", "information", "as", "to", "why;", "it's", "pretty", "much", "up", "to", "you", "to", "poke", "around", "and", "figure", "it", "out", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.delete <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "file.delete"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.delete", "label": "API", "asoc": []}]}
{"text": "personally i very rarely use available", "tokens": ["personally", "i", "very", "rarely", "use", "available", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "available"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available", "label": "API", "asoc": []}]}
{"text": "the length() will return zero in some cases where you don't have a zero length file; e.g", "tokens": ["the", "length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "have", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "length()", "label": "API", "asoc": []}]}
{"text": "the length will return zero in some cases where you don't have a zero length file; e.g", "tokens": ["the", "length", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "have", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> length <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "length"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "length", "label": "API", "asoc": []}]}
{"text": "the file.length will return zero in some cases where you don't have a zero length file; e.g", "tokens": ["the", "file.length", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "have", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length", "label": "API", "asoc": []}]}
{"text": "that's the reason we have the load factor  ,  and the reason we should use a proper hashcode that spreads the keys as evenly as possible across the buckets  .", "tokens": ["that's", "the", "reason", "we", "have", "the", "load", "factor", "", ",", "", "and", "the", "reason", "we", "should", "use", "a", "proper", "hashcode", "that", "spreads", "the", "keys", "as", "evenly", "as", "possible", "across", "the", "buckets", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hashcode <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "hashcode"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "hashcode", "label": "API", "asoc": []}]}
{"text": "the getfreespace() method returns the number of unallocated bytes in the partition named by this abstract path name", "tokens": ["the", "getfreespace()", "method", "returns", "the", "number", "of", "unallocated", "bytes", "in", "the", "partition", "named", "by", "this", "abstract", "path", "name", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getfreespace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "getfreespace()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getfreespace()", "label": "API", "asoc": []}]}
{"text": "the getfreespace method returns the number of unallocated bytes in the partition named by this abstract path name", "tokens": ["the", "getfreespace", "method", "returns", "the", "number", "of", "unallocated", "bytes", "in", "the", "partition", "named", "by", "this", "abstract", "path", "name", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getfreespace <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "getfreespace"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getfreespace", "label": "API", "asoc": []}]}
{"text": "the java.io.file.getfreespace method returns the number of unallocated bytes in the partition named by this abstract path name", "tokens": ["the", "java.io.file.getfreespace", "method", "returns", "the", "number", "of", "unallocated", "bytes", "in", "the", "partition", "named", "by", "this", "abstract", "path", "name", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.io.file.getfreespace <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "java.io.file.getfreespace"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.io.file.getfreespace", "label": "API", "asoc": []}]}
{"text": "then again  ,  it's the same as newinstance with a cast added  ,  so i'm not sure that your method adds a lot of value", "tokens": ["then", "again", "", ",", "", "it's", "the", "same", "as", "newinstance", "with", "a", "cast", "added", "", ",", "", "so", "i'm", "not", "sure", "that", "your", "method", "adds", "a", "lot", "of", "value", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> newinstance <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "newinstance"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "newinstance", "label": "API", "asoc": []}]}
{"text": "so next always returns the value after the cursor  ,  and moves the cursor to the position after that", "tokens": ["so", "next", "always", "returns", "the", "value", "after", "the", "cursor", "", ",", "", "and", "moves", "the", "cursor", "to", "the", "position", "after", "that", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "next"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "next", "label": "API", "asoc": []}]}
{"text": "calling canread() will test if it is a readable file", "tokens": ["calling", "canread()", "will", "test", "if", "it", "is", "a", "readable", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> canread() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "canread()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "canread()", "label": "API", "asoc": []}]}
{"text": "calling canread will test if it is a readable file", "tokens": ["calling", "canread", "will", "test", "if", "it", "is", "a", "readable", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> canread <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "canread"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "canread", "label": "API", "asoc": []}]}
{"text": "calling file.canread will test if it is a readable file", "tokens": ["calling", "file.canread", "will", "test", "if", "it", "is", "a", "readable", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.canread <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.canread"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.canread", "label": "API", "asoc": []}]}
{"text": "no  ,  there are no guarantees that write will exhaust the whole buffer", "tokens": ["no", "", ",", "", "there", "are", "no", "guarantees", "that", "write", "will", "exhaust", "the", "whole", "buffer", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> write <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "write"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "write", "label": "API", "asoc": []}]}
{"text": "many rest clients expect a list when they invoke list method  .", "tokens": ["many", "rest", "clients", "expect", "a", "list", "when", "they", "invoke", "list", "method", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> list <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "list"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "list", "label": "API", "asoc": []}]}
{"text": "instead  ,  you need to declare map as a volatile and implement your refresh method as per your question", "tokens": ["instead", "", ",", "", "you", "need", "to", "declare", "map", "as", "a", "volatile", "and", "implement", "your", "refresh", "method", "as", "per", "your", "question", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> refresh <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "refresh"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "refresh", "label": "API", "asoc": []}]}
{"text": "add() should never throw an arrayindexoutofboundsexception if used \"properly\" so it seems that you're using your arraylist in a way which it does not support", "tokens": ["add()", "should", "never", "throw", "an", "arrayindexoutofboundsexception", "if", "used", "\"properly\"", "so", "it", "seems", "that", "you're", "using", "your", "arraylist", "in", "a", "way", "which", "it", "does", "not", "support", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> add() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "add()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "add()", "label": "API", "asoc": []}]}
{"text": "add should never throw an arrayindexoutofboundsexception if used \"properly\" so it seems that you're using your arraylist in a way which it does not support", "tokens": ["add", "should", "never", "throw", "an", "arrayindexoutofboundsexception", "if", "used", "\"properly\"", "so", "it", "seems", "that", "you're", "using", "your", "arraylist", "in", "a", "way", "which", "it", "does", "not", "support", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> add <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "add"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "add", "label": "API", "asoc": []}]}
{"text": "arraylist.add should never throw an arrayindexoutofboundsexception if used \"properly\" so it seems that you're using your arraylist in a way which it does not support", "tokens": ["arraylist.add", "should", "never", "throw", "an", "arrayindexoutofboundsexception", "if", "used", "\"properly\"", "so", "it", "seems", "that", "you're", "using", "your", "arraylist", "in", "a", "way", "which", "it", "does", "not", "support", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arraylist.add <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "arraylist.add"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arraylist.add", "label": "API", "asoc": []}]}
{"text": "prior to scaling by 6  ,  the output of random() is one of 2^53 possible values drawn from a uniform distribution", "tokens": ["prior", "to", "scaling", "by", "6", "", ",", "", "the", "output", "of", "random()", "is", "one", "of", "2^53", "possible", "values", "drawn", "from", "a", "uniform", "distribution", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> random() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "random()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "random()", "label": "API", "asoc": []}]}
{"text": "prior to scaling by 6  ,  the output of random is one of 2^53 possible values drawn from a uniform distribution", "tokens": ["prior", "to", "scaling", "by", "6", "", ",", "", "the", "output", "of", "random", "is", "one", "of", "2^53", "possible", "values", "drawn", "from", "a", "uniform", "distribution", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "random"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "random", "label": "API", "asoc": []}]}
{"text": "prior to scaling by 6  ,  the output of math.random is one of 2^53 possible values drawn from a uniform distribution", "tokens": ["prior", "to", "scaling", "by", "6", "", ",", "", "the", "output", "of", "math.random", "is", "one", "of", "2^53", "possible", "values", "drawn", "from", "a", "uniform", "distribution", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> math.random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "math.random"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "math.random", "label": "API", "asoc": []}]}
{"text": "just use getname() using string methods:", "tokens": ["just", "use", "getname()", "using", "string", "methods:", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getname() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "getname()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getname()", "label": "API", "asoc": []}]}
{"text": "just use getname using string methods:", "tokens": ["just", "use", "getname", "using", "string", "methods:", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getname <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "getname"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getname", "label": "API", "asoc": []}]}
{"text": "just use file.getname using string methods:", "tokens": ["just", "use", "file.getname", "using", "string", "methods:", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.getname <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "file.getname"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.getname", "label": "API", "asoc": []}]}
{"text": "and because of the backwards compatibility  ,  it is too late to change it.) in your first example the split function creates a string[] object", "tokens": ["and", "because", "of", "the", "backwards", "compatibility", "", ",", "", "it", "is", "too", "late", "to", "change", "it.)", "in", "your", "first", "example", "the", "split", "function", "creates", "a", "string[]", "object", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> split <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "split"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "split", "label": "API", "asoc": []}]}
{"text": "readline declares that it throws an ioexception", "tokens": ["readline", "declares", "that", "it", "throws", "an", "ioexception", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> readline <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "readline"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "readline", "label": "API", "asoc": []}]}
{"text": "in case the method is private use getdeclaredmethod instead of getmethod", "tokens": ["in", "case", "the", "method", "is", "private", "use", "getdeclaredmethod", "instead", "of", "getmethod", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getdeclaredmethod <extra_id_0> function replace <extra_id_5> getmethod <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> getmethod <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "getdeclaredmethod"}, {"type": "API", "offset": [10], "text": "getmethod"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [7], "text": "getdeclaredmethod"}, {"type": "API", "offset": [10], "text": "getmethod"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "getdeclaredmethod", "label": "API", "asoc": [["function replace", "getmethod"]]}, {"span": "getmethod", "label": "API", "asoc": []}]}
{"text": "moreover  ,  there is a pure java compatible implementation of array from gnu classpath", "tokens": ["moreover", "", ",", "", "there", "is", "a", "pure", "java", "compatible", "implementation", "of", "array", "from", "gnu", "classpath", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> array <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "array"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "array", "label": "API", "asoc": []}]}
{"text": "the get operation returns a task&lt;&gt; which means it is an asynchronous operation", "tokens": ["the", "get", "operation", "returns", "a", "task&lt;&gt;", "which", "means", "it", "is", "an", "asynchronous", "operation", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> get <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "get"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "get", "label": "API", "asoc": []}]}
{"text": "the standard oracle jdk 7 implementation uses what's called a linear congruential generator  to produce random values in random", "tokens": ["the", "standard", "oracle", "jdk", "7", "implementation", "uses", "what's", "called", "a", "linear", "congruential", "generator", "", "to", "produce", "random", "values", "in", "random", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "random"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "random", "label": "API", "asoc": []}]}
{"text": "if you just use getbytes() it will use the platform default", "tokens": ["if", "you", "just", "use", "getbytes()", "it", "will", "use", "the", "platform", "default", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getbytes() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "getbytes()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getbytes()", "label": "API", "asoc": []}]}
{"text": "if you just use getbytes it will use the platform default", "tokens": ["if", "you", "just", "use", "getbytes", "it", "will", "use", "the", "platform", "default", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getbytes <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "getbytes"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getbytes", "label": "API", "asoc": []}]}
{"text": "if you just use string.getbytes it will use the platform default", "tokens": ["if", "you", "just", "use", "string.getbytes", "it", "will", "use", "the", "platform", "default", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.getbytes <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "string.getbytes"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.getbytes", "label": "API", "asoc": []}]}
{"text": "the jvm actually specifically provides a mechanism for overriding classes in lang", "tokens": ["the", "jvm", "actually", "specifically", "provides", "a", "mechanism", "for", "overriding", "classes", "in", "lang", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> lang <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "lang"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "lang", "label": "API", "asoc": []}]}
{"text": "it is called peek (example from the javadoc):", "tokens": ["it", "is", "called", "peek", "(example", "from", "the", "javadoc):", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> peek <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "peek"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "peek", "label": "API", "asoc": []}]}
{"text": "commit is instantaneous but performs disk writes", "tokens": ["commit", "is", "instantaneous", "but", "performs", "disk", "writes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> commit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "commit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "commit", "label": "API", "asoc": []}]}
{"text": "calling interrupted will result in clearing the interrupt flag  ,  and makes no sense here  ,  especially since the return value is discarded", "tokens": ["calling", "interrupted", "will", "result", "in", "clearing", "the", "interrupt", "flag", "", ",", "", "and", "makes", "no", "sense", "here", "", ",", "", "especially", "since", "the", "return", "value", "is", "discarded", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> interrupted <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "interrupted"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "interrupted", "label": "API", "asoc": []}]}
{"text": "for more information visit this link you are most probably using keyevent  ,  which will not work with javafx events", "tokens": ["for", "more", "information", "visit", "this", "link", "you", "are", "most", "probably", "using", "keyevent", "", ",", "", "which", "will", "not", "work", "with", "javafx", "events", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> keyevent <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "keyevent"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "keyevent", "label": "API", "asoc": []}]}
{"text": "aslist() creates a fixed-size list that is directly backed by the varargs array parameter", "tokens": ["aslist()", "creates", "a", "fixed-size", "list", "that", "is", "directly", "backed", "by", "the", "varargs", "array", "parameter", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> aslist() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "aslist()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "aslist()", "label": "API", "asoc": []}]}
{"text": "aslist creates a fixed-size list that is directly backed by the varargs array parameter", "tokens": ["aslist", "creates", "a", "fixed-size", "list", "that", "is", "directly", "backed", "by", "the", "varargs", "array", "parameter", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> aslist <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "aslist"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "aslist", "label": "API", "asoc": []}]}
{"text": "arrays.aslist creates a fixed-size list that is directly backed by the varargs array parameter", "tokens": ["arrays.aslist", "creates", "a", "fixed-size", "list", "that", "is", "directly", "backed", "by", "the", "varargs", "array", "parameter", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.aslist <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "arrays.aslist"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.aslist", "label": "API", "asoc": []}]}
{"text": "that will result in hasnextline returning false", "tokens": ["that", "will", "result", "in", "hasnextline", "returning", "false", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hasnextline <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "hasnextline"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "hasnextline", "label": "API", "asoc": []}]}
{"text": "if the producer is currently already waiting on the lock  ,  calling notify will let it know that it can wake up and continue when the lock is released", "tokens": ["if", "the", "producer", "is", "currently", "already", "waiting", "on", "the", "lock", "", ",", "", "calling", "notify", "will", "let", "it", "know", "that", "it", "can", "wake", "up", "and", "continue", "when", "the", "lock", "is", "released", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> notify <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "notify"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "notify", "label": "API", "asoc": []}]}
{"text": "i don't see where your query is executed ( like executequery() ) but  ,  this kind of errors generally happens when your cursor is not well positioned", "tokens": ["i", "don't", "see", "where", "your", "query", "is", "executed", "(", "like", "executequery()", ")", "but", "", ",", "", "this", "kind", "of", "errors", "generally", "happens", "when", "your", "cursor", "is", "not", "well", "positioned", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> executequery() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "executequery()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "executequery()", "label": "API", "asoc": []}]}
{"text": "i don't see where your query is executed ( like executequery ) but  ,  this kind of errors generally happens when your cursor is not well positioned", "tokens": ["i", "don't", "see", "where", "your", "query", "is", "executed", "(", "like", "executequery", ")", "but", "", ",", "", "this", "kind", "of", "errors", "generally", "happens", "when", "your", "cursor", "is", "not", "well", "positioned", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> executequery <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "executequery"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "executequery", "label": "API", "asoc": []}]}
{"text": "i don't see where your query is executed ( like statement.executequery ) but  ,  this kind of errors generally happens when your cursor is not well positioned", "tokens": ["i", "don't", "see", "where", "your", "query", "is", "executed", "(", "like", "statement.executequery", ")", "but", "", ",", "", "this", "kind", "of", "errors", "generally", "happens", "when", "your", "cursor", "is", "not", "well", "positioned", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> statement.executequery <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "statement.executequery"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "statement.executequery", "label": "API", "asoc": []}]}
{"text": "type is a mess and unusable", "tokens": ["type", "is", "a", "mess", "and", "unusable", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> type <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "type"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "type", "label": "API", "asoc": []}]}
{"text": "as shown in dependentcolumn  ,  you can calculate derived values in your implementation of getvalueat", "tokens": ["as", "shown", "in", "dependentcolumn", "", ",", "", "you", "can", "calculate", "derived", "values", "in", "your", "implementation", "of", "getvalueat", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getvalueat <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "getvalueat"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getvalueat", "label": "API", "asoc": []}]}
{"text": "every object subclass has an android callable wrapper generated at build time", "tokens": ["every", "object", "subclass", "has", "an", "android", "callable", "wrapper", "generated", "at", "build", "time", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> object <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "object"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "object", "label": "API", "asoc": []}]}
{"text": "if you have java 8 available  ,  you can use function", "tokens": ["if", "you", "have", "java", "8", "available", "", ",", "", "you", "can", "use", "function", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> function <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "function"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "function", "label": "API", "asoc": []}]}
{"text": "as @hovercraft notes  ,  repaint alone is not sufficient to tell the chart's plot that you have replaced the dataset", "tokens": ["as", "@hovercraft", "notes", "", ",", "", "repaint", "alone", "is", "not", "sufficient", "to", "tell", "the", "chart's", "plot", "that", "you", "have", "replaced", "the", "dataset", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "repaint"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint", "label": "API", "asoc": []}]}
{"text": "as the build method returns a closeablehttpclient which is-a autoclosable  ,  you can place the declaration in a try-with-resources  statement", "tokens": ["as", "the", "build", "method", "returns", "a", "closeablehttpclient", "which", "is-a", "autoclosable", "", ",", "", "you", "can", "place", "the", "declaration", "in", "a", "try-with-resources", "", "statement", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> build <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "build"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "build", "label": "API", "asoc": []}]}
{"text": "well  ,  besides operating on different stuff  ,  sort operates on a list  ,  and sort operates on an array", "tokens": ["well", "", ",", "", "besides", "operating", "on", "different", "stuff", "", ",", "", "sort", "operates", "on", "a", "list", "", ",", "", "and", "sort", "operates", "on", "an", "array", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> sort <extra_id_0> behavior difference <extra_id_5> sort <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> sort <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "sort"}, {"type": "API", "offset": [12], "text": "sort"}], "relation": [{"type": "behavior difference", "args": [{"type": "API", "offset": [12], "text": "sort"}, {"type": "API", "offset": [12], "text": "sort"}]}], "event": [], "spot": ["API"], "asoc": ["behavior difference"], "spot_asoc": [{"span": "sort", "label": "API", "asoc": [["behavior difference", "sort"]]}, {"span": "sort", "label": "API", "asoc": []}]}
{"text": "if the producer is not waiting through a wait call  ,  it must be outside the method (possibly waiting to enter the method and acquire the lock that way)", "tokens": ["if", "the", "producer", "is", "not", "waiting", "through", "a", "wait", "call", "", ",", "", "it", "must", "be", "outside", "the", "method", "(possibly", "waiting", "to", "enter", "the", "method", "and", "acquire", "the", "lock", "that", "way)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "wait"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait", "label": "API", "asoc": []}]}
{"text": "the java documentation for pow states", "tokens": ["the", "java", "documentation", "for", "pow", "states", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pow <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "pow"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pow", "label": "API", "asoc": []}]}
{"text": "it is also worth noting that if the nextint call succeeded  ,  the scanner would be positioned immediately after the last character of the number", "tokens": ["it", "is", "also", "worth", "noting", "that", "if", "the", "nextint", "call", "succeeded", "", ",", "", "the", "scanner", "would", "be", "positioned", "immediately", "after", "the", "last", "character", "of", "the", "number", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "nextint"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nextint", "label": "API", "asoc": []}]}
{"text": "users are now asked to migrate to time (jsr-310)", "tokens": ["users", "are", "now", "asked", "to", "migrate", "to", "time", "(jsr-310)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "time", "label": "API", "asoc": []}]}
{"text": "java 8 and above starting from java 8 you can use optional", "tokens": ["java", "8", "and", "above", "starting", "from", "java", "8", "you", "can", "use", "optional", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> optional <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "optional"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "optional", "label": "API", "asoc": []}]}
{"text": "you will see that your setreuseaddress is being called too late i.e", "tokens": ["you", "will", "see", "that", "your", "setreuseaddress", "is", "being", "called", "too", "late", "i.e", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> setreuseaddress <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "setreuseaddress"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "setreuseaddress", "label": "API", "asoc": []}]}
{"text": "try println() on the runnable given to newthread in your example  .", "tokens": ["try", "println()", "on", "the", "runnable", "given", "to", "newthread", "in", "your", "example", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> println() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "println()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "println()", "label": "API", "asoc": []}]}
{"text": "try println on the runnable given to newthread in your example  .", "tokens": ["try", "println", "on", "the", "runnable", "given", "to", "newthread", "in", "your", "example", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> println <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "println"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "println", "label": "API", "asoc": []}]}
{"text": "try system.out.println on the runnable given to newthread in your example  .", "tokens": ["try", "system.out.println", "on", "the", "runnable", "given", "to", "newthread", "in", "your", "example", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.out.println <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "system.out.println"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.out.println", "label": "API", "asoc": []}]}
{"text": "i suggest using  the dateformat as shown in this page :", "tokens": ["i", "suggest", "using", "", "the", "dateformat", "as", "shown", "in", "this", "page", ":", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> dateformat <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "dateformat"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "dateformat", "label": "API", "asoc": []}]}
{"text": "the main loop ( in this case a timer )  ,  tells the component that it should update it's movement as required", "tokens": ["the", "main", "loop", "(", "in", "this", "case", "a", "timer", ")", "", ",", "", "tells", "the", "component", "that", "it", "should", "update", "it's", "movement", "as", "required", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "timer"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "timer", "label": "API", "asoc": []}]}
{"text": "public final class getclass is a public instance method declared 'final' in the object class and therefore if an interface tries to declare a method with this signature then the compilation will fail  .", "tokens": ["public", "final", "class", "getclass", "is", "a", "public", "instance", "method", "declared", "'final'", "in", "the", "object", "class", "and", "therefore", "if", "an", "interface", "tries", "to", "declare", "a", "method", "with", "this", "signature", "then", "the", "compilation", "will", "fail", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getclass <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "getclass"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getclass", "label": "API", "asoc": []}]}
{"text": "to parse your date you can use  but if that fails and you are seeing  parseexception", "tokens": ["to", "parse", "your", "date", "you", "can", "use", "", "but", "if", "that", "fails", "and", "you", "are", "seeing", "", "parseexception", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> parseexception <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "parseexception"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "parseexception", "label": "API", "asoc": []}]}
{"text": "if we assume that there is something more sophisticated going on  ,  not creating the same string in every iteration  ,  well  ,  then there is no benefit in calling intern", "tokens": ["if", "we", "assume", "that", "there", "is", "something", "more", "sophisticated", "going", "on", "", ",", "", "not", "creating", "the", "same", "string", "in", "every", "iteration", "", ",", "", "well", "", ",", "", "then", "there", "is", "no", "benefit", "in", "calling", "intern", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> intern <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [36], "text": "intern"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "intern", "label": "API", "asoc": []}]}
{"text": "by the time that you call dispose  ,  the observable is done  ,  and nothing will happen -- disposing a completed observable has no effect  .", "tokens": ["by", "the", "time", "that", "you", "call", "dispose", "", ",", "", "the", "observable", "is", "done", "", ",", "", "and", "nothing", "will", "happen", "--", "disposing", "a", "completed", "observable", "has", "no", "effect", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> dispose <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "dispose"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "dispose", "label": "API", "asoc": []}]}
{"text": "the codesource is available by getcodesource()", "tokens": ["the", "codesource", "is", "available", "by", "getcodesource()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcodesource() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "getcodesource()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcodesource()", "label": "API", "asoc": []}]}
{"text": "the codesource is available by getcodesource", "tokens": ["the", "codesource", "is", "available", "by", "getcodesource", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcodesource <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "getcodesource"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcodesource", "label": "API", "asoc": []}]}
{"text": "the codesource is available by protectiondomain.getcodesource", "tokens": ["the", "codesource", "is", "available", "by", "protectiondomain.getcodesource", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> protectiondomain.getcodesource <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "protectiondomain.getcodesource"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "protectiondomain.getcodesource", "label": "API", "asoc": []}]}
{"text": "by default all classes inherit object", "tokens": ["by", "default", "all", "classes", "inherit", "object", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> object <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "object"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "object", "label": "API", "asoc": []}]}
{"text": "a task queued with execute that generates some throwable will cause the uncaughtexceptionhandler for the thread running the task to be invoked", "tokens": ["a", "task", "queued", "with", "execute", "that", "generates", "some", "throwable", "will", "cause", "the", "uncaughtexceptionhandler", "for", "the", "thread", "running", "the", "task", "to", "be", "invoked", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> execute <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "execute"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "execute", "label": "API", "asoc": []}]}
{"text": "edit: note that delete can be done to any element  ,  and not only the head  ,  however", "tokens": ["edit:", "note", "that", "delete", "can", "be", "done", "to", "any", "element", "", ",", "", "and", "not", "only", "the", "head", "", ",", "", "however", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> delete <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "delete"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "delete", "label": "API", "asoc": []}]}
{"text": "that format is specified in the tostring()", "tokens": ["that", "format", "is", "specified", "in", "the", "tostring()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "that format is specified in the tostring", "tokens": ["that", "format", "is", "specified", "in", "the", "tostring", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "tostring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring", "label": "API", "asoc": []}]}
{"text": "that format is specified in the date.tostring", "tokens": ["that", "format", "is", "specified", "in", "the", "date.tostring", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> date.tostring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "date.tostring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "date.tostring", "label": "API", "asoc": []}]}
{"text": "the problem is almost certainly because the array returned by array() is the full backing array  ,  but the data may only be contained within a portion of it", "tokens": ["the", "problem", "is", "almost", "certainly", "because", "the", "array", "returned", "by", "array()", "is", "the", "full", "backing", "array", "", ",", "", "but", "the", "data", "may", "only", "be", "contained", "within", "a", "portion", "of", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> array() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "array()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "array()", "label": "API", "asoc": []}]}
{"text": "the problem is almost certainly because the array returned by array is the full backing array  ,  but the data may only be contained within a portion of it", "tokens": ["the", "problem", "is", "almost", "certainly", "because", "the", "array", "returned", "by", "array", "is", "the", "full", "backing", "array", "", ",", "", "but", "the", "data", "may", "only", "be", "contained", "within", "a", "portion", "of", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> array <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "array"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "array", "label": "API", "asoc": []}]}
{"text": "the problem is almost certainly because the array returned by bytebuffer.array is the full backing array  ,  but the data may only be contained within a portion of it", "tokens": ["the", "problem", "is", "almost", "certainly", "because", "the", "array", "returned", "by", "bytebuffer.array", "is", "the", "full", "backing", "array", "", ",", "", "but", "the", "data", "may", "only", "be", "contained", "within", "a", "portion", "of", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> bytebuffer.array <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "bytebuffer.array"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "bytebuffer.array", "label": "API", "asoc": []}]}
{"text": "it does have nanotime()  ,  but that just gives an offset from some previously known time", "tokens": ["it", "does", "have", "nanotime()", "", ",", "", "but", "that", "just", "gives", "an", "offset", "from", "some", "previously", "known", "time", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nanotime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "nanotime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nanotime()", "label": "API", "asoc": []}]}
{"text": "it does have nanotime  ,  but that just gives an offset from some previously known time", "tokens": ["it", "does", "have", "nanotime", "", ",", "", "but", "that", "just", "gives", "an", "offset", "from", "some", "previously", "known", "time", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nanotime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "nanotime"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nanotime", "label": "API", "asoc": []}]}
{"text": "it does have system.nanotime  ,  but that just gives an offset from some previously known time", "tokens": ["it", "does", "have", "system.nanotime", "", ",", "", "but", "that", "just", "gives", "an", "offset", "from", "some", "previously", "known", "time", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.nanotime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "system.nanotime"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.nanotime", "label": "API", "asoc": []}]}
{"text": "to the point  ,  you need to scan the entire classpath (and subfolders) for classes implementing driver", "tokens": ["to", "the", "point", "", ",", "", "you", "need", "to", "scan", "the", "entire", "classpath", "(and", "subfolders)", "for", "classes", "implementing", "driver", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> driver <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "driver"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "driver", "label": "API", "asoc": []}]}
{"text": "you can try using arraycopy() but  ,  probably better to use clone in most cases:", "tokens": ["you", "can", "try", "using", "arraycopy()", "but", "", ",", "", "probably", "better", "to", "use", "clone", "in", "most", "cases:", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arraycopy() <extra_id_0> efficiency comparison <extra_id_5> clone <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> clone <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "arraycopy()"}, {"type": "API", "offset": [13], "text": "clone"}], "relation": [{"type": "efficiency comparison", "args": [{"type": "API", "offset": [4], "text": "arraycopy()"}, {"type": "API", "offset": [13], "text": "clone"}]}], "event": [], "spot": ["API"], "asoc": ["efficiency comparison"], "spot_asoc": [{"span": "arraycopy()", "label": "API", "asoc": [["efficiency comparison", "clone"]]}, {"span": "clone", "label": "API", "asoc": []}]}
{"text": "you can try using arraycopy but  ,  probably better to use clone in most cases:", "tokens": ["you", "can", "try", "using", "arraycopy", "but", "", ",", "", "probably", "better", "to", "use", "clone", "in", "most", "cases:", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arraycopy <extra_id_0> efficiency comparison <extra_id_5> clone <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> clone <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "arraycopy"}, {"type": "API", "offset": [13], "text": "clone"}], "relation": [{"type": "efficiency comparison", "args": [{"type": "API", "offset": [4], "text": "arraycopy"}, {"type": "API", "offset": [13], "text": "clone"}]}], "event": [], "spot": ["API"], "asoc": ["efficiency comparison"], "spot_asoc": [{"span": "arraycopy", "label": "API", "asoc": [["efficiency comparison", "clone"]]}, {"span": "clone", "label": "API", "asoc": []}]}
{"text": "you can try using system.arraycopy but  ,  probably better to use clone in most cases:", "tokens": ["you", "can", "try", "using", "system.arraycopy", "but", "", ",", "", "probably", "better", "to", "use", "clone", "in", "most", "cases:", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.arraycopy <extra_id_0> efficiency comparison <extra_id_5> clone <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> clone <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.arraycopy"}, {"type": "API", "offset": [13], "text": "clone"}], "relation": [{"type": "efficiency comparison", "args": [{"type": "API", "offset": [4], "text": "system.arraycopy"}, {"type": "API", "offset": [13], "text": "clone"}]}], "event": [], "spot": ["API"], "asoc": ["efficiency comparison"], "spot_asoc": [{"span": "system.arraycopy", "label": "API", "asoc": [["efficiency comparison", "clone"]]}, {"span": "clone", "label": "API", "asoc": []}]}
{"text": "even if the start() is the last statement in your constructor  ,  the new thread may be accessing a partially constructed object because of the reordering", "tokens": ["even", "if", "the", "start()", "is", "the", "last", "statement", "in", "your", "constructor", "", ",", "", "the", "new", "thread", "may", "be", "accessing", "a", "partially", "constructed", "object", "because", "of", "the", "reordering", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> start() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "start()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "start()", "label": "API", "asoc": []}]}
{"text": "even if the start is the last statement in your constructor  ,  the new thread may be accessing a partially constructed object because of the reordering", "tokens": ["even", "if", "the", "start", "is", "the", "last", "statement", "in", "your", "constructor", "", ",", "", "the", "new", "thread", "may", "be", "accessing", "a", "partially", "constructed", "object", "because", "of", "the", "reordering", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> start <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "start"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "start", "label": "API", "asoc": []}]}
{"text": "even if the thread.start is the last statement in your constructor  ,  the new thread may be accessing a partially constructed object because of the reordering", "tokens": ["even", "if", "the", "thread.start", "is", "the", "last", "statement", "in", "your", "constructor", "", ",", "", "the", "new", "thread", "may", "be", "accessing", "a", "partially", "constructed", "object", "because", "of", "the", "reordering", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.start <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "thread.start"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.start", "label": "API", "asoc": []}]}
{"text": "here is an example  ,  this prints class comes from getclass inherited from object edit: to get the getter or setter and its name  .", "tokens": ["here", "is", "an", "example", "", ",", "", "this", "prints", "class", "comes", "from", "getclass", "inherited", "from", "object", "edit:", "to", "get", "the", "getter", "or", "setter", "and", "its", "name", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getclass <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "getclass"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getclass", "label": "API", "asoc": []}]}
{"text": "also  ,  use revalidate and repaint to encourage the container to update it's layout when adding new components recommendations", "tokens": ["also", "", ",", "", "use", "revalidate", "and", "repaint", "to", "encourage", "the", "container", "to", "update", "it's", "layout", "when", "adding", "new", "components", "recommendations", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> revalidate <extra_id_0> function collaboration <extra_id_5> repaint <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> repaint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "revalidate"}, {"type": "API", "offset": [7], "text": "repaint"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [5], "text": "revalidate"}, {"type": "API", "offset": [7], "text": "repaint"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "revalidate", "label": "API", "asoc": [["function collaboration", "repaint"]]}, {"span": "repaint", "label": "API", "asoc": []}]}
{"text": "another feasible way is using socket", "tokens": ["another", "feasible", "way", "is", "using", "socket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> socket <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "socket"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "socket", "label": "API", "asoc": []}]}
{"text": "the new nextint() generates a random positive number", "tokens": ["the", "new", "nextint()", "generates", "a", "random", "positive", "number", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "nextint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nextint()", "label": "API", "asoc": []}]}
{"text": "the new nextint generates a random positive number", "tokens": ["the", "new", "nextint", "generates", "a", "random", "positive", "number", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "nextint"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nextint", "label": "API", "asoc": []}]}
{"text": "the new random.nextint generates a random positive number", "tokens": ["the", "new", "random.nextint", "generates", "a", "random", "positive", "number", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> random.nextint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "random.nextint"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "random.nextint", "label": "API", "asoc": []}]}
{"text": "calling run will execute run method in the same thread  ,  without starting new thread  .", "tokens": ["calling", "run", "will", "execute", "run", "method", "in", "the", "same", "thread", "", ",", "", "without", "starting", "new", "thread", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> run <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "run"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "run", "label": "API", "asoc": []}]}
{"text": "check the api for suitable types; a string should be acceptable", "tokens": ["check", "the", "api", "for", "suitable", "types;", "a", "string", "should", "be", "acceptable", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string", "label": "API", "asoc": []}]}
{"text": "now look at implementation of start() : because threadstatus has not been stored/restored properly you can start a second time", "tokens": ["now", "look", "at", "implementation", "of", "start()", ":", "because", "threadstatus", "has", "not", "been", "stored/restored", "properly", "you", "can", "start", "a", "second", "time", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> start() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "start()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "start()", "label": "API", "asoc": []}]}
{"text": "now look at implementation of start : because threadstatus has not been stored/restored properly you can start a second time", "tokens": ["now", "look", "at", "implementation", "of", "start", ":", "because", "threadstatus", "has", "not", "been", "stored/restored", "properly", "you", "can", "start", "a", "second", "time", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> start <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "start"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "start", "label": "API", "asoc": []}]}
{"text": "now look at implementation of thread.start : because threadstatus has not been stored/restored properly you can start a second time", "tokens": ["now", "look", "at", "implementation", "of", "thread.start", ":", "because", "threadstatus", "has", "not", "been", "stored/restored", "properly", "you", "can", "start", "a", "second", "time", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.start <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "thread.start"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.start", "label": "API", "asoc": []}]}
{"text": "now  ,  you are at the mercy of the output stream and how often the writing portion of your program calls flush so there may be a delay", "tokens": ["now", "", ",", "", "you", "are", "at", "the", "mercy", "of", "the", "output", "stream", "and", "how", "often", "the", "writing", "portion", "of", "your", "program", "calls", "flush", "so", "there", "may", "be", "a", "delay", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> flush <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "flush"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "flush", "label": "API", "asoc": []}]}
{"text": "let's further assume that equals is implemented correctly on this object  ,  that is  ,  that it checks all of these fields correctly", "tokens": ["let's", "further", "assume", "that", "equals", "is", "implemented", "correctly", "on", "this", "object", "", ",", "", "that", "is", "", ",", "", "that", "it", "checks", "all", "of", "these", "fields", "correctly", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "equals"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "equals", "label": "API", "asoc": []}]}
{"text": "in java 1.4 and earlier they used object as the type for any object added to the collection", "tokens": ["in", "java", "1.4", "and", "earlier", "they", "used", "object", "as", "the", "type", "for", "any", "object", "added", "to", "the", "collection", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> object <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "object"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "object", "label": "API", "asoc": []}]}
{"text": "you need to check whether string is not empty before using parseint function", "tokens": ["you", "need", "to", "check", "whether", "string", "is", "not", "empty", "before", "using", "parseint", "function", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> parseint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "parseint"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "parseint", "label": "API", "asoc": []}]}
{"text": "use file's getparentfile method and lastindexof() to retrieve just the immediate parent directory", "tokens": ["use", "file's", "getparentfile", "method", "and", "lastindexof()", "to", "retrieve", "just", "the", "immediate", "parent", "directory", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getparentfile <extra_id_0> function collaboration <extra_id_5> lastindexof() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> lastindexof() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "getparentfile"}, {"type": "API", "offset": [5], "text": "lastindexof()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [2], "text": "getparentfile"}, {"type": "API", "offset": [5], "text": "lastindexof()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "getparentfile", "label": "API", "asoc": [["function collaboration", "lastindexof()"]]}, {"span": "lastindexof()", "label": "API", "asoc": []}]}
{"text": "use file's getparentfile method and lastindexof to retrieve just the immediate parent directory", "tokens": ["use", "file's", "getparentfile", "method", "and", "lastindexof", "to", "retrieve", "just", "the", "immediate", "parent", "directory", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getparentfile <extra_id_0> function collaboration <extra_id_5> lastindexof <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> lastindexof <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "getparentfile"}, {"type": "API", "offset": [5], "text": "lastindexof"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [2], "text": "getparentfile"}, {"type": "API", "offset": [5], "text": "lastindexof"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "getparentfile", "label": "API", "asoc": [["function collaboration", "lastindexof"]]}, {"span": "lastindexof", "label": "API", "asoc": []}]}
{"text": "use file's getparentfile method and string.lastindexof to retrieve just the immediate parent directory", "tokens": ["use", "file's", "getparentfile", "method", "and", "string.lastindexof", "to", "retrieve", "just", "the", "immediate", "parent", "directory", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getparentfile <extra_id_0> function collaboration <extra_id_5> string.lastindexof <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> string.lastindexof <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "getparentfile"}, {"type": "API", "offset": [5], "text": "string.lastindexof"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [2], "text": "getparentfile"}, {"type": "API", "offset": [5], "text": "string.lastindexof"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "getparentfile", "label": "API", "asoc": [["function collaboration", "string.lastindexof"]]}, {"span": "string.lastindexof", "label": "API", "asoc": []}]}
{"text": "2018-12-31t23:37z use the modern time classes  ,  not those terrible legacy classes such as date", "tokens": ["2018-12-31t23:37z", "use", "the", "modern", "time", "classes", "", ",", "", "not", "those", "terrible", "legacy", "classes", "such", "as", "date", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "time", "label": "API", "asoc": []}]}
{"text": "using filechannel : java nio classes were introduced in java 1.4 and filechannel can be used to copy file in java", "tokens": ["using", "filechannel", ":", "java", "nio", "classes", "were", "introduced", "in", "java", "1.4", "and", "filechannel", "can", "be", "used", "to", "copy", "file", "in", "java", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> filechannel <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "filechannel"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "filechannel", "label": "API", "asoc": []}]}
{"text": "you're calling valueof to store the icon in your database", "tokens": ["you're", "calling", "valueof", "to", "store", "the", "icon", "in", "your", "database", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> valueof <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "valueof"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "valueof", "label": "API", "asoc": []}]}
{"text": "if you're using java 8 try using the new time api which uses immutable objects", "tokens": ["if", "you're", "using", "java", "8", "try", "using", "the", "new", "time", "api", "which", "uses", "immutable", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "time", "label": "API", "asoc": []}]}
{"text": "if you have a specific jar file and you know the path within that jar file then you could simply treat that file as archive and access it via jarfile which lets you list all entries in the file", "tokens": ["if", "you", "have", "a", "specific", "jar", "file", "and", "you", "know", "the", "path", "within", "that", "jar", "file", "then", "you", "could", "simply", "treat", "that", "file", "as", "archive", "and", "access", "it", "via", "jarfile", "which", "lets", "you", "list", "all", "entries", "in", "the", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> jarfile <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [29], "text": "jarfile"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "jarfile", "label": "API", "asoc": []}]}
{"text": "especially once they start to get their own methods like getname  ,  getid  ,  etc .  .", "tokens": ["especially", "once", "they", "start", "to", "get", "their", "own", "methods", "like", "getname", "", ",", "", "getid", "", ",", "", "etc", ".", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getname <extra_id_0> function similarity <extra_id_5> getid <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> getid <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getname"}, {"type": "API", "offset": [14], "text": "getid"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [10], "text": "getname"}, {"type": "API", "offset": [14], "text": "getid"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "getname", "label": "API", "asoc": [["function similarity", "getid"]]}, {"span": "getid", "label": "API", "asoc": []}]}
{"text": "all you need to do is use substring", "tokens": ["all", "you", "need", "to", "do", "is", "use", "substring", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> substring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "substring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "substring", "label": "API", "asoc": []}]}
{"text": "secondary  ,  you mention calling add multiple times .  .", "tokens": ["secondary", "", ",", "", "you", "mention", "calling", "add", "multiple", "times", ".", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> add <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "add"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "add", "label": "API", "asoc": []}]}
{"text": "you can do this through runonuithread()", "tokens": ["you", "can", "do", "this", "through", "runonuithread()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> runonuithread() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "runonuithread()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "runonuithread()", "label": "API", "asoc": []}]}
{"text": "you can do this through runonuithread", "tokens": ["you", "can", "do", "this", "through", "runonuithread", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> runonuithread <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "runonuithread"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "runonuithread", "label": "API", "asoc": []}]}
{"text": "you can do this through getactivity.runonuithread", "tokens": ["you", "can", "do", "this", "through", "getactivity.runonuithread", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getactivity.runonuithread <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "getactivity.runonuithread"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getactivity.runonuithread", "label": "API", "asoc": []}]}
{"text": "from the javadoc for reset brokenbarrierexception so reset causes any currently waiting threads to throw a brokenbarrierexception and wake immediately", "tokens": ["from", "the", "javadoc", "for", "reset", "brokenbarrierexception", "so", "reset", "causes", "any", "currently", "waiting", "threads", "to", "throw", "a", "brokenbarrierexception", "and", "wake", "immediately", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> reset <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "reset"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "reset", "label": "API", "asoc": []}]}
{"text": "basically  ,  you shouldn't use tostring() for anything other than debugging", "tokens": ["basically", "", ",", "", "you", "shouldn't", "use", "tostring()", "for", "anything", "other", "than", "debugging", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "basically  ,  you shouldn't use tostring for anything other than debugging", "tokens": ["basically", "", ",", "", "you", "shouldn't", "use", "tostring", "for", "anything", "other", "than", "debugging", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "tostring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring", "label": "API", "asoc": []}]}
{"text": "basically  ,  you shouldn't use date.tostring for anything other than debugging", "tokens": ["basically", "", ",", "", "you", "shouldn't", "use", "date.tostring", "for", "anything", "other", "than", "debugging", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> date.tostring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "date.tostring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "date.tostring", "label": "API", "asoc": []}]}
{"text": "setdate takes a date  ,  not a date", "tokens": ["setdate", "takes", "a", "date", "", ",", "", "not", "a", "date", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> date <extra_id_0> function replace <extra_id_5> date <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> date <extra_id_1> <extra_id_0> API <extra_id_5> setdate <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "date"}, {"type": "API", "offset": [3], "text": "date"}, {"type": "API", "offset": [0], "text": "setdate"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [3], "text": "date"}, {"type": "API", "offset": [3], "text": "date"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "date", "label": "API", "asoc": [["function replace", "date"]]}, {"span": "date", "label": "API", "asoc": []}, {"span": "setdate", "label": "API", "asoc": []}]}
{"text": "your java file is missing an import statement for list  ,  which is why it's failing to compile", "tokens": ["your", "java", "file", "is", "missing", "an", "import", "statement", "for", "list", "", ",", "", "which", "is", "why", "it's", "failing", "to", "compile", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> list <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "list"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "list", "label": "API", "asoc": []}]}
{"text": "you can call get on a future as often as you like  ,  and it will only block if the task that produces the result has not finished yet", "tokens": ["you", "can", "call", "get", "on", "a", "future", "as", "often", "as", "you", "like", "", ",", "", "and", "it", "will", "only", "block", "if", "the", "task", "that", "produces", "the", "result", "has", "not", "finished", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> get <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "get"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "get", "label": "API", "asoc": []}]}
{"text": "it feels ugly to write it as a string and call getbytes  ,  but perhaps you can look into this", "tokens": ["it", "feels", "ugly", "to", "write", "it", "as", "a", "string", "and", "call", "getbytes", "", ",", "", "but", "perhaps", "you", "can", "look", "into", "this", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getbytes <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "getbytes"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getbytes", "label": "API", "asoc": []}]}
{"text": "sort returns void not int[] type", "tokens": ["sort", "returns", "void", "not", "int[]", "type", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> sort <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "sort"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "sort", "label": "API", "asoc": []}]}
{"text": "from the tostring docs: tostring the tostring method for class object example:", "tokens": ["from", "the", "tostring", "docs:", "tostring", "the", "tostring", "method", "for", "class", "object", "example:", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "tostring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring", "label": "API", "asoc": []}]}
{"text": "yes  ,  after calling flush  ,  the dbms is now aware of your data - but following acid standards  ,  no other database sessions will see this data until the dbms is told to commit it", "tokens": ["yes", "", ",", "", "after", "calling", "flush", "", ",", "", "the", "dbms", "is", "now", "aware", "of", "your", "data", "-", "but", "following", "acid", "standards", "", ",", "", "no", "other", "database", "sessions", "will", "see", "this", "data", "until", "the", "dbms", "is", "told", "to", "commit", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> flush <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "flush"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "flush", "label": "API", "asoc": []}]}
{"text": "through the use of a single timer  ,  you could iterate through the balls list and update there positions", "tokens": ["through", "the", "use", "of", "a", "single", "timer", "", ",", "", "you", "could", "iterate", "through", "the", "balls", "list", "and", "update", "there", "positions", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "timer"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "timer", "label": "API", "asoc": []}]}
{"text": "then you can see that you program will sit in wait forever  .", "tokens": ["then", "you", "can", "see", "that", "you", "program", "will", "sit", "in", "wait", "forever", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "wait"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait", "label": "API", "asoc": []}]}
{"text": "calling isdirectory() will test if it is a directory", "tokens": ["calling", "isdirectory()", "will", "test", "if", "it", "is", "a", "directory", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> isdirectory() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "isdirectory()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "isdirectory()", "label": "API", "asoc": []}]}
{"text": "calling isdirectory will test if it is a directory", "tokens": ["calling", "isdirectory", "will", "test", "if", "it", "is", "a", "directory", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> isdirectory <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "isdirectory"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "isdirectory", "label": "API", "asoc": []}]}
{"text": "calling file.isdirectory will test if it is a directory", "tokens": ["calling", "file.isdirectory", "will", "test", "if", "it", "is", "a", "directory", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.isdirectory <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.isdirectory"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.isdirectory", "label": "API", "asoc": []}]}
{"text": "the fxmlloader has a getcontroller method that allows you to retrieve a reference to the controller", "tokens": ["the", "fxmlloader", "has", "a", "getcontroller", "method", "that", "allows", "you", "to", "retrieve", "a", "reference", "to", "the", "controller", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontroller <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "getcontroller"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontroller", "label": "API", "asoc": []}]}
{"text": "however  ,  you're not displaying it in utc  ,  because of the way tostring() works (it always uses the system local time zone)", "tokens": ["however", "", ",", "", "you're", "not", "displaying", "it", "in", "utc", "", ",", "", "because", "of", "the", "way", "tostring()", "works", "(it", "always", "uses", "the", "system", "local", "time", "zone)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "however  ,  you're not displaying it in utc  ,  because of the way tostring works (it always uses the system local time zone)", "tokens": ["however", "", ",", "", "you're", "not", "displaying", "it", "in", "utc", "", ",", "", "because", "of", "the", "way", "tostring", "works", "(it", "always", "uses", "the", "system", "local", "time", "zone)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "tostring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring", "label": "API", "asoc": []}]}
{"text": "however  ,  you're not displaying it in utc  ,  because of the way date.tostring works (it always uses the system local time zone)", "tokens": ["however", "", ",", "", "you're", "not", "displaying", "it", "in", "utc", "", ",", "", "because", "of", "the", "way", "date.tostring", "works", "(it", "always", "uses", "the", "system", "local", "time", "zone)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> date.tostring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "date.tostring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "date.tostring", "label": "API", "asoc": []}]}
{"text": "although new scanner works  ,  you could rather pass the file name directly into the scanner's constructor  .", "tokens": ["although", "new", "scanner", "works", "", ",", "", "you", "could", "rather", "pass", "the", "file", "name", "directly", "into", "the", "scanner's", "constructor", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> scanner <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "scanner"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "scanner", "label": "API", "asoc": []}]}
{"text": "nevertheless  ,  even identityhashcode() can return the same hash for multiple objects", "tokens": ["nevertheless", "", ",", "", "even", "identityhashcode()", "can", "return", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless  ,  even identityhashcode can return the same hash for multiple objects", "tokens": ["nevertheless", "", ",", "", "even", "identityhashcode", "can", "return", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> identityhashcode <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "identityhashcode"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "identityhashcode", "label": "API", "asoc": []}]}
{"text": "nevertheless  ,  even system.identityhashcode can return the same hash for multiple objects", "tokens": ["nevertheless", "", ",", "", "even", "system.identityhashcode", "can", "return", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "system.identityhashcode"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode", "label": "API", "asoc": []}]}
{"text": "flip sets the limit (length) of the buffer to the current position and then the position is set to zero", "tokens": ["flip", "sets", "the", "limit", "(length)", "of", "the", "buffer", "to", "the", "current", "position", "and", "then", "the", "position", "is", "set", "to", "zero", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> flip <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "flip"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "flip", "label": "API", "asoc": []}]}
{"text": "that sets the isinterrupted() to true and causes wait()  ,  sleep()  ,  and a couple other methods to throw interruptedexception", "tokens": ["that", "sets", "the", "isinterrupted()", "to", "true", "and", "causes", "wait()", "", ",", "", "sleep()", "", ",", "", "and", "a", "couple", "other", "methods", "to", "throw", "interruptedexception", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> isinterrupted() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "isinterrupted()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "isinterrupted()", "label": "API", "asoc": []}]}
{"text": "that sets the isinterrupted to true and causes wait()  ,  sleep()  ,  and a couple other methods to throw interruptedexception", "tokens": ["that", "sets", "the", "isinterrupted", "to", "true", "and", "causes", "wait()", "", ",", "", "sleep()", "", ",", "", "and", "a", "couple", "other", "methods", "to", "throw", "interruptedexception", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> isinterrupted <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "isinterrupted"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "isinterrupted", "label": "API", "asoc": []}]}
{"text": "that sets the thread.isinterrupted to true and causes wait()  ,  sleep()  ,  and a couple other methods to throw interruptedexception", "tokens": ["that", "sets", "the", "thread.isinterrupted", "to", "true", "and", "causes", "wait()", "", ",", "", "sleep()", "", ",", "", "and", "a", "couple", "other", "methods", "to", "throw", "interruptedexception", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.isinterrupted <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "thread.isinterrupted"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.isinterrupted", "label": "API", "asoc": []}]}
{"text": "you are ignoring the result of connect  ,  which if true means that op_connect will never fire  ,  because the channel is already connected", "tokens": ["you", "are", "ignoring", "the", "result", "of", "connect", "", ",", "", "which", "if", "true", "means", "that", "op_connect", "will", "never", "fire", "", ",", "", "because", "the", "channel", "is", "already", "connected", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> connect <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "connect"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "connect", "label": "API", "asoc": []}]}
{"text": "you should never call sleep() on the edt", "tokens": ["you", "should", "never", "call", "sleep()", "on", "the", "edt", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> sleep() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "sleep()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "sleep()", "label": "API", "asoc": []}]}
{"text": "you should never call sleep on the edt", "tokens": ["you", "should", "never", "call", "sleep", "on", "the", "edt", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> sleep <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "sleep"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "sleep", "label": "API", "asoc": []}]}
{"text": "you should never call thread.sleep on the edt", "tokens": ["you", "should", "never", "call", "thread.sleep", "on", "the", "edt", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "thread.sleep"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep", "label": "API", "asoc": []}]}
{"text": "instead of timer  ,  timer may be more convenient  ,  as seen in this example  .", "tokens": ["instead", "of", "timer", "", ",", "", "timer", "may", "be", "more", "convenient", "", ",", "", "as", "seen", "in", "this", "example", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timer <extra_id_0> efficiency comparison <extra_id_5> timer <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> timer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "timer"}, {"type": "API", "offset": [2], "text": "timer"}], "relation": [{"type": "efficiency comparison", "args": [{"type": "API", "offset": [2], "text": "timer"}, {"type": "API", "offset": [2], "text": "timer"}]}], "event": [], "spot": ["API"], "asoc": ["efficiency comparison"], "spot_asoc": [{"span": "timer", "label": "API", "asoc": [["efficiency comparison", "timer"]]}, {"span": "timer", "label": "API", "asoc": []}]}
{"text": "it looks to me like this workaround is required because of a possible bug in scrollpanelayout", "tokens": ["it", "looks", "to", "me", "like", "this", "workaround", "is", "required", "because", "of", "a", "possible", "bug", "in", "scrollpanelayout", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> scrollpanelayout <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "scrollpanelayout"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "scrollpanelayout", "label": "API", "asoc": []}]}
{"text": "uuid uses securerandom  ,  which is supposed to be \"cryptographically strong\"", "tokens": ["uuid", "uses", "securerandom", "", ",", "", "which", "is", "supposed", "to", "be", "\"cryptographically", "strong\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> securerandom <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "securerandom"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "securerandom", "label": "API", "asoc": []}]}
{"text": "this methods required an object of type driver", "tokens": ["this", "methods", "required", "an", "object", "of", "type", "driver", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> driver <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "driver"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "driver", "label": "API", "asoc": []}]}
{"text": "unless you add scanforplugins() somewhere in your code  ,  the plugins might never be available at all", "tokens": ["unless", "you", "add", "scanforplugins()", "somewhere", "in", "your", "code", "", ",", "", "the", "plugins", "might", "never", "be", "available", "at", "all", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> scanforplugins() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "scanforplugins()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "scanforplugins()", "label": "API", "asoc": []}]}
{"text": "unless you add scanforplugins somewhere in your code  ,  the plugins might never be available at all", "tokens": ["unless", "you", "add", "scanforplugins", "somewhere", "in", "your", "code", "", ",", "", "the", "plugins", "might", "never", "be", "available", "at", "all", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> scanforplugins <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "scanforplugins"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "scanforplugins", "label": "API", "asoc": []}]}
{"text": "unless you add imageio.scanforplugins somewhere in your code  ,  the plugins might never be available at all", "tokens": ["unless", "you", "add", "imageio.scanforplugins", "somewhere", "in", "your", "code", "", ",", "", "the", "plugins", "might", "never", "be", "available", "at", "all", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> imageio.scanforplugins <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "imageio.scanforplugins"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "imageio.scanforplugins", "label": "API", "asoc": []}]}
{"text": "(...) locale for the current request locale  ,  determined by the most specific locale resolver available  ,  in effect  ,  the configured localeresolver in a servlet environment", "tokens": ["(...)", "locale", "for", "the", "current", "request", "locale", "", ",", "", "determined", "by", "the", "most", "specific", "locale", "resolver", "available", "", ",", "", "in", "effect", "", ",", "", "the", "configured", "localeresolver", "in", "a", "servlet", "environment", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> locale <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "locale"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "locale", "label": "API", "asoc": []}]}
{"text": "use shuffle() : it enables you to get n unique elements by an incremented index (assuming that the list itself contains unique elements)", "tokens": ["use", "shuffle()", ":", "it", "enables", "you", "to", "get", "n", "unique", "elements", "by", "an", "incremented", "index", "(assuming", "that", "the", "list", "itself", "contains", "unique", "elements)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> shuffle() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "shuffle()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "shuffle()", "label": "API", "asoc": []}]}
{"text": "use shuffle : it enables you to get n unique elements by an incremented index (assuming that the list itself contains unique elements)", "tokens": ["use", "shuffle", ":", "it", "enables", "you", "to", "get", "n", "unique", "elements", "by", "an", "incremented", "index", "(assuming", "that", "the", "list", "itself", "contains", "unique", "elements)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> shuffle <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "shuffle"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "shuffle", "label": "API", "asoc": []}]}
{"text": "use collections.shuffle : it enables you to get n unique elements by an incremented index (assuming that the list itself contains unique elements)", "tokens": ["use", "collections.shuffle", ":", "it", "enables", "you", "to", "get", "n", "unique", "elements", "by", "an", "incremented", "index", "(assuming", "that", "the", "list", "itself", "contains", "unique", "elements)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> collections.shuffle <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "collections.shuffle"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "collections.shuffle", "label": "API", "asoc": []}]}
{"text": "your snippet is incorrectly synchronized; you should update your dataset from the process method of a swingworker  ,  as shown here", "tokens": ["your", "snippet", "is", "incorrectly", "synchronized;", "you", "should", "update", "your", "dataset", "from", "the", "process", "method", "of", "a", "swingworker", "", ",", "", "as", "shown", "here", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> process <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "process"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "process", "label": "API", "asoc": []}]}
{"text": "with this rule you are able to test code  ,  that calls exit() : system rules needs at least junit 4.9", "tokens": ["with", "this", "rule", "you", "are", "able", "to", "test", "code", "", ",", "", "that", "calls", "exit()", ":", "system", "rules", "needs", "at", "least", "junit", "4.9", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> exit() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "exit()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "exit()", "label": "API", "asoc": []}]}
{"text": "with this rule you are able to test code  ,  that calls exit : system rules needs at least junit 4.9", "tokens": ["with", "this", "rule", "you", "are", "able", "to", "test", "code", "", ",", "", "that", "calls", "exit", ":", "system", "rules", "needs", "at", "least", "junit", "4.9", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> exit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "exit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "exit", "label": "API", "asoc": []}]}
{"text": "with this rule you are able to test code  ,  that calls system.exit : system rules needs at least junit 4.9", "tokens": ["with", "this", "rule", "you", "are", "able", "to", "test", "code", "", ",", "", "that", "calls", "system.exit", ":", "system", "rules", "needs", "at", "least", "junit", "4.9", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.exit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "system.exit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.exit", "label": "API", "asoc": []}]}
{"text": "from observability of a package: the packages java  ,  lang  ,  and io are always observable", "tokens": ["from", "observability", "of", "a", "package:", "the", "packages", "java", "", ",", "", "lang", "", ",", "", "and", "io", "are", "always", "observable", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> lang <extra_id_0> function similarity <extra_id_5> io <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> io <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "lang"}, {"type": "API", "offset": [16], "text": "io"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [11], "text": "lang"}, {"type": "API", "offset": [16], "text": "io"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "lang", "label": "API", "asoc": [["function similarity", "io"]]}, {"span": "io", "label": "API", "asoc": []}]}
{"text": "since this is a swing application  ,  don't use a timer but rather a timer also known as a swing timer", "tokens": ["since", "this", "is", "a", "swing", "application", "", ",", "", "don't", "use", "a", "timer", "but", "rather", "a", "timer", "also", "known", "as", "a", "swing", "timer", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timer <extra_id_0> function replace <extra_id_5> timer <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> timer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "timer"}, {"type": "API", "offset": [12], "text": "timer"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [12], "text": "timer"}, {"type": "API", "offset": [12], "text": "timer"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "timer", "label": "API", "asoc": [["function replace", "timer"]]}, {"span": "timer", "label": "API", "asoc": []}]}
{"text": "but do you know anything about string objects  ?", "tokens": ["but", "do", "you", "know", "anything", "about", "string", "objects", "", "?", "", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string", "label": "API", "asoc": []}]}
{"text": "you can use thread for parallel execution", "tokens": ["you", "can", "use", "thread", "for", "parallel", "execution", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "thread"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread", "label": "API", "asoc": []}]}
{"text": "from jdk 7 you can use readallbytes(path)", "tokens": ["from", "jdk", "7", "you", "can", "use", "readallbytes(path)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> readallbytes(path) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "readallbytes(path)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "readallbytes(path)", "label": "API", "asoc": []}]}
{"text": "from jdk 7 you can use readallbytes", "tokens": ["from", "jdk", "7", "you", "can", "use", "readallbytes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> readallbytes <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "readallbytes"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "readallbytes", "label": "API", "asoc": []}]}
{"text": "from jdk 7 you can use files.readallbytes", "tokens": ["from", "jdk", "7", "you", "can", "use", "files.readallbytes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> files.readallbytes <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "files.readallbytes"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "files.readallbytes", "label": "API", "asoc": []}]}
{"text": "a timestamp actually does have (up to) nanosecond precision (assuming the database server and the driver actually support it)", "tokens": ["a", "timestamp", "actually", "does", "have", "(up", "to)", "nanosecond", "precision", "(assuming", "the", "database", "server", "and", "the", "driver", "actually", "support", "it)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "timestamp"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": []}]}
{"text": "i assume the reason you want access to the native connection is because you want access to a vendor connection class so you have access to vendor extensions", "tokens": ["i", "assume", "the", "reason", "you", "want", "access", "to", "the", "native", "connection", "is", "because", "you", "want", "access", "to", "a", "vendor", "connection", "class", "so", "you", "have", "access", "to", "vendor", "extensions", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> connection <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "connection"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "connection", "label": "API", "asoc": []}]}
{"text": "use the replaceall() method to replace all matches in the string note: using the \\b regex command will match on a word boundary (like whitespace)", "tokens": ["use", "the", "replaceall()", "method", "to", "replace", "all", "matches", "in", "the", "string", "note:", "using", "the", "\\b", "regex", "command", "will", "match", "on", "a", "word", "boundary", "(like", "whitespace)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replaceall() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "replaceall()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replaceall()", "label": "API", "asoc": []}]}
{"text": "use the replaceall method to replace all matches in the string note: using the \\b regex command will match on a word boundary (like whitespace)", "tokens": ["use", "the", "replaceall", "method", "to", "replace", "all", "matches", "in", "the", "string", "note:", "using", "the", "\\b", "regex", "command", "will", "match", "on", "a", "word", "boundary", "(like", "whitespace)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replaceall <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "replaceall"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replaceall", "label": "API", "asoc": []}]}
{"text": "use the matcher.replaceall method to replace all matches in the string note: using the \\b regex command will match on a word boundary (like whitespace)", "tokens": ["use", "the", "matcher.replaceall", "method", "to", "replace", "all", "matches", "in", "the", "string", "note:", "using", "the", "\\b", "regex", "command", "will", "match", "on", "a", "word", "boundary", "(like", "whitespace)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> matcher.replaceall <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "matcher.replaceall"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "matcher.replaceall", "label": "API", "asoc": []}]}
{"text": "note that it might not be this  ,  because currenttimemillis() doesn't progress smoothly  ,  owing to corrections for clock skew", "tokens": ["note", "that", "it", "might", "not", "be", "this", "", ",", "", "because", "currenttimemillis()", "doesn't", "progress", "smoothly", "", ",", "", "owing", "to", "corrections", "for", "clock", "skew", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> currenttimemillis() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "currenttimemillis()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "currenttimemillis()", "label": "API", "asoc": []}]}
{"text": "note that it might not be this  ,  because currenttimemillis doesn't progress smoothly  ,  owing to corrections for clock skew", "tokens": ["note", "that", "it", "might", "not", "be", "this", "", ",", "", "because", "currenttimemillis", "doesn't", "progress", "smoothly", "", ",", "", "owing", "to", "corrections", "for", "clock", "skew", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> currenttimemillis <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "currenttimemillis"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "currenttimemillis", "label": "API", "asoc": []}]}
{"text": "note that it might not be this  ,  because system.currenttimemillis doesn't progress smoothly  ,  owing to corrections for clock skew", "tokens": ["note", "that", "it", "might", "not", "be", "this", "", ",", "", "because", "system.currenttimemillis", "doesn't", "progress", "smoothly", "", ",", "", "owing", "to", "corrections", "for", "clock", "skew", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.currenttimemillis <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "system.currenttimemillis"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.currenttimemillis", "label": "API", "asoc": []}]}
{"text": "so i was expecting a compiling error due to the fact that the compiler would not be able to find the string class file", "tokens": ["so", "i", "was", "expecting", "a", "compiling", "error", "due", "to", "the", "fact", "that", "the", "compiler", "would", "not", "be", "able", "to", "find", "the", "string", "class", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string", "label": "API", "asoc": []}]}
{"text": "i think you'll have to live with the @suppresswarnings(...) approach since the invoke method returns an object", "tokens": ["i", "think", "you'll", "have", "to", "live", "with", "the", "@suppresswarnings(...)", "approach", "since", "the", "invoke", "method", "returns", "an", "object", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> invoke <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "invoke"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "invoke", "label": "API", "asoc": []}]}
{"text": "so how can you store nothing in it or have it empty  ?  it can only store references to instances of date", "tokens": ["so", "how", "can", "you", "store", "nothing", "in", "it", "or", "have", "it", "empty", "", "?", "", "it", "can", "only", "store", "references", "to", "instances", "of", "date", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> date <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "date"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "date", "label": "API", "asoc": []}]}
{"text": "equals tests for value equality", "tokens": ["equals", "tests", "for", "value", "equality", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "equals"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "equals", "label": "API", "asoc": []}]}
{"text": "read the simpledateformat javadoc what the individual parts stands for", "tokens": ["read", "the", "simpledateformat", "javadoc", "what", "the", "individual", "parts", "stands", "for", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> simpledateformat <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "simpledateformat"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "simpledateformat", "label": "API", "asoc": []}]}
{"text": "join will make the currently executing thread to wait for the the thread it is called on to die", "tokens": ["join", "will", "make", "the", "currently", "executing", "thread", "to", "wait", "for", "the", "the", "thread", "it", "is", "called", "on", "to", "die", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> join <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "join"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "join", "label": "API", "asoc": []}]}
{"text": "you can access the text by calling the text method on the element", "tokens": ["you", "can", "access", "the", "text", "by", "calling", "the", "text", "method", "on", "the", "element", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> text <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "text"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "text", "label": "API", "asoc": []}]}
{"text": "then you can use the getsource method to tell which combobox the event came from", "tokens": ["then", "you", "can", "use", "the", "getsource", "method", "to", "tell", "which", "combobox", "the", "event", "came", "from", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getsource <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "getsource"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getsource", "label": "API", "asoc": []}]}
{"text": "now when the thread is notified either by notify or by notifyall call on the same object then the waiting state of the thread ends", "tokens": ["now", "when", "the", "thread", "is", "notified", "either", "by", "notify", "or", "by", "notifyall", "call", "on", "the", "same", "object", "then", "the", "waiting", "state", "of", "the", "thread", "ends", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> notify <extra_id_0> function similarity <extra_id_5> notifyall <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> notifyall <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "notify"}, {"type": "API", "offset": [11], "text": "notifyall"}], "relation": [{"type": "function similarity", "args": [{"type": "API", "offset": [8], "text": "notify"}, {"type": "API", "offset": [11], "text": "notifyall"}]}], "event": [], "spot": ["API"], "asoc": ["function similarity"], "spot_asoc": [{"span": "notify", "label": "API", "asoc": [["function similarity", "notifyall"]]}, {"span": "notifyall", "label": "API", "asoc": []}]}
{"text": "if you must interact with old code not yet updated for time types  ,  you can convert to/from time types", "tokens": ["if", "you", "must", "interact", "with", "old", "code", "not", "yet", "updated", "for", "time", "types", "", ",", "", "you", "can", "convert", "to/from", "time", "types", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "time", "label": "API", "asoc": []}]}
{"text": "you can't modify this map while iterating on it  ,  except by invoking remove on the iterator", "tokens": ["you", "can't", "modify", "this", "map", "while", "iterating", "on", "it", "", ",", "", "except", "by", "invoking", "remove", "on", "the", "iterator", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "remove"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove", "label": "API", "asoc": []}]}
{"text": "in your compareto method  ,  when you detect that you are looking at two strings representing integers  ,  make sure they are the same length before comparing them", "tokens": ["in", "your", "compareto", "method", "", ",", "", "when", "you", "detect", "that", "you", "are", "looking", "at", "two", "strings", "representing", "integers", "", ",", "", "make", "sure", "they", "are", "the", "same", "length", "before", "comparing", "them", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> compareto <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "compareto"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "compareto", "label": "API", "asoc": []}]}
{"text": "use timer to schedule a future event to trigger", "tokens": ["use", "timer", "to", "schedule", "a", "future", "event", "to", "trigger", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "timer"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "timer", "label": "API", "asoc": []}]}
{"text": "as an aside  ,  you don't want to override the update method for swing gui's as that's mainly for awt gui's  ,  unless you're changing the application's look and feel in mid run", "tokens": ["as", "an", "aside", "", ",", "", "you", "don't", "want", "to", "override", "the", "update", "method", "for", "swing", "gui's", "as", "that's", "mainly", "for", "awt", "gui's", "", ",", "", "unless", "you're", "changing", "the", "application's", "look", "and", "feel", "in", "mid", "run", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> update <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "update"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "update", "label": "API", "asoc": []}]}
{"text": "the problem is that remove() has two methods  ,  one that is an object  ,  and one that is an (int index)", "tokens": ["the", "problem", "is", "that", "remove()", "has", "two", "methods", "", ",", "", "one", "that", "is", "an", "object", "", ",", "", "and", "one", "that", "is", "an", "(int", "index)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "remove()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove()", "label": "API", "asoc": []}]}
{"text": "the problem is that remove has two methods  ,  one that is an object  ,  and one that is an (int index)", "tokens": ["the", "problem", "is", "that", "remove", "has", "two", "methods", "", ",", "", "one", "that", "is", "an", "object", "", ",", "", "and", "one", "that", "is", "an", "(int", "index)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "remove"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove", "label": "API", "asoc": []}]}
{"text": "the problem is that arraylist.remove has two methods  ,  one that is an object  ,  and one that is an (int index)", "tokens": ["the", "problem", "is", "that", "arraylist.remove", "has", "two", "methods", "", ",", "", "one", "that", "is", "an", "object", "", ",", "", "and", "one", "that", "is", "an", "(int", "index)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arraylist.remove <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "arraylist.remove"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arraylist.remove", "label": "API", "asoc": []}]}
{"text": "withzonesamelocal will change the zone but keep all the other fields the same", "tokens": ["withzonesamelocal", "will", "change", "the", "zone", "but", "keep", "all", "the", "other", "fields", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> withzonesamelocal <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "withzonesamelocal"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "withzonesamelocal", "label": "API", "asoc": []}]}
{"text": "you need to call repaint and revalidate", "tokens": ["you", "need", "to", "call", "repaint", "and", "revalidate", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint <extra_id_0> function collaboration <extra_id_5> revalidate <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> revalidate <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "repaint"}, {"type": "API", "offset": [6], "text": "revalidate"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [4], "text": "repaint"}, {"type": "API", "offset": [6], "text": "revalidate"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "repaint", "label": "API", "asoc": [["function collaboration", "revalidate"]]}, {"span": "revalidate", "label": "API", "asoc": []}]}
{"text": "you can assert that the two sets are equal to one another  ,  which invokes the set equals method  .", "tokens": ["you", "can", "assert", "that", "the", "two", "sets", "are", "equal", "to", "one", "another", "", ",", "", "which", "invokes", "the", "set", "equals", "method", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "equals"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "equals", "label": "API", "asoc": []}]}
{"text": "(i still prefer it over the exit() call  ,  but using reflection in this way is somewhat fragile.)", "tokens": ["(i", "still", "prefer", "it", "over", "the", "exit()", "call", "", ",", "", "but", "using", "reflection", "in", "this", "way", "is", "somewhat", "fragile.)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> exit() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "exit()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "exit()", "label": "API", "asoc": []}]}
{"text": "(i still prefer it over the exit call  ,  but using reflection in this way is somewhat fragile.)", "tokens": ["(i", "still", "prefer", "it", "over", "the", "exit", "call", "", ",", "", "but", "using", "reflection", "in", "this", "way", "is", "somewhat", "fragile.)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> exit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "exit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "exit", "label": "API", "asoc": []}]}
{"text": "(i still prefer it over the system.exit call  ,  but using reflection in this way is somewhat fragile.)", "tokens": ["(i", "still", "prefer", "it", "over", "the", "system.exit", "call", "", ",", "", "but", "using", "reflection", "in", "this", "way", "is", "somewhat", "fragile.)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.exit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "system.exit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.exit", "label": "API", "asoc": []}]}
{"text": "fetch rows in your implementation of doinbackground  ,  publish interim results  ,  and add them to the table model in your implementation of process", "tokens": ["fetch", "rows", "in", "your", "implementation", "of", "doinbackground", "", ",", "", "publish", "interim", "results", "", ",", "", "and", "add", "them", "to", "the", "table", "model", "in", "your", "implementation", "of", "process", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> doinbackground <extra_id_0> function collaboration <extra_id_5> publish <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> publish <extra_id_1> <extra_id_0> API <extra_id_5> process <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "doinbackground"}, {"type": "API", "offset": [10], "text": "publish"}, {"type": "API", "offset": [27], "text": "process"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [6], "text": "doinbackground"}, {"type": "API", "offset": [10], "text": "publish"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "doinbackground", "label": "API", "asoc": [["function collaboration", "publish"]]}, {"span": "publish", "label": "API", "asoc": []}, {"span": "process", "label": "API", "asoc": []}]}
{"text": "in short paintcomponent is a method defined in jpanel or your own custom class that extends jpanel", "tokens": ["in", "short", "paintcomponent", "is", "a", "method", "defined", "in", "jpanel", "or", "your", "own", "custom", "class", "that", "extends", "jpanel", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> paintcomponent <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "paintcomponent"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "paintcomponent", "label": "API", "asoc": []}]}
{"text": "because the first thread has already checked the condition however  ,  it will simply call wait after being re-scheduled  ,  even though it could make progress", "tokens": ["because", "the", "first", "thread", "has", "already", "checked", "the", "condition", "however", "", ",", "", "it", "will", "simply", "call", "wait", "after", "being", "re-scheduled", "", ",", "", "even", "though", "it", "could", "make", "progress", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "wait"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait", "label": "API", "asoc": []}]}
{"text": "it's very compact: a hashset is used here to give good look-up performance - even very large hash sets are able to execute contains extremely quickly", "tokens": ["it's", "very", "compact:", "a", "hashset", "is", "used", "here", "to", "give", "good", "look-up", "performance", "-", "even", "very", "large", "hash", "sets", "are", "able", "to", "execute", "contains", "extremely", "quickly", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> contains <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "contains"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "contains", "label": "API", "asoc": []}]}
{"text": "it is clear that they could not either get rid of size or change its semantics without creating compatibility problems", "tokens": ["it", "is", "clear", "that", "they", "could", "not", "either", "get", "rid", "of", "size", "or", "change", "its", "semantics", "without", "creating", "compatibility", "problems", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> size <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "size"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "size", "label": "API", "asoc": []}]}
{"text": "collections are iterable  ,  and each call to iterator produces a distinct iterator instance that is independent of any other active instances", "tokens": ["collections", "are", "iterable", "", ",", "", "and", "each", "call", "to", "iterator", "produces", "a", "distinct", "iterator", "instance", "that", "is", "independent", "of", "any", "other", "active", "instances", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> iterator <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "iterator"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "iterator", "label": "API", "asoc": []}]}
{"text": "inshort  ,  klassklass means that you would have one class object which defines the behavior of class itself", "tokens": ["inshort", "", ",", "", "klassklass", "means", "that", "you", "would", "have", "one", "class", "object", "which", "defines", "the", "behavior", "of", "class", "itself", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> class <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "class"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "class", "label": "API", "asoc": []}]}
{"text": "2.why i'm able to acess the method show  ?   because this method is available in all a objects (if it's not declared in the subclass  ,  it is still inherited from a)  .", "tokens": ["2.why", "i'm", "able", "to", "acess", "the", "method", "show", "", "?", "", "", "because", "this", "method", "is", "available", "in", "all", "a", "objects", "(if", "it's", "not", "declared", "in", "the", "subclass", "", ",", "", "it", "is", "still", "inherited", "from", "a)", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> show <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "show"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "show", "label": "API", "asoc": []}]}
{"text": "the method  ,  refreshrow()  ,  suppose to update the resultset  ,  hence it rightly requires updatable resultset", "tokens": ["the", "method", "", ",", "", "refreshrow()", "", ",", "", "suppose", "to", "update", "the", "resultset", "", ",", "", "hence", "it", "rightly", "requires", "updatable", "resultset", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> refreshrow() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "refreshrow()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "refreshrow()", "label": "API", "asoc": []}]}
{"text": "the method  ,  refreshrow  ,  suppose to update the resultset  ,  hence it rightly requires updatable resultset", "tokens": ["the", "method", "", ",", "", "refreshrow", "", ",", "", "suppose", "to", "update", "the", "resultset", "", ",", "", "hence", "it", "rightly", "requires", "updatable", "resultset", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> refreshrow <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "refreshrow"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "refreshrow", "label": "API", "asoc": []}]}
{"text": "the method  ,  resultset.refreshrow  ,  suppose to update the resultset  ,  hence it rightly requires updatable resultset", "tokens": ["the", "method", "", ",", "", "resultset.refreshrow", "", ",", "", "suppose", "to", "update", "the", "resultset", "", ",", "", "hence", "it", "rightly", "requires", "updatable", "resultset", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> resultset.refreshrow <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "resultset.refreshrow"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "resultset.refreshrow", "label": "API", "asoc": []}]}
{"text": "this call is normally included in a finally block  ,  but if the application calls exit(0)  ,  finally blocks are no longer executed  .", "tokens": ["this", "call", "is", "normally", "included", "in", "a", "finally", "block", "", ",", "", "but", "if", "the", "application", "calls", "exit(0)", "", ",", "", "finally", "blocks", "are", "no", "longer", "executed", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> exit(0) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "exit(0)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "exit(0)", "label": "API", "asoc": []}]}
{"text": "this call is normally included in a finally block  ,  but if the application calls exit  ,  finally blocks are no longer executed  .", "tokens": ["this", "call", "is", "normally", "included", "in", "a", "finally", "block", "", ",", "", "but", "if", "the", "application", "calls", "exit", "", ",", "", "finally", "blocks", "are", "no", "longer", "executed", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> exit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "exit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "exit", "label": "API", "asoc": []}]}
{"text": "this call is normally included in a finally block  ,  but if the application calls system.exit  ,  finally blocks are no longer executed  .", "tokens": ["this", "call", "is", "normally", "included", "in", "a", "finally", "block", "", ",", "", "but", "if", "the", "application", "calls", "system.exit", "", ",", "", "finally", "blocks", "are", "no", "longer", "executed", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.exit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "system.exit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.exit", "label": "API", "asoc": []}]}
{"text": "considering object identity \"it is recommended that you implement equals and hashcode using business key equality", "tokens": ["considering", "object", "identity", "\"it", "is", "recommended", "that", "you", "implement", "equals", "and", "hashcode", "using", "business", "key", "equality", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals <extra_id_0> function collaboration <extra_id_5> hashcode <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> hashcode <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "equals"}, {"type": "API", "offset": [11], "text": "hashcode"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [9], "text": "equals"}, {"type": "API", "offset": [11], "text": "hashcode"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "equals", "label": "API", "asoc": [["function collaboration", "hashcode"]]}, {"span": "hashcode", "label": "API", "asoc": []}]}
{"text": "it gives you a process object that you can waitfor  ,  like this:", "tokens": ["it", "gives", "you", "a", "process", "object", "that", "you", "can", "waitfor", "", ",", "", "like", "this:", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> waitfor <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "waitfor"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "waitfor", "label": "API", "asoc": []}]}
{"text": "this is file is simply properties file", "tokens": ["this", "is", "file", "is", "simply", "properties", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> properties <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "properties"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "properties", "label": "API", "asoc": []}]}
{"text": "this is most likely because your code (either directly or via hibernate) is trying to read a value from a returned result set and it's using the wrong type (such as getstring on a numeric value)", "tokens": ["this", "is", "most", "likely", "because", "your", "code", "(either", "directly", "or", "via", "hibernate)", "is", "trying", "to", "read", "a", "value", "from", "a", "returned", "result", "set", "and", "it's", "using", "the", "wrong", "type", "(such", "as", "getstring", "on", "a", "numeric", "value)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getstring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [31], "text": "getstring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getstring", "label": "API", "asoc": []}]}
{"text": "stream is not a sub-pacakge of java.util", "tokens": ["stream", "is", "not", "a", "sub-pacakge", "of", "java.util", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> stream <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "stream"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "stream", "label": "API", "asoc": []}]}
{"text": "i don't believe it's possible  ,  since date is based on utc  ,  which is based on the gregorian calendar  ,  and the gregorian calendar has no year zero", "tokens": ["i", "don't", "believe", "it's", "possible", "", ",", "", "since", "date", "is", "based", "on", "utc", "", ",", "", "which", "is", "based", "on", "the", "gregorian", "calendar", "", ",", "", "and", "the", "gregorian", "calendar", "has", "no", "year", "zero", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> date <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "date"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "date", "label": "API", "asoc": []}]}
{"text": "this comparator class must implement the comparator interface  .", "tokens": ["this", "comparator", "class", "must", "implement", "the", "comparator", "interface", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> comparator <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "comparator"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "comparator", "label": "API", "asoc": []}]}
{"text": "try to use your original code with write and add \\n at the end to confirm this  .", "tokens": ["try", "to", "use", "your", "original", "code", "with", "write", "and", "add", "\\n", "at", "the", "end", "to", "confirm", "this", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> write <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "write"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "write", "label": "API", "asoc": []}]}
{"text": "the run method would be in the stackframe if the user overrode it in a thread superclass", "tokens": ["the", "run", "method", "would", "be", "in", "the", "stackframe", "if", "the", "user", "overrode", "it", "in", "a", "thread", "superclass", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> run <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "run"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "run", "label": "API", "asoc": []}]}
{"text": "use copyof() methods which returns a bigger array  ,  with the contents of the original array  .", "tokens": ["use", "copyof()", "methods", "which", "returns", "a", "bigger", "array", "", ",", "", "with", "the", "contents", "of", "the", "original", "array", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> copyof() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "copyof()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "copyof()", "label": "API", "asoc": []}]}
{"text": "use copyof methods which returns a bigger array  ,  with the contents of the original array  .", "tokens": ["use", "copyof", "methods", "which", "returns", "a", "bigger", "array", "", ",", "", "with", "the", "contents", "of", "the", "original", "array", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> copyof <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "copyof"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "copyof", "label": "API", "asoc": []}]}
{"text": "use java.util.arrays.copyof methods which returns a bigger array  ,  with the contents of the original array  .", "tokens": ["use", "java.util.arrays.copyof", "methods", "which", "returns", "a", "bigger", "array", "", ",", "", "with", "the", "contents", "of", "the", "original", "array", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.arrays.copyof <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "java.util.arrays.copyof"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.arrays.copyof", "label": "API", "asoc": []}]}
{"text": "they are now legacy  ,  supplanted entirely by the time classes", "tokens": ["they", "are", "now", "legacy", "", ",", "", "supplanted", "entirely", "by", "the", "time", "classes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "time", "label": "API", "asoc": []}]}
{"text": "this is the reason why your contains is not giving you correct results  .", "tokens": ["this", "is", "the", "reason", "why", "your", "contains", "is", "not", "giving", "you", "correct", "results", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> contains <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "contains"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "contains", "label": "API", "asoc": []}]}
{"text": "you should create your own class that is serializable that includes two fields: a byte[] for the file contents  ,  and a file that has everything else you need", "tokens": ["you", "should", "create", "your", "own", "class", "that", "is", "serializable", "that", "includes", "two", "fields:", "a", "byte[]", "for", "the", "file", "contents", "", ",", "", "and", "a", "file", "that", "has", "everything", "else", "you", "need", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "file"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file", "label": "API", "asoc": []}]}
{"text": "by contrast  ,  foreach is always executed in the iteration order of the iterable  ,  if one is specified", "tokens": ["by", "contrast", "", ",", "", "foreach", "is", "always", "executed", "in", "the", "iteration", "order", "of", "the", "iterable", "", ",", "", "if", "one", "is", "specified", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> foreach <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "foreach"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "foreach", "label": "API", "asoc": []}]}
{"text": "you can always convert to/from a date at the boundaries of your own code if you need to  ,  e.g", "tokens": ["you", "can", "always", "convert", "to/from", "a", "date", "at", "the", "boundaries", "of", "your", "own", "code", "if", "you", "need", "to", "", ",", "", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> date <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "date"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "date", "label": "API", "asoc": []}]}
{"text": "on most of those types you can't \"just\" do a tostring as you would do in a simple statement", "tokens": ["on", "most", "of", "those", "types", "you", "can't", "\"just\"", "do", "a", "tostring", "as", "you", "would", "do", "in", "a", "simple", "statement", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "tostring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring", "label": "API", "asoc": []}]}
{"text": "this can be seen in the source code for get (archive)", "tokens": ["this", "can", "be", "seen", "in", "the", "source", "code", "for", "get", "(archive)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> get <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "get"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "get", "label": "API", "asoc": []}]}
{"text": "the repaint will definitely be necessary if the change in components involves a deletion  ,  or a component being drawn where another component was visualized previously", "tokens": ["the", "repaint", "will", "definitely", "be", "necessary", "if", "the", "change", "in", "components", "involves", "a", "deletion", "", ",", "", "or", "a", "component", "being", "drawn", "where", "another", "component", "was", "visualized", "previously", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "repaint"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint", "label": "API", "asoc": []}]}
{"text": "[if a class load fails one time and you or spring call forname() again for some reason  ,  then java won't actually try to load a second time", "tokens": ["[if", "a", "class", "load", "fails", "one", "time", "and", "you", "or", "spring", "call", "forname()", "again", "for", "some", "reason", "", ",", "", "then", "java", "won't", "actually", "try", "to", "load", "a", "second", "time", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> forname() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "forname()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "forname()", "label": "API", "asoc": []}]}
{"text": "[if a class load fails one time and you or spring call forname again for some reason  ,  then java won't actually try to load a second time", "tokens": ["[if", "a", "class", "load", "fails", "one", "time", "and", "you", "or", "spring", "call", "forname", "again", "for", "some", "reason", "", ",", "", "then", "java", "won't", "actually", "try", "to", "load", "a", "second", "time", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> forname <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "forname"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "forname", "label": "API", "asoc": []}]}
{"text": "[if a class load fails one time and you or spring call class.forname again for some reason  ,  then java won't actually try to load a second time", "tokens": ["[if", "a", "class", "load", "fails", "one", "time", "and", "you", "or", "spring", "call", "class.forname", "again", "for", "some", "reason", "", ",", "", "then", "java", "won't", "actually", "try", "to", "load", "a", "second", "time", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> class.forname <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "class.forname"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "class.forname", "label": "API", "asoc": []}]}
{"text": "inheriting gives you the release method  ,  for example (you can peek inside the unknown class to see the implementation)", "tokens": ["inheriting", "gives", "you", "the", "release", "method", "", ",", "", "for", "example", "(you", "can", "peek", "inside", "the", "unknown", "class", "to", "see", "the", "implementation)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> release <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "release"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "release", "label": "API", "asoc": []}]}
{"text": "i have nether used gc()", "tokens": ["i", "have", "nether", "used", "gc()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> gc() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "gc()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "gc()", "label": "API", "asoc": []}]}
{"text": "i have nether used gc", "tokens": ["i", "have", "nether", "used", "gc", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> gc <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "gc"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "gc", "label": "API", "asoc": []}]}
{"text": "i have nether used system.gc", "tokens": ["i", "have", "nether", "used", "system.gc", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.gc <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.gc"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.gc", "label": "API", "asoc": []}]}
{"text": "these troublesome classes are entirely supplanted by the time classes", "tokens": ["these", "troublesome", "classes", "are", "entirely", "supplanted", "by", "the", "time", "classes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "time", "label": "API", "asoc": []}]}
{"text": "you should not use sleep() on event dispatch thread (or any thread where sleep will cuase unwanted execution blocking)  ,  as this will cause the ui to seem frozen", "tokens": ["you", "should", "not", "use", "sleep()", "on", "event", "dispatch", "thread", "(or", "any", "thread", "where", "sleep", "will", "cuase", "unwanted", "execution", "blocking)", "", ",", "", "as", "this", "will", "cause", "the", "ui", "to", "seem", "frozen", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> sleep() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "sleep()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "sleep()", "label": "API", "asoc": []}]}
{"text": "you should not use sleep on event dispatch thread (or any thread where sleep will cuase unwanted execution blocking)  ,  as this will cause the ui to seem frozen", "tokens": ["you", "should", "not", "use", "sleep", "on", "event", "dispatch", "thread", "(or", "any", "thread", "where", "sleep", "will", "cuase", "unwanted", "execution", "blocking)", "", ",", "", "as", "this", "will", "cause", "the", "ui", "to", "seem", "frozen", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> sleep <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "sleep"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "sleep", "label": "API", "asoc": []}]}
{"text": "you should not use thread.sleep on event dispatch thread (or any thread where sleep will cuase unwanted execution blocking)  ,  as this will cause the ui to seem frozen", "tokens": ["you", "should", "not", "use", "thread.sleep", "on", "event", "dispatch", "thread", "(or", "any", "thread", "where", "sleep", "will", "cuase", "unwanted", "execution", "blocking)", "", ",", "", "as", "this", "will", "cause", "the", "ui", "to", "seem", "frozen", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "thread.sleep"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep", "label": "API", "asoc": []}]}
{"text": "in 1.3 and above there is a single thread per consumer; the next poll is performed after the last message from the previous poll has been processed by the listener", "tokens": ["in", "1.3", "and", "above", "there", "is", "a", "single", "thread", "per", "consumer;", "the", "next", "poll", "is", "performed", "after", "the", "last", "message", "from", "the", "previous", "poll", "has", "been", "processed", "by", "the", "listener", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> poll <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "poll"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "poll", "label": "API", "asoc": []}]}
{"text": "so afterwards  ,  the keyset of the map contains the disjoint set  .", "tokens": ["so", "afterwards", "", ",", "", "the", "keyset", "of", "the", "map", "contains", "the", "disjoint", "set", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> keyset <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "keyset"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "keyset", "label": "API", "asoc": []}]}
{"text": "clock is an interface that you can use to get your timestamp values", "tokens": ["clock", "is", "an", "interface", "that", "you", "can", "use", "to", "get", "your", "timestamp", "values", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> clock <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "clock"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "clock", "label": "API", "asoc": []}]}
{"text": "to start the playback  ,  start must be called", "tokens": ["to", "start", "the", "playback", "", ",", "", "start", "must", "be", "called", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> start <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "start"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "start", "label": "API", "asoc": []}]}
{"text": "i am using the libphonenumber library along with locale class to complete this as follows", "tokens": ["i", "am", "using", "the", "libphonenumber", "library", "along", "with", "locale", "class", "to", "complete", "this", "as", "follows", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> locale <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "locale"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "locale", "label": "API", "asoc": []}]}
{"text": "the first step of the take method is then  ,  naturally  ,  to acquire the read semaphore  ,  in order to disallow any other thread to retrieve the element concurrently", "tokens": ["the", "first", "step", "of", "the", "take", "method", "is", "then", "", ",", "", "naturally", "", ",", "", "to", "acquire", "the", "read", "semaphore", "", ",", "", "in", "order", "to", "disallow", "any", "other", "thread", "to", "retrieve", "the", "element", "concurrently", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> take <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "take"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "take", "label": "API", "asoc": []}]}
{"text": "read the input with scanner and a for loop:", "tokens": ["read", "the", "input", "with", "scanner", "and", "a", "for", "loop:", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> scanner <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "scanner"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "scanner", "label": "API", "asoc": []}]}
{"text": "when you call getsubimage()  ,  then the image on which you call this method will become \"unmanaged\"", "tokens": ["when", "you", "call", "getsubimage()", "", ",", "", "then", "the", "image", "on", "which", "you", "call", "this", "method", "will", "become", "\"unmanaged\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getsubimage() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "getsubimage()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getsubimage()", "label": "API", "asoc": []}]}
{"text": "when you call getsubimage  ,  then the image on which you call this method will become \"unmanaged\"", "tokens": ["when", "you", "call", "getsubimage", "", ",", "", "then", "the", "image", "on", "which", "you", "call", "this", "method", "will", "become", "\"unmanaged\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getsubimage <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "getsubimage"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getsubimage", "label": "API", "asoc": []}]}
{"text": "when you call bufferedimage.getsubimage  ,  then the image on which you call this method will become \"unmanaged\"", "tokens": ["when", "you", "call", "bufferedimage.getsubimage", "", ",", "", "then", "the", "image", "on", "which", "you", "call", "this", "method", "will", "become", "\"unmanaged\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> bufferedimage.getsubimage <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "bufferedimage.getsubimage"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "bufferedimage.getsubimage", "label": "API", "asoc": []}]}
{"text": "select statements in jsoup will not return null if there are no elements", "tokens": ["select", "statements", "in", "jsoup", "will", "not", "return", "null", "if", "there", "are", "no", "elements", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> select <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "select"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "select", "label": "API", "asoc": []}]}
{"text": "this follows from the fact that the equals method takes in an object as parameter  ,  not just the same type as the object", "tokens": ["this", "follows", "from", "the", "fact", "that", "the", "equals", "method", "takes", "in", "an", "object", "as", "parameter", "", ",", "", "not", "just", "the", "same", "type", "as", "the", "object", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "equals"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "equals", "label": "API", "asoc": []}]}
{"text": "update: to clarify a conceptual misunderstanding  ,  the sleep is not required", "tokens": ["update:", "to", "clarify", "a", "conceptual", "misunderstanding", "", ",", "", "the", "sleep", "is", "not", "required", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> sleep <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "sleep"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "sleep", "label": "API", "asoc": []}]}
{"text": "note also that the power-of-two computation based on highestonebit() introduced by this changeset also disappeared at the same time  ,  though this was noted but dismissed during the review", "tokens": ["note", "also", "that", "the", "power-of-two", "computation", "based", "on", "highestonebit()", "introduced", "by", "this", "changeset", "also", "disappeared", "at", "the", "same", "time", "", ",", "", "though", "this", "was", "noted", "but", "dismissed", "during", "the", "review", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> highestonebit() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "highestonebit()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "highestonebit()", "label": "API", "asoc": []}]}
{"text": "note also that the power-of-two computation based on highestonebit introduced by this changeset also disappeared at the same time  ,  though this was noted but dismissed during the review", "tokens": ["note", "also", "that", "the", "power-of-two", "computation", "based", "on", "highestonebit", "introduced", "by", "this", "changeset", "also", "disappeared", "at", "the", "same", "time", "", ",", "", "though", "this", "was", "noted", "but", "dismissed", "during", "the", "review", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> highestonebit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "highestonebit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "highestonebit", "label": "API", "asoc": []}]}
{"text": "note also that the power-of-two computation based on integer.highestonebit introduced by this changeset also disappeared at the same time  ,  though this was noted but dismissed during the review", "tokens": ["note", "also", "that", "the", "power-of-two", "computation", "based", "on", "integer.highestonebit", "introduced", "by", "this", "changeset", "also", "disappeared", "at", "the", "same", "time", "", ",", "", "though", "this", "was", "noted", "but", "dismissed", "during", "the", "review", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> integer.highestonebit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "integer.highestonebit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "integer.highestonebit", "label": "API", "asoc": []}]}
{"text": "by default the oracle drivers does not return information on synonyms in getcolumns", "tokens": ["by", "default", "the", "oracle", "drivers", "does", "not", "return", "information", "on", "synonyms", "in", "getcolumns", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumns <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "getcolumns"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumns", "label": "API", "asoc": []}]}
{"text": "however  ,  there is nothing special about remove() that makes it work in all cases  .", "tokens": ["however", "", ",", "", "there", "is", "nothing", "special", "about", "remove()", "that", "makes", "it", "work", "in", "all", "cases", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "remove()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove()", "label": "API", "asoc": []}]}
{"text": "however  ,  there is nothing special about remove that makes it work in all cases  .", "tokens": ["however", "", ",", "", "there", "is", "nothing", "special", "about", "remove", "that", "makes", "it", "work", "in", "all", "cases", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "remove"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove", "label": "API", "asoc": []}]}
{"text": "however  ,  there is nothing special about iterator.remove that makes it work in all cases  .", "tokens": ["however", "", ",", "", "there", "is", "nothing", "special", "about", "iterator.remove", "that", "makes", "it", "work", "in", "all", "cases", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> iterator.remove <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "iterator.remove"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "iterator.remove", "label": "API", "asoc": []}]}
{"text": "e.g .  ,  instead of calling newdirectorystream(path) just call list(path)", "tokens": ["e.g", ".", "", ",", "", "instead", "of", "calling", "newdirectorystream(path)", "just", "call", "list(path)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> newdirectorystream(path) <extra_id_0> function replace <extra_id_5> list(path) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> list(path) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "newdirectorystream(path)"}, {"type": "API", "offset": [11], "text": "list(path)"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [8], "text": "newdirectorystream(path)"}, {"type": "API", "offset": [11], "text": "list(path)"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "newdirectorystream(path)", "label": "API", "asoc": [["function replace", "list(path)"]]}, {"span": "list(path)", "label": "API", "asoc": []}]}
{"text": "e.g .  ,  instead of calling newdirectorystream(path) just call list", "tokens": ["e.g", ".", "", ",", "", "instead", "of", "calling", "newdirectorystream(path)", "just", "call", "list", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> newdirectorystream(path) <extra_id_0> function replace <extra_id_5> list <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> list <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "newdirectorystream(path)"}, {"type": "API", "offset": [11], "text": "list"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [8], "text": "newdirectorystream(path)"}, {"type": "API", "offset": [11], "text": "list"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "newdirectorystream(path)", "label": "API", "asoc": [["function replace", "list"]]}, {"span": "list", "label": "API", "asoc": []}]}
{"text": "e.g .  ,  instead of calling newdirectorystream(path) just call files.list", "tokens": ["e.g", ".", "", ",", "", "instead", "of", "calling", "newdirectorystream(path)", "just", "call", "files.list", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> newdirectorystream(path) <extra_id_0> function replace <extra_id_5> files.list <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> files.list <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "newdirectorystream(path)"}, {"type": "API", "offset": [11], "text": "files.list"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [8], "text": "newdirectorystream(path)"}, {"type": "API", "offset": [11], "text": "files.list"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "newdirectorystream(path)", "label": "API", "asoc": [["function replace", "files.list"]]}, {"span": "files.list", "label": "API", "asoc": []}]}
{"text": "e.g .  ,  instead of calling newdirectorystream just call list(path)", "tokens": ["e.g", ".", "", ",", "", "instead", "of", "calling", "newdirectorystream", "just", "call", "list(path)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> newdirectorystream <extra_id_0> function replace <extra_id_5> list(path) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> list(path) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "newdirectorystream"}, {"type": "API", "offset": [11], "text": "list(path)"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [8], "text": "newdirectorystream"}, {"type": "API", "offset": [11], "text": "list(path)"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "newdirectorystream", "label": "API", "asoc": [["function replace", "list(path)"]]}, {"span": "list(path)", "label": "API", "asoc": []}]}
{"text": "e.g .  ,  instead of calling newdirectorystream just call list", "tokens": ["e.g", ".", "", ",", "", "instead", "of", "calling", "newdirectorystream", "just", "call", "list", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> newdirectorystream <extra_id_0> function replace <extra_id_5> list <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> list <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "newdirectorystream"}, {"type": "API", "offset": [11], "text": "list"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [8], "text": "newdirectorystream"}, {"type": "API", "offset": [11], "text": "list"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "newdirectorystream", "label": "API", "asoc": [["function replace", "list"]]}, {"span": "list", "label": "API", "asoc": []}]}
{"text": "e.g .  ,  instead of calling newdirectorystream just call files.list", "tokens": ["e.g", ".", "", ",", "", "instead", "of", "calling", "newdirectorystream", "just", "call", "files.list", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> newdirectorystream <extra_id_0> function replace <extra_id_5> files.list <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> files.list <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "newdirectorystream"}, {"type": "API", "offset": [11], "text": "files.list"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [8], "text": "newdirectorystream"}, {"type": "API", "offset": [11], "text": "files.list"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "newdirectorystream", "label": "API", "asoc": [["function replace", "files.list"]]}, {"span": "files.list", "label": "API", "asoc": []}]}
{"text": "e.g .  ,  instead of calling files.newdirectorystream just call list(path)", "tokens": ["e.g", ".", "", ",", "", "instead", "of", "calling", "files.newdirectorystream", "just", "call", "list(path)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> files.newdirectorystream <extra_id_0> function replace <extra_id_5> list(path) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> list(path) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "files.newdirectorystream"}, {"type": "API", "offset": [11], "text": "list(path)"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [8], "text": "files.newdirectorystream"}, {"type": "API", "offset": [11], "text": "list(path)"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "files.newdirectorystream", "label": "API", "asoc": [["function replace", "list(path)"]]}, {"span": "list(path)", "label": "API", "asoc": []}]}
{"text": "e.g .  ,  instead of calling files.newdirectorystream just call list", "tokens": ["e.g", ".", "", ",", "", "instead", "of", "calling", "files.newdirectorystream", "just", "call", "list", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> files.newdirectorystream <extra_id_0> function replace <extra_id_5> list <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> list <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "files.newdirectorystream"}, {"type": "API", "offset": [11], "text": "list"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [8], "text": "files.newdirectorystream"}, {"type": "API", "offset": [11], "text": "list"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "files.newdirectorystream", "label": "API", "asoc": [["function replace", "list"]]}, {"span": "list", "label": "API", "asoc": []}]}
{"text": "e.g .  ,  instead of calling files.newdirectorystream just call files.list", "tokens": ["e.g", ".", "", ",", "", "instead", "of", "calling", "files.newdirectorystream", "just", "call", "files.list", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> files.newdirectorystream <extra_id_0> function replace <extra_id_5> files.list <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> files.list <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "files.newdirectorystream"}, {"type": "API", "offset": [11], "text": "files.list"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [8], "text": "files.newdirectorystream"}, {"type": "API", "offset": [11], "text": "files.list"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "files.newdirectorystream", "label": "API", "asoc": [["function replace", "files.list"]]}, {"span": "files.list", "label": "API", "asoc": []}]}
{"text": "the solution is to call flush() always after writing something to the pipe", "tokens": ["the", "solution", "is", "to", "call", "flush()", "always", "after", "writing", "something", "to", "the", "pipe", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> flush() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "flush()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "flush()", "label": "API", "asoc": []}]}
{"text": "the solution is to call flush always after writing something to the pipe", "tokens": ["the", "solution", "is", "to", "call", "flush", "always", "after", "writing", "something", "to", "the", "pipe", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> flush <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "flush"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "flush", "label": "API", "asoc": []}]}
{"text": "the solution is to call pipedwriter.flush always after writing something to the pipe", "tokens": ["the", "solution", "is", "to", "call", "pipedwriter.flush", "always", "after", "writing", "something", "to", "the", "pipe", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pipedwriter.flush <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "pipedwriter.flush"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pipedwriter.flush", "label": "API", "asoc": []}]}
{"text": "you can't wait on an object unless the current thread owns that object's monitor", "tokens": ["you", "can't", "wait", "on", "an", "object", "unless", "the", "current", "thread", "owns", "that", "object's", "monitor", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "wait"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait", "label": "API", "asoc": []}]}
{"text": "to be more precise  ,  i would use nanotime method rather than currenttimemillis", "tokens": ["to", "be", "more", "precise", "", ",", "", "i", "would", "use", "nanotime", "method", "rather", "than", "currenttimemillis", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nanotime <extra_id_0> function replace <extra_id_5> currenttimemillis <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> currenttimemillis <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "nanotime"}, {"type": "API", "offset": [14], "text": "currenttimemillis"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [10], "text": "nanotime"}, {"type": "API", "offset": [14], "text": "currenttimemillis"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "nanotime", "label": "API", "asoc": [["function replace", "currenttimemillis"]]}, {"span": "currenttimemillis", "label": "API", "asoc": []}]}
{"text": "available will always return 0 for sslsocket", "tokens": ["available", "will", "always", "return", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available", "label": "API", "asoc": []}]}
{"text": "but when interfacing with old code not yet updated to time  ,  you may need to convert", "tokens": ["but", "when", "interfacing", "with", "old", "code", "not", "yet", "updated", "to", "time", "", ",", "", "you", "may", "need", "to", "convert", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "time", "label": "API", "asoc": []}]}
{"text": "you only have one image in your relation per parseobject in your \"notica\" class as you call getfirst", "tokens": ["you", "only", "have", "one", "image", "in", "your", "relation", "per", "parseobject", "in", "your", "\"notica\"", "class", "as", "you", "call", "getfirst", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getfirst <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "getfirst"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getfirst", "label": "API", "asoc": []}]}
{"text": "see also this comparison with the preparerenderer approach", "tokens": ["see", "also", "this", "comparison", "with", "the", "preparerenderer", "approach", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> preparerenderer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "preparerenderer"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "preparerenderer", "label": "API", "asoc": []}]}
{"text": "that's how tostring is implemented for arrays", "tokens": ["that's", "how", "tostring", "is", "implemented", "for", "arrays", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "tostring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring", "label": "API", "asoc": []}]}
{"text": "you can also stop/start all listeners by calling stop / start on the registry itself  .", "tokens": ["you", "can", "also", "stop/start", "all", "listeners", "by", "calling", "stop", "/", "start", "on", "the", "registry", "itself", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> stop <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "stop"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "stop", "label": "API", "asoc": []}]}
{"text": "aslist only provides a thin wrapper around an array", "tokens": ["aslist", "only", "provides", "a", "thin", "wrapper", "around", "an", "array", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> aslist <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "aslist"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "aslist", "label": "API", "asoc": []}]}
{"text": "okay  ,  the script obviously kicks in when the clear method clears the input and leaves it empty", "tokens": ["okay", "", ",", "", "the", "script", "obviously", "kicks", "in", "when", "the", "clear", "method", "clears", "the", "input", "and", "leaves", "it", "empty", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> clear <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "clear"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "clear", "label": "API", "asoc": []}]}
{"text": "gettext will only get the inner text of an element", "tokens": ["gettext", "will", "only", "get", "the", "inner", "text", "of", "an", "element", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> gettext <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "gettext"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "gettext", "label": "API", "asoc": []}]}
{"text": "according to the file java docs the default temporary-file directory is specified by the system property java.io.tmpdir", "tokens": ["according", "to", "the", "file", "java", "docs", "the", "default", "temporary-file", "directory", "is", "specified", "by", "the", "system", "property", "java.io.tmpdir", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "file"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file", "label": "API", "asoc": []}]}
{"text": "normally the split would remove the characters matched by the regex", "tokens": ["normally", "the", "split", "would", "remove", "the", "characters", "matched", "by", "the", "regex", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> split <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "split"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "split", "label": "API", "asoc": []}]}
{"text": "a date is not a date", "tokens": ["a", "date", "is", "not", "a", "date", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> date <extra_id_0> behavior difference <extra_id_5> date <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> date <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "date"}, {"type": "API", "offset": [1], "text": "date"}], "relation": [{"type": "behavior difference", "args": [{"type": "API", "offset": [1], "text": "date"}, {"type": "API", "offset": [1], "text": "date"}]}], "event": [], "spot": ["API"], "asoc": ["behavior difference"], "spot_asoc": [{"span": "date", "label": "API", "asoc": [["behavior difference", "date"]]}, {"span": "date", "label": "API", "asoc": []}]}
{"text": "contains() may be what you're looking for  ,  or perhaps you want to put some wild cards before and after your word: e.g .  ,", "tokens": ["contains()", "may", "be", "what", "you're", "looking", "for", "", ",", "", "or", "perhaps", "you", "want", "to", "put", "some", "wild", "cards", "before", "and", "after", "your", "word:", "e.g", ".", "", ",", "", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> contains() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "contains()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "contains()", "label": "API", "asoc": []}]}
{"text": "contains may be what you're looking for  ,  or perhaps you want to put some wild cards before and after your word: e.g .  ,", "tokens": ["contains", "may", "be", "what", "you're", "looking", "for", "", ",", "", "or", "perhaps", "you", "want", "to", "put", "some", "wild", "cards", "before", "and", "after", "your", "word:", "e.g", ".", "", ",", "", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> contains <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "contains"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "contains", "label": "API", "asoc": []}]}
{"text": "string.contains may be what you're looking for  ,  or perhaps you want to put some wild cards before and after your word: e.g .  ,", "tokens": ["string.contains", "may", "be", "what", "you're", "looking", "for", "", ",", "", "or", "perhaps", "you", "want", "to", "put", "some", "wild", "cards", "before", "and", "after", "your", "word:", "e.g", ".", "", ",", "", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.contains <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "string.contains"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.contains", "label": "API", "asoc": []}]}
{"text": "it is possible to do this reasonably using some reflection ( array )  ,  but we need to provide a class as an argument", "tokens": ["it", "is", "possible", "to", "do", "this", "reasonably", "using", "some", "reflection", "(", "array", ")", "", ",", "", "but", "we", "need", "to", "provide", "a", "class", "as", "an", "argument", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> array <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "array"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "array", "label": "API", "asoc": []}]}
{"text": "here is a method that returns a set containing the entry items sorted by their value  .", "tokens": ["here", "is", "a", "method", "that", "returns", "a", "set", "containing", "the", "entry", "items", "sorted", "by", "their", "value", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> entry <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "entry"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "entry", "label": "API", "asoc": []}]}
{"text": "code example on how to cache values", "tokens": ["code", "example", "on", "how", "to", "cache", "values", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> values <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "values"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "values", "label": "API", "asoc": []}]}
{"text": "the sort() methods use a quick sort in all primitive type arrays", "tokens": ["the", "sort()", "methods", "use", "a", "quick", "sort", "in", "all", "primitive", "type", "arrays", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> sort() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "sort()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "sort()", "label": "API", "asoc": []}]}
{"text": "the sort methods use a quick sort in all primitive type arrays", "tokens": ["the", "sort", "methods", "use", "a", "quick", "sort", "in", "all", "primitive", "type", "arrays", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> sort <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "sort"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "sort", "label": "API", "asoc": []}]}
{"text": "the arrays.sort methods use a quick sort in all primitive type arrays", "tokens": ["the", "arrays.sort", "methods", "use", "a", "quick", "sort", "in", "all", "primitive", "type", "arrays", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "arrays.sort"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort", "label": "API", "asoc": []}]}
{"text": "replace next with nextline", "tokens": ["replace", "next", "with", "nextline", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next <extra_id_0> function replace <extra_id_5> nextline <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> nextline <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "next"}, {"type": "API", "offset": [3], "text": "nextline"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [1], "text": "next"}, {"type": "API", "offset": [3], "text": "nextline"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "next", "label": "API", "asoc": [["function replace", "nextline"]]}, {"span": "nextline", "label": "API", "asoc": []}]}
{"text": "if you have a multi-dimensional array  ,  you can use deeptostring() to achieve the same sort of output", "tokens": ["if", "you", "have", "a", "multi-dimensional", "array", "", ",", "", "you", "can", "use", "deeptostring()", "to", "achieve", "the", "same", "sort", "of", "output", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> deeptostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "deeptostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "deeptostring()", "label": "API", "asoc": []}]}
{"text": "if you have a multi-dimensional array  ,  you can use deeptostring to achieve the same sort of output", "tokens": ["if", "you", "have", "a", "multi-dimensional", "array", "", ",", "", "you", "can", "use", "deeptostring", "to", "achieve", "the", "same", "sort", "of", "output", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> deeptostring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "deeptostring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "deeptostring", "label": "API", "asoc": []}]}
{"text": "if you have a multi-dimensional array  ,  you can use arrays.deeptostring to achieve the same sort of output", "tokens": ["if", "you", "have", "a", "multi-dimensional", "array", "", ",", "", "you", "can", "use", "arrays.deeptostring", "to", "achieve", "the", "same", "sort", "of", "output", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.deeptostring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "arrays.deeptostring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.deeptostring", "label": "API", "asoc": []}]}
{"text": "override both hashcode and equals : hashmap maps key1  ,  key2 and key3 into the same bucket", "tokens": ["override", "both", "hashcode", "and", "equals", ":", "hashmap", "maps", "key1", "", ",", "", "key2", "and", "key3", "into", "the", "same", "bucket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hashcode <extra_id_0> function collaboration <extra_id_5> equals <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> equals <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "hashcode"}, {"type": "API", "offset": [4], "text": "equals"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [2], "text": "hashcode"}, {"type": "API", "offset": [4], "text": "equals"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "hashcode", "label": "API", "asoc": [["function collaboration", "equals"]]}, {"span": "equals", "label": "API", "asoc": []}]}
{"text": "using an array of newsinglethreadexecutor() would be fine", "tokens": ["using", "an", "array", "of", "newsinglethreadexecutor()", "would", "be", "fine", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> newsinglethreadexecutor() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "newsinglethreadexecutor()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "newsinglethreadexecutor()", "label": "API", "asoc": []}]}
{"text": "using an array of newsinglethreadexecutor would be fine", "tokens": ["using", "an", "array", "of", "newsinglethreadexecutor", "would", "be", "fine", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> newsinglethreadexecutor <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "newsinglethreadexecutor"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "newsinglethreadexecutor", "label": "API", "asoc": []}]}
{"text": "using an array of executors.newsinglethreadexecutor would be fine", "tokens": ["using", "an", "array", "of", "executors.newsinglethreadexecutor", "would", "be", "fine", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> executors.newsinglethreadexecutor <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "executors.newsinglethreadexecutor"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "executors.newsinglethreadexecutor", "label": "API", "asoc": []}]}
{"text": "you can call getstate() on and check if the state is timed_waiting", "tokens": ["you", "can", "call", "getstate()", "on", "and", "check", "if", "the", "state", "is", "timed_waiting", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getstate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "getstate()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getstate()", "label": "API", "asoc": []}]}
{"text": "you can call getstate on and check if the state is timed_waiting", "tokens": ["you", "can", "call", "getstate", "on", "and", "check", "if", "the", "state", "is", "timed_waiting", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getstate <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "getstate"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getstate", "label": "API", "asoc": []}]}
{"text": "you can call thread.getstate on and check if the state is timed_waiting", "tokens": ["you", "can", "call", "thread.getstate", "on", "and", "check", "if", "the", "state", "is", "timed_waiting", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.getstate <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "thread.getstate"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.getstate", "label": "API", "asoc": []}]}
{"text": "what you want is in which case integer is used as a type argument  .", "tokens": ["what", "you", "want", "is", "in", "which", "case", "integer", "is", "used", "as", "a", "type", "argument", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> integer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "integer"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "integer", "label": "API", "asoc": []}]}
{"text": "the user class's get set methods: then this was implemented in the run method in my server class as follows:", "tokens": ["the", "user", "class's", "get", "set", "methods:", "then", "this", "was", "implemented", "in", "the", "run", "method", "in", "my", "server", "class", "as", "follows:", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> run <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "run"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "run", "label": "API", "asoc": []}]}
{"text": "because the background color is a bound property of the buttons  ,  you don't need the subsequent calls to repaint", "tokens": ["because", "the", "background", "color", "is", "a", "bound", "property", "of", "the", "buttons", "", ",", "", "you", "don't", "need", "the", "subsequent", "calls", "to", "repaint", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "repaint"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint", "label": "API", "asoc": []}]}
{"text": "the root cause of your problem is that relative paths in io are dependent on the current working directory", "tokens": ["the", "root", "cause", "of", "your", "problem", "is", "that", "relative", "paths", "in", "io", "are", "dependent", "on", "the", "current", "working", "directory", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> io <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "io"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "io", "label": "API", "asoc": []}]}
{"text": "the javadocs states that add \"[r]eturns a biginteger whose value is (this + val).\"", "tokens": ["the", "javadocs", "states", "that", "add", "\"[r]eturns", "a", "biginteger", "whose", "value", "is", "(this", "+", "val).\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> add <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "add"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "add", "label": "API", "asoc": []}]}
{"text": "since the time zone is not stored  ,  your approach of mapping instant to timestamp with time zone is better  ,  because the sql type is really just a utc timestamp", "tokens": ["since", "the", "time", "zone", "is", "not", "stored", "", ",", "", "your", "approach", "of", "mapping", "instant", "to", "timestamp", "with", "time", "zone", "is", "better", "", ",", "", "because", "the", "sql", "type", "is", "really", "just", "a", "utc", "timestamp", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> instant <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "instant"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "instant", "label": "API", "asoc": []}]}
{"text": "the modern approach uses the time classes", "tokens": ["the", "modern", "approach", "uses", "the", "time", "classes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "time", "label": "API", "asoc": []}]}
{"text": "this is exactly as specified in the documentation: string nextline : advances this scanner past the current line and returns the input that was skipped", "tokens": ["this", "is", "exactly", "as", "specified", "in", "the", "documentation:", "string", "nextline", ":", "advances", "this", "scanner", "past", "the", "current", "line", "and", "returns", "the", "input", "that", "was", "skipped", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextline <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "nextline"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nextline", "label": "API", "asoc": []}]}
{"text": "lacking the correct encoding in a single place  ,  for example in a debug println call  ,  will give erroneous and misleading output  .", "tokens": ["lacking", "the", "correct", "encoding", "in", "a", "single", "place", "", ",", "", "for", "example", "in", "a", "debug", "println", "call", "", ",", "", "will", "give", "erroneous", "and", "misleading", "output", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> println <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "println"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "println", "label": "API", "asoc": []}]}
{"text": "the function currenttimemillis() will do that for you  ,  and it does it quite accurately  .", "tokens": ["the", "function", "currenttimemillis()", "will", "do", "that", "for", "you", "", ",", "", "and", "it", "does", "it", "quite", "accurately", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> currenttimemillis() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "currenttimemillis()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "currenttimemillis()", "label": "API", "asoc": []}]}
{"text": "the function currenttimemillis will do that for you  ,  and it does it quite accurately  .", "tokens": ["the", "function", "currenttimemillis", "will", "do", "that", "for", "you", "", ",", "", "and", "it", "does", "it", "quite", "accurately", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> currenttimemillis <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "currenttimemillis"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "currenttimemillis", "label": "API", "asoc": []}]}
{"text": "the function system.currenttimemillis will do that for you  ,  and it does it quite accurately  .", "tokens": ["the", "function", "system.currenttimemillis", "will", "do", "that", "for", "you", "", ",", "", "and", "it", "does", "it", "quite", "accurately", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.currenttimemillis <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "system.currenttimemillis"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.currenttimemillis", "label": "API", "asoc": []}]}
{"text": "from the docs: \"the iterator provided in method iterator is not guaranteed to traverse the elements of the priority queue in any particular order.\"", "tokens": ["from", "the", "docs:", "\"the", "iterator", "provided", "in", "method", "iterator", "is", "not", "guaranteed", "to", "traverse", "the", "elements", "of", "the", "priority", "queue", "in", "any", "particular", "order.\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> iterator <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "iterator"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "iterator", "label": "API", "asoc": []}]}
{"text": "logging (jul) was unnecessary from the beginning", "tokens": ["logging", "(jul)", "was", "unnecessary", "from", "the", "beginning", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> logging <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "logging"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "logging", "label": "API", "asoc": []}]}
{"text": "when two integers are divided  ,  the answer is floor automatically", "tokens": ["when", "two", "integers", "are", "divided", "", ",", "", "the", "answer", "is", "floor", "automatically", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> floor <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "floor"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "floor", "label": "API", "asoc": []}]}
{"text": "in other words  ,  this method returns a string equal to the value of: to achieve what you want  ,  rather use tostring()  .", "tokens": ["in", "other", "words", "", ",", "", "this", "method", "returns", "a", "string", "equal", "to", "the", "value", "of:", "to", "achieve", "what", "you", "want", "", ",", "", "rather", "use", "tostring()", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [26], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "in other words  ,  this method returns a string equal to the value of: to achieve what you want  ,  rather use tostring  .", "tokens": ["in", "other", "words", "", ",", "", "this", "method", "returns", "a", "string", "equal", "to", "the", "value", "of:", "to", "achieve", "what", "you", "want", "", ",", "", "rather", "use", "tostring", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [26], "text": "tostring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring", "label": "API", "asoc": []}]}
{"text": "in other words  ,  this method returns a string equal to the value of: to achieve what you want  ,  rather use arrays.tostring  .", "tokens": ["in", "other", "words", "", ",", "", "this", "method", "returns", "a", "string", "equal", "to", "the", "value", "of:", "to", "achieve", "what", "you", "want", "", ",", "", "rather", "use", "arrays.tostring", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.tostring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [26], "text": "arrays.tostring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.tostring", "label": "API", "asoc": []}]}
{"text": "in this example  ,  answers is going to contain a bunch of futures which will return nulls (see definition of callable()", "tokens": ["in", "this", "example", "", ",", "", "answers", "is", "going", "to", "contain", "a", "bunch", "of", "futures", "which", "will", "return", "nulls", "(see", "definition", "of", "callable()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> callable() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "callable()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "callable()", "label": "API", "asoc": []}]}
{"text": "in this example  ,  answers is going to contain a bunch of futures which will return nulls (see definition of callable", "tokens": ["in", "this", "example", "", ",", "", "answers", "is", "going", "to", "contain", "a", "bunch", "of", "futures", "which", "will", "return", "nulls", "(see", "definition", "of", "callable", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> callable <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "callable"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "callable", "label": "API", "asoc": []}]}
{"text": "in this example  ,  answers is going to contain a bunch of futures which will return nulls (see definition of executors.callable", "tokens": ["in", "this", "example", "", ",", "", "answers", "is", "going", "to", "contain", "a", "bunch", "of", "futures", "which", "will", "return", "nulls", "(see", "definition", "of", "executors.callable", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> executors.callable <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "executors.callable"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "executors.callable", "label": "API", "asoc": []}]}
{"text": "don't use the random method in a painting method", "tokens": ["don't", "use", "the", "random", "method", "in", "a", "painting", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "random"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "random", "label": "API", "asoc": []}]}
{"text": "invoking pack on the enclosing window will cause it to be \"sized to fit the preferred size and layouts of its subcomponents.\"", "tokens": ["invoking", "pack", "on", "the", "enclosing", "window", "will", "cause", "it", "to", "be", "\"sized", "to", "fit", "the", "preferred", "size", "and", "layouts", "of", "its", "subcomponents.\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pack <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "pack"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pack", "label": "API", "asoc": []}]}
{"text": "if you do prints state states thread state for a waiting thread", "tokens": ["if", "you", "do", "prints", "state", "states", "thread", "state", "for", "a", "waiting", "thread", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> state <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "state"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "state", "label": "API", "asoc": []}]}
{"text": "the easiest way is probably to use replaceall() : this will leave all letters a intact and will replace all other characters with question marks", "tokens": ["the", "easiest", "way", "is", "probably", "to", "use", "replaceall()", ":", "this", "will", "leave", "all", "letters", "a", "intact", "and", "will", "replace", "all", "other", "characters", "with", "question", "marks", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replaceall() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "replaceall()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replaceall()", "label": "API", "asoc": []}]}
{"text": "the easiest way is probably to use replaceall : this will leave all letters a intact and will replace all other characters with question marks", "tokens": ["the", "easiest", "way", "is", "probably", "to", "use", "replaceall", ":", "this", "will", "leave", "all", "letters", "a", "intact", "and", "will", "replace", "all", "other", "characters", "with", "question", "marks", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replaceall <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "replaceall"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replaceall", "label": "API", "asoc": []}]}
{"text": "the easiest way is probably to use string.replaceall : this will leave all letters a intact and will replace all other characters with question marks", "tokens": ["the", "easiest", "way", "is", "probably", "to", "use", "string.replaceall", ":", "this", "will", "leave", "all", "letters", "a", "intact", "and", "will", "replace", "all", "other", "characters", "with", "question", "marks", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.replaceall <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "string.replaceall"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.replaceall", "label": "API", "asoc": []}]}
{"text": "in tostring you can put whatever information is interesting - for example all fields", "tokens": ["in", "tostring", "you", "can", "put", "whatever", "information", "is", "interesting", "-", "for", "example", "all", "fields", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "tostring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring", "label": "API", "asoc": []}]}
{"text": "by looking at the source code of the plainview#paint method  ,  i saw that the fontmetrics are used  ,  and those you can easily override in the jtextarea", "tokens": ["by", "looking", "at", "the", "source", "code", "of", "the", "plainview#paint", "method", "", ",", "", "i", "saw", "that", "the", "fontmetrics", "are", "used", "", ",", "", "and", "those", "you", "can", "easily", "override", "in", "the", "jtextarea", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> plainview#paint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "plainview#paint"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "plainview#paint", "label": "API", "asoc": []}]}
{"text": "* for any reason  ,  if you have to stick to java 6 or java 7  ,  you can use threeten-backport which backports most of the time functionality to java 6 &amp; 7", "tokens": ["*", "for", "any", "reason", "", ",", "", "if", "you", "have", "to", "stick", "to", "java", "6", "or", "java", "7", "", ",", "", "you", "can", "use", "threeten-backport", "which", "backports", "most", "of", "the", "time", "functionality", "to", "java", "6", "&amp;", "7", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [30], "text": "time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "time", "label": "API", "asoc": []}]}
{"text": "for example overriding the paint function", "tokens": ["for", "example", "overriding", "the", "paint", "function", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> paint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "paint"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "paint", "label": "API", "asoc": []}]}
{"text": "since you can use time  ,  the modern java date and time api  ,  you should not wish to apply the old-fashioned and poorly designed timestamp class too", "tokens": ["since", "you", "can", "use", "time", "", ",", "", "the", "modern", "java", "date", "and", "time", "api", "", ",", "", "you", "should", "not", "wish", "to", "apply", "the", "old-fashioned", "and", "poorly", "designed", "timestamp", "class", "too", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "time", "label": "API", "asoc": []}]}
{"text": "in general if the jvm is about to throw an outofmemoryerror  ,  calling gc() won't prevent it", "tokens": ["in", "general", "if", "the", "jvm", "is", "about", "to", "throw", "an", "outofmemoryerror", "", ",", "", "calling", "gc()", "won't", "prevent", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> gc() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "gc()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "gc()", "label": "API", "asoc": []}]}
{"text": "in general if the jvm is about to throw an outofmemoryerror  ,  calling gc won't prevent it", "tokens": ["in", "general", "if", "the", "jvm", "is", "about", "to", "throw", "an", "outofmemoryerror", "", ",", "", "calling", "gc", "won't", "prevent", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> gc <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "gc"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "gc", "label": "API", "asoc": []}]}
{"text": "in general if the jvm is about to throw an outofmemoryerror  ,  calling system.gc won't prevent it", "tokens": ["in", "general", "if", "the", "jvm", "is", "about", "to", "throw", "an", "outofmemoryerror", "", ",", "", "calling", "system.gc", "won't", "prevent", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.gc <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "system.gc"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.gc", "label": "API", "asoc": []}]}
{"text": "therefore find returns the same instance when called from the same transaction", "tokens": ["therefore", "find", "returns", "the", "same", "instance", "when", "called", "from", "the", "same", "transaction", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> find <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "find"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "find", "label": "API", "asoc": []}]}
{"text": "before attempting to write to a file  ,  you can check if the file is writable by your java application using canwrite()", "tokens": ["before", "attempting", "to", "write", "to", "a", "file", "", ",", "", "you", "can", "check", "if", "the", "file", "is", "writable", "by", "your", "java", "application", "using", "canwrite()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> canwrite() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "canwrite()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "canwrite()", "label": "API", "asoc": []}]}
{"text": "before attempting to write to a file  ,  you can check if the file is writable by your java application using canwrite", "tokens": ["before", "attempting", "to", "write", "to", "a", "file", "", ",", "", "you", "can", "check", "if", "the", "file", "is", "writable", "by", "your", "java", "application", "using", "canwrite", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> canwrite <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "canwrite"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "canwrite", "label": "API", "asoc": []}]}
{"text": "before attempting to write to a file  ,  you can check if the file is writable by your java application using file.canwrite", "tokens": ["before", "attempting", "to", "write", "to", "a", "file", "", ",", "", "you", "can", "check", "if", "the", "file", "is", "writable", "by", "your", "java", "application", "using", "file.canwrite", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.canwrite <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "file.canwrite"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.canwrite", "label": "API", "asoc": []}]}
{"text": "one improvement i'd make is to cut out the unnecessary map operation and do the lookup in the collector:", "tokens": ["one", "improvement", "i'd", "make", "is", "to", "cut", "out", "the", "unnecessary", "map", "operation", "and", "do", "the", "lookup", "in", "the", "collector:", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> map <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "map"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "map", "label": "API", "asoc": []}]}
{"text": "quote the separate column names and use replace() to escape the same quote inside the column name  .", "tokens": ["quote", "the", "separate", "column", "names", "and", "use", "replace()", "to", "escape", "the", "same", "quote", "inside", "the", "column", "name", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "replace()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replace()", "label": "API", "asoc": []}]}
{"text": "quote the separate column names and use replace to escape the same quote inside the column name  .", "tokens": ["quote", "the", "separate", "column", "names", "and", "use", "replace", "to", "escape", "the", "same", "quote", "inside", "the", "column", "name", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replace <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "replace"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replace", "label": "API", "asoc": []}]}
{"text": "quote the separate column names and use string.replace to escape the same quote inside the column name  .", "tokens": ["quote", "the", "separate", "column", "names", "and", "use", "string.replace", "to", "escape", "the", "same", "quote", "inside", "the", "column", "name", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.replace <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "string.replace"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.replace", "label": "API", "asoc": []}]}
{"text": "you haven't called next on your iterator  ,  so it's not referring to the first item yet", "tokens": ["you", "haven't", "called", "next", "on", "your", "iterator", "", ",", "", "so", "it's", "not", "referring", "to", "the", "first", "item", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "next"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "next", "label": "API", "asoc": []}]}
{"text": "if you choose to sort the array programmatically at run time  ,  make sure you use the appropriate (sorted) index when calling getstring etc", "tokens": ["if", "you", "choose", "to", "sort", "the", "array", "programmatically", "at", "run", "time", "", ",", "", "make", "sure", "you", "use", "the", "appropriate", "(sorted)", "index", "when", "calling", "getstring", "etc", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getstring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [24], "text": "getstring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getstring", "label": "API", "asoc": []}]}
{"text": "it's also recommended  ,  after each write  ,  to use flush()  ,  on both server and client", "tokens": ["it's", "also", "recommended", "", ",", "", "after", "each", "write", "", ",", "", "to", "use", "flush()", "", ",", "", "on", "both", "server", "and", "client", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> flush() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "flush()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "flush()", "label": "API", "asoc": []}]}
{"text": "it's also recommended  ,  after each write  ,  to use flush  ,  on both server and client", "tokens": ["it's", "also", "recommended", "", ",", "", "after", "each", "write", "", ",", "", "to", "use", "flush", "", ",", "", "on", "both", "server", "and", "client", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> flush <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "flush"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "flush", "label": "API", "asoc": []}]}
{"text": "it's also recommended  ,  after each write  ,  to use writer.flush  ,  on both server and client", "tokens": ["it's", "also", "recommended", "", ",", "", "after", "each", "write", "", ",", "", "to", "use", "writer.flush", "", ",", "", "on", "both", "server", "and", "client", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> writer.flush <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "writer.flush"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "writer.flush", "label": "API", "asoc": []}]}
{"text": "you can force it via calling intern as you have already found out", "tokens": ["you", "can", "force", "it", "via", "calling", "intern", "as", "you", "have", "already", "found", "out", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> intern <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "intern"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "intern", "label": "API", "asoc": []}]}
{"text": "if another thread invokes parse before the completion of the first invocation  ,  it will clear the calendar  ,  but the other invocation will expect it to be populated with intermediate results of the calculation", "tokens": ["if", "another", "thread", "invokes", "parse", "before", "the", "completion", "of", "the", "first", "invocation", "", ",", "", "it", "will", "clear", "the", "calendar", "", ",", "", "but", "the", "other", "invocation", "will", "expect", "it", "to", "be", "populated", "with", "intermediate", "results", "of", "the", "calculation", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> parse <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "parse"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "parse", "label": "API", "asoc": []}]}
{"text": "call next to advance to the first item first  ,  then call remove  .", "tokens": ["call", "next", "to", "advance", "to", "the", "first", "item", "first", "", ",", "", "then", "call", "remove", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next <extra_id_0> logic constraint <extra_id_5> remove <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> remove <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "next"}, {"type": "API", "offset": [14], "text": "remove"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [1], "text": "next"}, {"type": "API", "offset": [14], "text": "remove"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "next", "label": "API", "asoc": [["logic constraint", "remove"]]}, {"span": "remove", "label": "API", "asoc": []}]}
{"text": "verifyerror can be the result when you have compiled against a different library than you are using at runtime", "tokens": ["verifyerror", "can", "be", "the", "result", "when", "you", "have", "compiled", "against", "a", "different", "library", "than", "you", "are", "using", "at", "runtime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> verifyerror <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "verifyerror"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "verifyerror", "label": "API", "asoc": []}]}
{"text": "in java  ,  the equals method that is inherited from object is: in other words  ,  the parameter must be of type object", "tokens": ["in", "java", "", ",", "", "the", "equals", "method", "that", "is", "inherited", "from", "object", "is:", "in", "other", "words", "", ",", "", "the", "parameter", "must", "be", "of", "type", "object", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "equals"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "equals", "label": "API", "asoc": []}]}
{"text": "one way is to automatically add logging to all places which call sleep using a java agent", "tokens": ["one", "way", "is", "to", "automatically", "add", "logging", "to", "all", "places", "which", "call", "sleep", "using", "a", "java", "agent", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> sleep <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "sleep"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "sleep", "label": "API", "asoc": []}]}
{"text": "step3: iterate the list  ,  write a conditions with a use the getname() method to compare and the name and your input  .", "tokens": ["step3:", "iterate", "the", "list", "", ",", "", "write", "a", "conditions", "with", "a", "use", "the", "getname()", "method", "to", "compare", "and", "the", "name", "and", "your", "input", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getname() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "getname()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getname()", "label": "API", "asoc": []}]}
{"text": "step3: iterate the list  ,  write a conditions with a use the getname method to compare and the name and your input  .", "tokens": ["step3:", "iterate", "the", "list", "", ",", "", "write", "a", "conditions", "with", "a", "use", "the", "getname", "method", "to", "compare", "and", "the", "name", "and", "your", "input", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getname <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "getname"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getname", "label": "API", "asoc": []}]}
{"text": "step3: iterate the list  ,  write a conditions with a use the file.getname method to compare and the name and your input  .", "tokens": ["step3:", "iterate", "the", "list", "", ",", "", "write", "a", "conditions", "with", "a", "use", "the", "file.getname", "method", "to", "compare", "and", "the", "name", "and", "your", "input", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.getname <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "file.getname"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.getname", "label": "API", "asoc": []}]}
{"text": "i reference this all the time  ,  and it looks like this functionallity is used in eclipse when generating the hashcode method for a given class", "tokens": ["i", "reference", "this", "all", "the", "time", "", ",", "", "and", "it", "looks", "like", "this", "functionallity", "is", "used", "in", "eclipse", "when", "generating", "the", "hashcode", "method", "for", "a", "given", "class", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hashcode <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "hashcode"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "hashcode", "label": "API", "asoc": []}]}
{"text": "when you pack the enclosing window  ,  it will be resized to fit the text area", "tokens": ["when", "you", "pack", "the", "enclosing", "window", "", ",", "", "it", "will", "be", "resized", "to", "fit", "the", "text", "area", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pack <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "pack"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pack", "label": "API", "asoc": []}]}
{"text": "the correct approach would be assuming this iterator supports the remove operation  .", "tokens": ["the", "correct", "approach", "would", "be", "assuming", "this", "iterator", "supports", "the", "remove", "operation", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "remove"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove", "label": "API", "asoc": []}]}
{"text": "it will also catch exceptions thrown by tostring and report these failures  .", "tokens": ["it", "will", "also", "catch", "exceptions", "thrown", "by", "tostring", "and", "report", "these", "failures", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "tostring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring", "label": "API", "asoc": []}]}
{"text": "the following is compact and avoids the loop in your example code (and gives you nice commas): however  ,  as others have pointed out  ,  if you don't have sensible tostring methods", "tokens": ["the", "following", "is", "compact", "and", "avoids", "the", "loop", "in", "your", "example", "code", "(and", "gives", "you", "nice", "commas):", "however", "", ",", "", "as", "others", "have", "pointed", "out", "", ",", "", "if", "you", "don't", "have", "sensible", "tostring", "methods", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [34], "text": "tostring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring", "label": "API", "asoc": []}]}
{"text": "when your editor concludes  ,  the table's editingstopped method collects the new value via getcelleditorvalue and uses it to setvalueat in the model", "tokens": ["when", "your", "editor", "concludes", "", ",", "", "the", "table's", "editingstopped", "method", "collects", "the", "new", "value", "via", "getcelleditorvalue", "and", "uses", "it", "to", "setvalueat", "in", "the", "model", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> editingstopped <extra_id_0> logic constraint <extra_id_5> getcelleditorvalue <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> getcelleditorvalue <extra_id_1> <extra_id_0> API <extra_id_5> setvalueat <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "editingstopped"}, {"type": "API", "offset": [16], "text": "getcelleditorvalue"}, {"type": "API", "offset": [21], "text": "setvalueat"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [9], "text": "editingstopped"}, {"type": "API", "offset": [16], "text": "getcelleditorvalue"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "editingstopped", "label": "API", "asoc": [["logic constraint", "getcelleditorvalue"]]}, {"span": "getcelleditorvalue", "label": "API", "asoc": []}, {"span": "setvalueat", "label": "API", "asoc": []}]}
{"text": "how to ensure that my tasks are responsive to interruption when i call cancel()  ?  calling future.cancel(...) will stop the task it has not been run yet", "tokens": ["how", "to", "ensure", "that", "my", "tasks", "are", "responsive", "to", "interruption", "when", "i", "call", "cancel()", "", "?", "", "calling", "future.cancel(...)", "will", "stop", "the", "task", "it", "has", "not", "been", "run", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> cancel() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "cancel()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "cancel()", "label": "API", "asoc": []}]}
{"text": "how to ensure that my tasks are responsive to interruption when i call cancel  ?  calling future.cancel(...) will stop the task it has not been run yet", "tokens": ["how", "to", "ensure", "that", "my", "tasks", "are", "responsive", "to", "interruption", "when", "i", "call", "cancel", "", "?", "", "calling", "future.cancel(...)", "will", "stop", "the", "task", "it", "has", "not", "been", "run", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> cancel <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "cancel"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "cancel", "label": "API", "asoc": []}]}
{"text": "how to ensure that my tasks are responsive to interruption when i call future.cancel  ?  calling future.cancel(...) will stop the task it has not been run yet", "tokens": ["how", "to", "ensure", "that", "my", "tasks", "are", "responsive", "to", "interruption", "when", "i", "call", "future.cancel", "", "?", "", "calling", "future.cancel(...)", "will", "stop", "the", "task", "it", "has", "not", "been", "run", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> future.cancel <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "future.cancel"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "future.cancel", "label": "API", "asoc": []}]}
{"text": "this is because array objects in java do not have a custom tostring method  ,  they inherit object's", "tokens": ["this", "is", "because", "array", "objects", "in", "java", "do", "not", "have", "a", "custom", "tostring", "method", "", ",", "", "they", "inherit", "object's", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "tostring"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring", "label": "API", "asoc": []}]}
{"text": "gc() ; is not guaranteed to force a garbage collection", "tokens": ["gc()", ";", "is", "not", "guaranteed", "to", "force", "a", "garbage", "collection", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> gc() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "gc()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "gc()", "label": "API", "asoc": []}]}
{"text": "gc ; is not guaranteed to force a garbage collection", "tokens": ["gc", ";", "is", "not", "guaranteed", "to", "force", "a", "garbage", "collection", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> gc <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "gc"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "gc", "label": "API", "asoc": []}]}
{"text": "system.gc ; is not guaranteed to force a garbage collection", "tokens": ["system.gc", ";", "is", "not", "guaranteed", "to", "force", "a", "garbage", "collection", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.gc <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "system.gc"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.gc", "label": "API", "asoc": []}]}
{"text": "you almost always want to use equals()", "tokens": ["you", "almost", "always", "want", "to", "use", "equals()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "equals()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": []}]}
{"text": "you almost always want to use equals", "tokens": ["you", "almost", "always", "want", "to", "use", "equals", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "equals"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "equals", "label": "API", "asoc": []}]}
{"text": "you almost always want to use objects.equals", "tokens": ["you", "almost", "always", "want", "to", "use", "objects.equals", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> objects.equals <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "objects.equals"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "objects.equals", "label": "API", "asoc": []}]}
{"text": "increase your run time to about a minute  ,  (n=100000000) or put some heavy computations in the compute", "tokens": ["increase", "your", "run", "time", "to", "about", "a", "minute", "", ",", "", "(n=100000000)", "or", "put", "some", "heavy", "computations", "in", "the", "compute", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> compute <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "compute"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "compute", "label": "API", "asoc": []}]}
{"text": "instead the jvm ends when no more non-daemon threads are running or when exit() is called", "tokens": ["instead", "the", "jvm", "ends", "when", "no", "more", "non-daemon", "threads", "are", "running", "or", "when", "exit()", "is", "called", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> exit() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "exit()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "exit()", "label": "API", "asoc": []}]}
{"text": "instead the jvm ends when no more non-daemon threads are running or when exit is called", "tokens": ["instead", "the", "jvm", "ends", "when", "no", "more", "non-daemon", "threads", "are", "running", "or", "when", "exit", "is", "called", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> exit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "exit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "exit", "label": "API", "asoc": []}]}
{"text": "instead the jvm ends when no more non-daemon threads are running or when system.exit is called", "tokens": ["instead", "the", "jvm", "ends", "when", "no", "more", "non-daemon", "threads", "are", "running", "or", "when", "system.exit", "is", "called", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.exit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "system.exit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.exit", "label": "API", "asoc": []}]}
{"text": "your method would look like this for better compatibility with the inputstream abstract class you may want to override all its methods in your class  .", "tokens": ["your", "method", "would", "look", "like", "this", "for", "better", "compatibility", "with", "the", "inputstream", "abstract", "class", "you", "may", "want", "to", "override", "all", "its", "methods", "in", "your", "class", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> inputstream <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "inputstream"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "inputstream", "label": "API", "asoc": []}]}
{"text": "nanotime() has an arbitrary start point; it's not unix epoch", "tokens": ["nanotime()", "has", "an", "arbitrary", "start", "point;", "it's", "not", "unix", "epoch", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nanotime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "nanotime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nanotime()", "label": "API", "asoc": []}]}
{"text": "nanotime has an arbitrary start point; it's not unix epoch", "tokens": ["nanotime", "has", "an", "arbitrary", "start", "point;", "it's", "not", "unix", "epoch", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nanotime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "nanotime"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nanotime", "label": "API", "asoc": []}]}
{"text": "system.nanotime has an arbitrary start point; it's not unix epoch", "tokens": ["system.nanotime", "has", "an", "arbitrary", "start", "point;", "it's", "not", "unix", "epoch", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.nanotime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "system.nanotime"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.nanotime", "label": "API", "asoc": []}]}
{"text": "to test beforehand if the string contains certain character(s)  ,  just use contains()", "tokens": ["to", "test", "beforehand", "if", "the", "string", "contains", "certain", "character(s)", "", ",", "", "just", "use", "contains()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> contains() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "contains()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "contains()", "label": "API", "asoc": []}]}
{"text": "to test beforehand if the string contains certain character(s)  ,  just use contains", "tokens": ["to", "test", "beforehand", "if", "the", "string", "contains", "certain", "character(s)", "", ",", "", "just", "use", "contains", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> contains <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "contains"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "contains", "label": "API", "asoc": []}]}
{"text": "to test beforehand if the string contains certain character(s)  ,  just use string.contains", "tokens": ["to", "test", "beforehand", "if", "the", "string", "contains", "certain", "character(s)", "", ",", "", "just", "use", "string.contains", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.contains <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "string.contains"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.contains", "label": "API", "asoc": []}]}
{"text": "for examples in the java api  ,  see checkedset and similar  .", "tokens": ["for", "examples", "in", "the", "java", "api", "", ",", "", "see", "checkedset", "and", "similar", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> checkedset <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "checkedset"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "checkedset", "label": "API", "asoc": []}]}
{"text": "you create a mypanel object and invoke callfilling on it to set the values in the tablemodel", "tokens": ["you", "create", "a", "mypanel", "object", "and", "invoke", "callfilling", "on", "it", "to", "set", "the", "values", "in", "the", "tablemodel", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> callfilling <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "callfilling"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "callfilling", "label": "API", "asoc": []}]}
{"text": "as it is mentioned in the official documentation  ,  the key for solving this problem is to use the startafter method", "tokens": ["as", "it", "is", "mentioned", "in", "the", "official", "documentation", "", ",", "", "the", "key", "for", "solving", "this", "problem", "is", "to", "use", "the", "startafter", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> startafter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "startafter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "startafter", "label": "API", "asoc": []}]}
{"text": "when you look into it  ,  indexof() also has a best case of o(n+m) and a worst case of o(nm)", "tokens": ["when", "you", "look", "into", "it", "", ",", "", "indexof()", "also", "has", "a", "best", "case", "of", "o(n+m)", "and", "a", "worst", "case", "of", "o(nm)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> indexof() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "indexof()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "indexof()", "label": "API", "asoc": []}]}
{"text": "when you look into it  ,  indexof also has a best case of o(n+m) and a worst case of o(nm)", "tokens": ["when", "you", "look", "into", "it", "", ",", "", "indexof", "also", "has", "a", "best", "case", "of", "o(n+m)", "and", "a", "worst", "case", "of", "o(nm)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> indexof <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "indexof"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "indexof", "label": "API", "asoc": []}]}
{"text": "when you look into it  ,  string.indexof also has a best case of o(n+m) and a worst case of o(nm)", "tokens": ["when", "you", "look", "into", "it", "", ",", "", "string.indexof", "also", "has", "a", "best", "case", "of", "o(n+m)", "and", "a", "worst", "case", "of", "o(nm)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.indexof <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "string.indexof"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.indexof", "label": "API", "asoc": []}]}
{"text": "you only want to next your reader once  ,  unless it has a lot of the same toke nrepeated again and again  .", "tokens": ["you", "only", "want", "to", "next", "your", "reader", "once", "", ",", "", "unless", "it", "has", "a", "lot", "of", "the", "same", "toke", "nrepeated", "again", "and", "again", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "next"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "next", "label": "API", "asoc": []}]}
{"text": "i'd recommend using computeifabsent  ,  to always ensure retrieving a list from the map", "tokens": ["i'd", "recommend", "using", "computeifabsent", "", ",", "", "to", "always", "ensure", "retrieving", "a", "list", "from", "the", "map", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> computeifabsent <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "computeifabsent"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "computeifabsent", "label": "API", "asoc": []}]}
{"text": "remove() is safe  ,  you can use it like this: note that remove() is the only safe way to modify a collection during iteration;", "tokens": ["remove()", "is", "safe", "", ",", "", "you", "can", "use", "it", "like", "this:", "note", "that", "remove()", "is", "the", "only", "safe", "way", "to", "modify", "a", "collection", "during", "iteration;", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "remove()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove()", "label": "API", "asoc": []}]}
{"text": "remove is safe  ,  you can use it like this: note that remove is the only safe way to modify a collection during iteration;", "tokens": ["remove", "is", "safe", "", ",", "", "you", "can", "use", "it", "like", "this:", "note", "that", "remove", "is", "the", "only", "safe", "way", "to", "modify", "a", "collection", "during", "iteration;", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "remove"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove", "label": "API", "asoc": []}]}
{"text": "iterator.remove is safe  ,  you can use it like this: note that iterator.remove is the only safe way to modify a collection during iteration;", "tokens": ["iterator.remove", "is", "safe", "", ",", "", "you", "can", "use", "it", "like", "this:", "note", "that", "iterator.remove", "is", "the", "only", "safe", "way", "to", "modify", "a", "collection", "during", "iteration;", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> iterator.remove <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "iterator.remove"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "iterator.remove", "label": "API", "asoc": []}]}
{"text": "if you want to join a collection of strings you can use the new join() method", "tokens": ["if", "you", "want", "to", "join", "a", "collection", "of", "strings", "you", "can", "use", "the", "new", "join()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> join() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "join()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "join()", "label": "API", "asoc": []}]}
{"text": "if you want to join a collection of strings you can use the new join method", "tokens": ["if", "you", "want", "to", "join", "a", "collection", "of", "strings", "you", "can", "use", "the", "new", "join", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> join <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "join"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "join", "label": "API", "asoc": []}]}
{"text": "if you want to join a collection of strings you can use the new string.join method", "tokens": ["if", "you", "want", "to", "join", "a", "collection", "of", "strings", "you", "can", "use", "the", "new", "string.join", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.join <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "string.join"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.join", "label": "API", "asoc": []}]}
{"text": "you'll notice that the format line has \"%s%\" declared in it  ,  so i don't see how the lecturer could possibly think that was faster", "tokens": ["you'll", "notice", "that", "the", "format", "line", "has", "\"%s%\"", "declared", "in", "it", "", ",", "", "so", "i", "don't", "see", "how", "the", "lecturer", "could", "possibly", "think", "that", "was", "faster", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> format <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "format"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "format", "label": "API", "asoc": []}]}
{"text": "to compare the values of strings  ,  use the equals method", "tokens": ["to", "compare", "the", "values", "of", "strings", "", ",", "", "use", "the", "equals", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "equals"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "equals", "label": "API", "asoc": []}]}
{"text": "for example  ,  when the objects aren't initialized  ,  no print will be made and no exceptions will be thrown", "tokens": ["for", "example", "", ",", "", "when", "the", "objects", "aren't", "initialized", "", ",", "", "no", "print", "will", "be", "made", "and", "no", "exceptions", "will", "be", "thrown", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> print <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "print"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "print", "label": "API", "asoc": []}]}
{"text": "in your case that means that you are closing in", "tokens": ["in", "your", "case", "that", "means", "that", "you", "are", "closing", "in", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> in <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "in"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "in", "label": "API", "asoc": []}]}
{"text": "and then you are creating a second scanner to read from the (now closed) in", "tokens": ["and", "then", "you", "are", "creating", "a", "second", "scanner", "to", "read", "from", "the", "(now", "closed)", "in", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> in <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "in"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "in", "label": "API", "asoc": []}]}
{"text": "you could use the arraycopy function to copy the data  ,  but you cannot avoid creating the new array  .", "tokens": ["you", "could", "use", "the", "arraycopy", "function", "to", "copy", "the", "data", "", ",", "", "but", "you", "cannot", "avoid", "creating", "the", "new", "array", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arraycopy <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "arraycopy"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arraycopy", "label": "API", "asoc": []}]}
{"text": "the paintcomponent method handles all of the \"painting\"", "tokens": ["the", "paintcomponent", "method", "handles", "all", "of", "the", "\"painting\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> paintcomponent <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "paintcomponent"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "paintcomponent", "label": "API", "asoc": []}]}
{"text": "every time you can to change the appearance of your jpanel  ,  you must call repaint", "tokens": ["every", "time", "you", "can", "to", "change", "the", "appearance", "of", "your", "jpanel", "", ",", "", "you", "must", "call", "repaint", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "repaint"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint", "label": "API", "asoc": []}]}
{"text": "then add these object to the result list add(o)", "tokens": ["then", "add", "these", "object", "to", "the", "result", "list", "add(o)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> add(o) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "add(o)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "add(o)", "label": "API", "asoc": []}]}
{"text": "then add these object to the result list add", "tokens": ["then", "add", "these", "object", "to", "the", "result", "list", "add", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> add <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "add"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "add", "label": "API", "asoc": []}]}
{"text": "then add these object to the result list result.add", "tokens": ["then", "add", "these", "object", "to", "the", "result", "list", "result.add", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> result.add <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "result.add"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "result.add", "label": "API", "asoc": []}]}
{"text": "the class for that in time is localdate", "tokens": ["the", "class", "for", "that", "in", "time", "is", "localdate", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> time <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "time"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "time", "label": "API", "asoc": []}]}
{"text": "to this  ,  just call new raw(byte[])  .", "tokens": ["to", "this", "", ",", "", "just", "call", "new", "raw(byte[])", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> raw(byte[]) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "raw(byte[])"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "raw(byte[])", "label": "API", "asoc": []}]}
{"text": "to this  ,  just call new raw  .", "tokens": ["to", "this", "", ",", "", "just", "call", "new", "raw", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> raw <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "raw"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "raw", "label": "API", "asoc": []}]}
{"text": "to this  ,  just call new oracle.sql.raw  .", "tokens": ["to", "this", "", ",", "", "just", "call", "new", "oracle.sql.raw", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> oracle.sql.raw <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "oracle.sql.raw"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "oracle.sql.raw", "label": "API", "asoc": []}]}
{"text": "note the apache commons isempty() method  ,  which performs this check concisely  .", "tokens": ["note", "the", "apache", "commons", "isempty()", "method", "", ",", "", "which", "performs", "this", "check", "concisely", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> isempty() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "isempty()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "isempty()", "label": "API", "asoc": []}]}
{"text": "note the apache commons isempty method  ,  which performs this check concisely  .", "tokens": ["note", "the", "apache", "commons", "isempty", "method", "", ",", "", "which", "performs", "this", "check", "concisely", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> isempty <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "isempty"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "isempty", "label": "API", "asoc": []}]}
{"text": "note the apache commons stringutils.isempty method  ,  which performs this check concisely  .", "tokens": ["note", "the", "apache", "commons", "stringutils.isempty", "method", "", ",", "", "which", "performs", "this", "check", "concisely", "", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> stringutils.isempty <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "stringutils.isempty"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "stringutils.isempty", "label": "API", "asoc": []}]}
{"text": "to build the file you will have to use the method createfile()", "tokens": ["to", "build", "the", "file", "you", "will", "have", "to", "use", "the", "method", "createfile()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> createfile() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "createfile()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "createfile()", "label": "API", "asoc": []}]}
{"text": "to produce the file you will have to use the method createfile()", "tokens": ["to", "produce", "the", "file", "you", "will", "have", "to", "use", "the", "method", "createfile()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> createfile() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "createfile()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "createfile()", "label": "API", "asoc": []}]}
{"text": "to construct the file you will have to use the method createfile()", "tokens": ["to", "construct", "the", "file", "you", "will", "have", "to", "use", "the", "method", "createfile()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> createfile() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "createfile()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "createfile()", "label": "API", "asoc": []}]}
{"text": "to generate the file you will have to use the method createfile()", "tokens": ["to", "generate", "the", "file", "you", "will", "have", "to", "use", "the", "method", "createfile()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> createfile() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "createfile()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "createfile()", "label": "API", "asoc": []}]}
{"text": "to establish the file you will have to use the method createfile()", "tokens": ["to", "establish", "the", "file", "you", "will", "have", "to", "use", "the", "method", "createfile()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> createfile() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "createfile()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "createfile()", "label": "API", "asoc": []}]}
{"text": "to make the file you will have to use the method createfile()", "tokens": ["to", "make", "the", "file", "you", "will", "have", "to", "use", "the", "method", "createfile()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> createfile() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "createfile()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "createfile()", "label": "API", "asoc": []}]}
{"text": "to obtain the file you will have to use the method createfile()", "tokens": ["to", "obtain", "the", "file", "you", "will", "have", "to", "use", "the", "method", "createfile()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> createfile() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "createfile()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "createfile()", "label": "API", "asoc": []}]}
{"text": "to reconstitute the file you will have to use the method createfile()", "tokens": ["to", "reconstitute", "the", "file", "you", "will", "have", "to", "use", "the", "method", "createfile()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> createfile() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "createfile()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "createfile()", "label": "API", "asoc": []}]}
{"text": "to compose the file you will have to use the method createfile()", "tokens": ["to", "compose", "the", "file", "you", "will", "have", "to", "use", "the", "method", "createfile()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> createfile() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "createfile()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "createfile()", "label": "API", "asoc": []}]}
{"text": "to instantiate the file you will have to use the method createfile()", "tokens": ["to", "instantiate", "the", "file", "you", "will", "have", "to", "use", "the", "method", "createfile()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> createfile() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "createfile()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "createfile()", "label": "API", "asoc": []}]}
{"text": "to implement the file you will have to use the method createfile()", "tokens": ["to", "implement", "the", "file", "you", "will", "have", "to", "use", "the", "method", "createfile()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> createfile() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "createfile()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "createfile()", "label": "API", "asoc": []}]}
{"text": "to get the file you will have to use the method createfile()", "tokens": ["to", "get", "the", "file", "you", "will", "have", "to", "use", "the", "method", "createfile()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> createfile() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "createfile()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "createfile()", "label": "API", "asoc": []}]}
{"text": "to retrieve the file you will have to use the method createfile()", "tokens": ["to", "retrieve", "the", "file", "you", "will", "have", "to", "use", "the", "method", "createfile()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> createfile() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "createfile()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "createfile()", "label": "API", "asoc": []}]}
{"text": "to return the file you will have to use the method createfile()", "tokens": ["to", "return", "the", "file", "you", "will", "have", "to", "use", "the", "method", "createfile()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> createfile() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "createfile()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "createfile()", "label": "API", "asoc": []}]}
{"text": "to install the file you will have to use the method createfile()", "tokens": ["to", "install", "the", "file", "you", "will", "have", "to", "use", "the", "method", "createfile()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> createfile() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "createfile()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "createfile()", "label": "API", "asoc": []}]}
{"text": "to set up the file you will have to use the method createfile()", "tokens": ["to", "set", "up", "the", "file", "you", "will", "have", "to", "use", "the", "method", "createfile()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> createfile() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "createfile()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "createfile()", "label": "API", "asoc": []}]}
{"text": "you can also invoke system.gc() to suggest that the garbage collector run immediately", "tokens": ["you", "can", "also", "invoke", "system.gc()", "to", "suggest", "that", "the", "garbage", "collector", "run", "immediately", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.gc() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.gc()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.gc()", "label": "API", "asoc": []}]}
{"text": "you can also tell system.gc() to suggest that the garbage collector run immediately", "tokens": ["you", "can", "also", "tell", "system.gc()", "to", "suggest", "that", "the", "garbage", "collector", "run", "immediately", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.gc() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.gc()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.gc()", "label": "API", "asoc": []}]}
{"text": "you can also indicate system.gc() to suggest that the garbage collector run immediately", "tokens": ["you", "can", "also", "indicate", "system.gc()", "to", "suggest", "that", "the", "garbage", "collector", "run", "immediately", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.gc() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.gc()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.gc()", "label": "API", "asoc": []}]}
{"text": "you can also occur system.gc() to suggest that the garbage collector run immediately", "tokens": ["you", "can", "also", "occur", "system.gc()", "to", "suggest", "that", "the", "garbage", "collector", "run", "immediately", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.gc() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.gc()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.gc()", "label": "API", "asoc": []}]}
{"text": "you can also perform system.gc() to suggest that the garbage collector run immediately", "tokens": ["you", "can", "also", "perform", "system.gc()", "to", "suggest", "that", "the", "garbage", "collector", "run", "immediately", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.gc() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.gc()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.gc()", "label": "API", "asoc": []}]}
{"text": "you can also prompt system.gc() to suggest that the garbage collector run immediately", "tokens": ["you", "can", "also", "prompt", "system.gc()", "to", "suggest", "that", "the", "garbage", "collector", "run", "immediately", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.gc() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.gc()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.gc()", "label": "API", "asoc": []}]}
{"text": "you can also notify system.gc() to suggest that the garbage collector run immediately", "tokens": ["you", "can", "also", "notify", "system.gc()", "to", "suggest", "that", "the", "garbage", "collector", "run", "immediately", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.gc() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.gc()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.gc()", "label": "API", "asoc": []}]}
{"text": "you can also execute system.gc() to suggest that the garbage collector run immediately", "tokens": ["you", "can", "also", "execute", "system.gc()", "to", "suggest", "that", "the", "garbage", "collector", "run", "immediately", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.gc() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.gc()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.gc()", "label": "API", "asoc": []}]}
{"text": "you can also run system.gc() to suggest that the garbage collector run immediately", "tokens": ["you", "can", "also", "run", "system.gc()", "to", "suggest", "that", "the", "garbage", "collector", "run", "immediately", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.gc() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.gc()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.gc()", "label": "API", "asoc": []}]}
{"text": "you can also enforce system.gc() to suggest that the garbage collector run immediately", "tokens": ["you", "can", "also", "enforce", "system.gc()", "to", "suggest", "that", "the", "garbage", "collector", "run", "immediately", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.gc() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.gc()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.gc()", "label": "API", "asoc": []}]}
{"text": "you can also fire system.gc() to suggest that the garbage collector run immediately", "tokens": ["you", "can", "also", "fire", "system.gc()", "to", "suggest", "that", "the", "garbage", "collector", "run", "immediately", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.gc() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.gc()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.gc()", "label": "API", "asoc": []}]}
{"text": "you can also trigger system.gc() to suggest that the garbage collector run immediately", "tokens": ["you", "can", "also", "trigger", "system.gc()", "to", "suggest", "that", "the", "garbage", "collector", "run", "immediately", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.gc() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.gc()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.gc()", "label": "API", "asoc": []}]}
{"text": "create a bullet ,  or change the location of the bullet ,  or whatever) ,  and then invoke repaint()", "tokens": ["create", "a", "bullet", ",", "", "or", "change", "the", "location", "of", "the", "bullet", ",", "", "or", "whatever)", ",", "", "and", "then", "invoke", "repaint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "create a bullet ,  or change the location of the bullet ,  or whatever) ,  and then tell repaint()", "tokens": ["create", "a", "bullet", ",", "", "or", "change", "the", "location", "of", "the", "bullet", ",", "", "or", "whatever)", ",", "", "and", "then", "tell", "repaint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "create a bullet ,  or change the location of the bullet ,  or whatever) ,  and then indicate repaint()", "tokens": ["create", "a", "bullet", ",", "", "or", "change", "the", "location", "of", "the", "bullet", ",", "", "or", "whatever)", ",", "", "and", "then", "indicate", "repaint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "create a bullet ,  or change the location of the bullet ,  or whatever) ,  and then occur repaint()", "tokens": ["create", "a", "bullet", ",", "", "or", "change", "the", "location", "of", "the", "bullet", ",", "", "or", "whatever)", ",", "", "and", "then", "occur", "repaint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "create a bullet ,  or change the location of the bullet ,  or whatever) ,  and then perform repaint()", "tokens": ["create", "a", "bullet", ",", "", "or", "change", "the", "location", "of", "the", "bullet", ",", "", "or", "whatever)", ",", "", "and", "then", "perform", "repaint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "create a bullet ,  or change the location of the bullet ,  or whatever) ,  and then prompt repaint()", "tokens": ["create", "a", "bullet", ",", "", "or", "change", "the", "location", "of", "the", "bullet", ",", "", "or", "whatever)", ",", "", "and", "then", "prompt", "repaint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "create a bullet ,  or change the location of the bullet ,  or whatever) ,  and then notify repaint()", "tokens": ["create", "a", "bullet", ",", "", "or", "change", "the", "location", "of", "the", "bullet", ",", "", "or", "whatever)", ",", "", "and", "then", "notify", "repaint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "create a bullet ,  or change the location of the bullet ,  or whatever) ,  and then execute repaint()", "tokens": ["create", "a", "bullet", ",", "", "or", "change", "the", "location", "of", "the", "bullet", ",", "", "or", "whatever)", ",", "", "and", "then", "execute", "repaint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "create a bullet ,  or change the location of the bullet ,  or whatever) ,  and then run repaint()", "tokens": ["create", "a", "bullet", ",", "", "or", "change", "the", "location", "of", "the", "bullet", ",", "", "or", "whatever)", ",", "", "and", "then", "run", "repaint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "create a bullet ,  or change the location of the bullet ,  or whatever) ,  and then enforce repaint()", "tokens": ["create", "a", "bullet", ",", "", "or", "change", "the", "location", "of", "the", "bullet", ",", "", "or", "whatever)", ",", "", "and", "then", "enforce", "repaint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "create a bullet ,  or change the location of the bullet ,  or whatever) ,  and then fire repaint()", "tokens": ["create", "a", "bullet", ",", "", "or", "change", "the", "location", "of", "the", "bullet", ",", "", "or", "whatever)", ",", "", "and", "then", "fire", "repaint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "create a bullet ,  or change the location of the bullet ,  or whatever) ,  and then trigger repaint()", "tokens": ["create", "a", "bullet", ",", "", "or", "change", "the", "location", "of", "the", "bullet", ",", "", "or", "whatever)", ",", "", "and", "then", "trigger", "repaint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "replace() doesn't convert the string you call it on - it returns a new string with the changes", "tokens": ["replace()", "doesn't", "convert", "the", "string", "you", "call", "it", "on", "-", "it", "returns", "a", "new", "string", "with", "the", "changes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "replace()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replace()", "label": "API", "asoc": []}]}
{"text": "replace() doesn't transfer the string you call it on - it returns a new string with the changes", "tokens": ["replace()", "doesn't", "transfer", "the", "string", "you", "call", "it", "on", "-", "it", "returns", "a", "new", "string", "with", "the", "changes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "replace()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replace()", "label": "API", "asoc": []}]}
{"text": "replace() doesn't map the string you call it on - it returns a new string with the changes", "tokens": ["replace()", "doesn't", "map", "the", "string", "you", "call", "it", "on", "-", "it", "returns", "a", "new", "string", "with", "the", "changes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "replace()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replace()", "label": "API", "asoc": []}]}
{"text": "replace() doesn't turn the string you call it on - it returns a new string with the changes", "tokens": ["replace()", "doesn't", "turn", "the", "string", "you", "call", "it", "on", "-", "it", "returns", "a", "new", "string", "with", "the", "changes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "replace()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replace()", "label": "API", "asoc": []}]}
{"text": "replace() doesn't transform the string you call it on - it returns a new string with the changes", "tokens": ["replace()", "doesn't", "transform", "the", "string", "you", "call", "it", "on", "-", "it", "returns", "a", "new", "string", "with", "the", "changes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "replace()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replace()", "label": "API", "asoc": []}]}
{"text": "replace() doesn't reconvert the string you call it on - it returns a new string with the changes", "tokens": ["replace()", "doesn't", "reconvert", "the", "string", "you", "call", "it", "on", "-", "it", "returns", "a", "new", "string", "with", "the", "changes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "replace()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replace()", "label": "API", "asoc": []}]}
{"text": "replace() doesn't move the string you call it on - it returns a new string with the changes", "tokens": ["replace()", "doesn't", "move", "the", "string", "you", "call", "it", "on", "-", "it", "returns", "a", "new", "string", "with", "the", "changes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "replace()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replace()", "label": "API", "asoc": []}]}
{"text": "replace() doesn't adapt the string you call it on - it returns a new string with the changes", "tokens": ["replace()", "doesn't", "adapt", "the", "string", "you", "call", "it", "on", "-", "it", "returns", "a", "new", "string", "with", "the", "changes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "replace()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replace()", "label": "API", "asoc": []}]}
{"text": "replace() doesn't translate the string you call it on - it returns a new string with the changes", "tokens": ["replace()", "doesn't", "translate", "the", "string", "you", "call", "it", "on", "-", "it", "returns", "a", "new", "string", "with", "the", "changes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "replace()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replace()", "label": "API", "asoc": []}]}
{"text": "replace() doesn't force the string you call it on - it returns a new string with the changes", "tokens": ["replace()", "doesn't", "force", "the", "string", "you", "call", "it", "on", "-", "it", "returns", "a", "new", "string", "with", "the", "changes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "replace()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replace()", "label": "API", "asoc": []}]}
{"text": "replace() doesn't cast the string you call it on - it returns a new string with the changes", "tokens": ["replace()", "doesn't", "cast", "the", "string", "you", "call", "it", "on", "-", "it", "returns", "a", "new", "string", "with", "the", "changes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "replace()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replace()", "label": "API", "asoc": []}]}
{"text": "replace() doesn't return the string you call it on - it returns a new string with the changes", "tokens": ["replace()", "doesn't", "return", "the", "string", "you", "call", "it", "on", "-", "it", "returns", "a", "new", "string", "with", "the", "changes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "replace()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replace()", "label": "API", "asoc": []}]}
{"text": "replace() doesn't update the string you call it on - it returns a new string with the changes", "tokens": ["replace()", "doesn't", "update", "the", "string", "you", "call", "it", "on", "-", "it", "returns", "a", "new", "string", "with", "the", "changes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "replace()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replace()", "label": "API", "asoc": []}]}
{"text": "replace() doesn't modify the string you call it on - it returns a new string with the changes", "tokens": ["replace()", "doesn't", "modify", "the", "string", "you", "call", "it", "on", "-", "it", "returns", "a", "new", "string", "with", "the", "changes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "replace()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replace()", "label": "API", "asoc": []}]}
{"text": "replace() doesn't fill the string you call it on - it returns a new string with the changes", "tokens": ["replace()", "doesn't", "fill", "the", "string", "you", "call", "it", "on", "-", "it", "returns", "a", "new", "string", "with", "the", "changes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "replace()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replace()", "label": "API", "asoc": []}]}
{"text": "replace() doesn't edit the string you call it on - it returns a new string with the changes", "tokens": ["replace()", "doesn't", "edit", "the", "string", "you", "call", "it", "on", "-", "it", "returns", "a", "new", "string", "with", "the", "changes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "replace()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replace()", "label": "API", "asoc": []}]}
{"text": "replace() doesn't rename the string you call it on - it returns a new string with the changes", "tokens": ["replace()", "doesn't", "rename", "the", "string", "you", "call", "it", "on", "-", "it", "returns", "a", "new", "string", "with", "the", "changes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "replace()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replace()", "label": "API", "asoc": []}]}
{"text": "replace() doesn't populate the string you call it on - it returns a new string with the changes", "tokens": ["replace()", "doesn't", "populate", "the", "string", "you", "call", "it", "on", "-", "it", "returns", "a", "new", "string", "with", "the", "changes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "replace()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replace()", "label": "API", "asoc": []}]}
{"text": "replace() doesn't adjust the string you call it on - it returns a new string with the changes", "tokens": ["replace()", "doesn't", "adjust", "the", "string", "you", "call", "it", "on", "-", "it", "returns", "a", "new", "string", "with", "the", "changes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "replace()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replace()", "label": "API", "asoc": []}]}
{"text": "replace() doesn't flush the string you call it on - it returns a new string with the changes", "tokens": ["replace()", "doesn't", "flush", "the", "string", "you", "call", "it", "on", "-", "it", "returns", "a", "new", "string", "with", "the", "changes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "replace()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replace()", "label": "API", "asoc": []}]}
{"text": "replace() doesn't trim the string you call it on - it returns a new string with the changes", "tokens": ["replace()", "doesn't", "trim", "the", "string", "you", "call", "it", "on", "-", "it", "returns", "a", "new", "string", "with", "the", "changes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "replace()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replace()", "label": "API", "asoc": []}]}
{"text": "replace() doesn't reconcile the string you call it on - it returns a new string with the changes", "tokens": ["replace()", "doesn't", "reconcile", "the", "string", "you", "call", "it", "on", "-", "it", "returns", "a", "new", "string", "with", "the", "changes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "replace()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replace()", "label": "API", "asoc": []}]}
{"text": "replace() doesn't resize the string you call it on - it returns a new string with the changes", "tokens": ["replace()", "doesn't", "resize", "the", "string", "you", "call", "it", "on", "-", "it", "returns", "a", "new", "string", "with", "the", "changes", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "replace()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "replace()", "label": "API", "asoc": []}]}
{"text": "to sort the whole array ,  just invoke arrays.sort(p)", "tokens": ["to", "sort", "the", "whole", "array", ",", "", "just", "invoke", "arrays.sort(p)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort(p) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "arrays.sort(p)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort(p)", "label": "API", "asoc": []}]}
{"text": "to sort the whole array ,  just tell arrays.sort(p)", "tokens": ["to", "sort", "the", "whole", "array", ",", "", "just", "tell", "arrays.sort(p)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort(p) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "arrays.sort(p)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort(p)", "label": "API", "asoc": []}]}
{"text": "to sort the whole array ,  just indicate arrays.sort(p)", "tokens": ["to", "sort", "the", "whole", "array", ",", "", "just", "indicate", "arrays.sort(p)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort(p) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "arrays.sort(p)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort(p)", "label": "API", "asoc": []}]}
{"text": "to sort the whole array ,  just occur arrays.sort(p)", "tokens": ["to", "sort", "the", "whole", "array", ",", "", "just", "occur", "arrays.sort(p)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort(p) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "arrays.sort(p)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort(p)", "label": "API", "asoc": []}]}
{"text": "to sort the whole array ,  just perform arrays.sort(p)", "tokens": ["to", "sort", "the", "whole", "array", ",", "", "just", "perform", "arrays.sort(p)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort(p) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "arrays.sort(p)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort(p)", "label": "API", "asoc": []}]}
{"text": "to sort the whole array ,  just prompt arrays.sort(p)", "tokens": ["to", "sort", "the", "whole", "array", ",", "", "just", "prompt", "arrays.sort(p)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort(p) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "arrays.sort(p)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort(p)", "label": "API", "asoc": []}]}
{"text": "to sort the whole array ,  just notify arrays.sort(p)", "tokens": ["to", "sort", "the", "whole", "array", ",", "", "just", "notify", "arrays.sort(p)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort(p) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "arrays.sort(p)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort(p)", "label": "API", "asoc": []}]}
{"text": "to sort the whole array ,  just execute arrays.sort(p)", "tokens": ["to", "sort", "the", "whole", "array", ",", "", "just", "execute", "arrays.sort(p)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort(p) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "arrays.sort(p)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort(p)", "label": "API", "asoc": []}]}
{"text": "to sort the whole array ,  just run arrays.sort(p)", "tokens": ["to", "sort", "the", "whole", "array", ",", "", "just", "run", "arrays.sort(p)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort(p) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "arrays.sort(p)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort(p)", "label": "API", "asoc": []}]}
{"text": "to sort the whole array ,  just enforce arrays.sort(p)", "tokens": ["to", "sort", "the", "whole", "array", ",", "", "just", "enforce", "arrays.sort(p)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort(p) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "arrays.sort(p)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort(p)", "label": "API", "asoc": []}]}
{"text": "to sort the whole array ,  just fire arrays.sort(p)", "tokens": ["to", "sort", "the", "whole", "array", ",", "", "just", "fire", "arrays.sort(p)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort(p) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "arrays.sort(p)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort(p)", "label": "API", "asoc": []}]}
{"text": "to sort the whole array ,  just trigger arrays.sort(p)", "tokens": ["to", "sort", "the", "whole", "array", ",", "", "just", "trigger", "arrays.sort(p)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort(p) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "arrays.sort(p)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort(p)", "label": "API", "asoc": []}]}
{"text": "enum constants are encoded differently than instances of normal classes ,  so objectinputstream.readobject() can store them without calling their readobject method", "tokens": ["enum", "constants", "are", "encoded", "differently", "than", "instances", "of", "normal", "classes", ",", "", "so", "objectinputstream.readobject()", "can", "store", "them", "without", "calling", "their", "readobject", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> objectinputstream.readobject() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "objectinputstream.readobject()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "objectinputstream.readobject()", "label": "API", "asoc": []}]}
{"text": "enum constants are encoded differently than instances of normal classes ,  so objectinputstream.readobject() can save them without calling their readobject method", "tokens": ["enum", "constants", "are", "encoded", "differently", "than", "instances", "of", "normal", "classes", ",", "", "so", "objectinputstream.readobject()", "can", "save", "them", "without", "calling", "their", "readobject", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> objectinputstream.readobject() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "objectinputstream.readobject()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "objectinputstream.readobject()", "label": "API", "asoc": []}]}
{"text": "enum constants are encoded differently than instances of normal classes ,  so objectinputstream.readobject() can dump them without calling their readobject method", "tokens": ["enum", "constants", "are", "encoded", "differently", "than", "instances", "of", "normal", "classes", ",", "", "so", "objectinputstream.readobject()", "can", "dump", "them", "without", "calling", "their", "readobject", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> objectinputstream.readobject() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "objectinputstream.readobject()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "objectinputstream.readobject()", "label": "API", "asoc": []}]}
{"text": "enum constants are encoded differently than instances of normal classes ,  so objectinputstream.readobject() can retain them without calling their readobject method", "tokens": ["enum", "constants", "are", "encoded", "differently", "than", "instances", "of", "normal", "classes", ",", "", "so", "objectinputstream.readobject()", "can", "retain", "them", "without", "calling", "their", "readobject", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> objectinputstream.readobject() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "objectinputstream.readobject()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "objectinputstream.readobject()", "label": "API", "asoc": []}]}
{"text": "enum constants are encoded differently than instances of normal classes ,  so objectinputstream.readobject() can cache them without calling their readobject method", "tokens": ["enum", "constants", "are", "encoded", "differently", "than", "instances", "of", "normal", "classes", ",", "", "so", "objectinputstream.readobject()", "can", "cache", "them", "without", "calling", "their", "readobject", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> objectinputstream.readobject() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "objectinputstream.readobject()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "objectinputstream.readobject()", "label": "API", "asoc": []}]}
{"text": "enum constants are encoded differently than instances of normal classes ,  so objectinputstream.readobject() can stash them without calling their readobject method", "tokens": ["enum", "constants", "are", "encoded", "differently", "than", "instances", "of", "normal", "classes", ",", "", "so", "objectinputstream.readobject()", "can", "stash", "them", "without", "calling", "their", "readobject", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> objectinputstream.readobject() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "objectinputstream.readobject()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "objectinputstream.readobject()", "label": "API", "asoc": []}]}
{"text": "enum constants are encoded differently than instances of normal classes ,  so objectinputstream.readobject() can serialize them without calling their readobject method", "tokens": ["enum", "constants", "are", "encoded", "differently", "than", "instances", "of", "normal", "classes", ",", "", "so", "objectinputstream.readobject()", "can", "serialize", "them", "without", "calling", "their", "readobject", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> objectinputstream.readobject() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "objectinputstream.readobject()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "objectinputstream.readobject()", "label": "API", "asoc": []}]}
{"text": "enum constants are encoded differently than instances of normal classes ,  so objectinputstream.readobject() can persist them without calling their readobject method", "tokens": ["enum", "constants", "are", "encoded", "differently", "than", "instances", "of", "normal", "classes", ",", "", "so", "objectinputstream.readobject()", "can", "persist", "them", "without", "calling", "their", "readobject", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> objectinputstream.readobject() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "objectinputstream.readobject()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "objectinputstream.readobject()", "label": "API", "asoc": []}]}
{"text": "you need to invoke gettime() to get the date out of it", "tokens": ["you", "need", "to", "invoke", "gettime()", "to", "get", "the", "date", "out", "of", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> gettime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "gettime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "gettime()", "label": "API", "asoc": []}]}
{"text": "you need to tell gettime() to get the date out of it", "tokens": ["you", "need", "to", "tell", "gettime()", "to", "get", "the", "date", "out", "of", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> gettime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "gettime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "gettime()", "label": "API", "asoc": []}]}
{"text": "you need to indicate gettime() to get the date out of it", "tokens": ["you", "need", "to", "indicate", "gettime()", "to", "get", "the", "date", "out", "of", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> gettime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "gettime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "gettime()", "label": "API", "asoc": []}]}
{"text": "you need to occur gettime() to get the date out of it", "tokens": ["you", "need", "to", "occur", "gettime()", "to", "get", "the", "date", "out", "of", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> gettime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "gettime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "gettime()", "label": "API", "asoc": []}]}
{"text": "you need to perform gettime() to get the date out of it", "tokens": ["you", "need", "to", "perform", "gettime()", "to", "get", "the", "date", "out", "of", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> gettime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "gettime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "gettime()", "label": "API", "asoc": []}]}
{"text": "you need to prompt gettime() to get the date out of it", "tokens": ["you", "need", "to", "prompt", "gettime()", "to", "get", "the", "date", "out", "of", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> gettime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "gettime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "gettime()", "label": "API", "asoc": []}]}
{"text": "you need to notify gettime() to get the date out of it", "tokens": ["you", "need", "to", "notify", "gettime()", "to", "get", "the", "date", "out", "of", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> gettime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "gettime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "gettime()", "label": "API", "asoc": []}]}
{"text": "you need to execute gettime() to get the date out of it", "tokens": ["you", "need", "to", "execute", "gettime()", "to", "get", "the", "date", "out", "of", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> gettime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "gettime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "gettime()", "label": "API", "asoc": []}]}
{"text": "you need to run gettime() to get the date out of it", "tokens": ["you", "need", "to", "run", "gettime()", "to", "get", "the", "date", "out", "of", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> gettime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "gettime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "gettime()", "label": "API", "asoc": []}]}
{"text": "you need to enforce gettime() to get the date out of it", "tokens": ["you", "need", "to", "enforce", "gettime()", "to", "get", "the", "date", "out", "of", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> gettime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "gettime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "gettime()", "label": "API", "asoc": []}]}
{"text": "you need to fire gettime() to get the date out of it", "tokens": ["you", "need", "to", "fire", "gettime()", "to", "get", "the", "date", "out", "of", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> gettime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "gettime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "gettime()", "label": "API", "asoc": []}]}
{"text": "you need to trigger gettime() to get the date out of it", "tokens": ["you", "need", "to", "trigger", "gettime()", "to", "get", "the", "date", "out", "of", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> gettime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "gettime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "gettime()", "label": "API", "asoc": []}]}
{"text": "first of all ,  to store a java.util.date into a database in java ,  you will have to convert it to java.sql.date", "tokens": ["first", "of", "all", ",", "", "to", "store", "a", "java.util.date", "into", "a", "database", "in", "java", ",", "", "you", "will", "have", "to", "convert", "it", "to", "java.sql.date", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.date <extra_id_0> type conversion <extra_id_5> java.sql.date <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> java.sql.date <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "java.util.date"}, {"type": "API", "offset": [23], "text": "java.sql.date"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [8], "text": "java.util.date"}, {"type": "API", "offset": [23], "text": "java.sql.date"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "java.util.date", "label": "API", "asoc": [["type conversion", "java.sql.date"]]}, {"span": "java.sql.date", "label": "API", "asoc": []}]}
{"text": "first of all ,  to save a java.util.date into a database in java ,  you will have to convert it to java.sql.date", "tokens": ["first", "of", "all", ",", "", "to", "save", "a", "java.util.date", "into", "a", "database", "in", "java", ",", "", "you", "will", "have", "to", "convert", "it", "to", "java.sql.date", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.date <extra_id_0> type conversion <extra_id_5> java.sql.date <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> java.sql.date <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "java.util.date"}, {"type": "API", "offset": [23], "text": "java.sql.date"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [8], "text": "java.util.date"}, {"type": "API", "offset": [23], "text": "java.sql.date"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "java.util.date", "label": "API", "asoc": [["type conversion", "java.sql.date"]]}, {"span": "java.sql.date", "label": "API", "asoc": []}]}
{"text": "first of all ,  to dump a java.util.date into a database in java ,  you will have to convert it to java.sql.date", "tokens": ["first", "of", "all", ",", "", "to", "dump", "a", "java.util.date", "into", "a", "database", "in", "java", ",", "", "you", "will", "have", "to", "convert", "it", "to", "java.sql.date", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.date <extra_id_0> type conversion <extra_id_5> java.sql.date <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> java.sql.date <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "java.util.date"}, {"type": "API", "offset": [23], "text": "java.sql.date"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [8], "text": "java.util.date"}, {"type": "API", "offset": [23], "text": "java.sql.date"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "java.util.date", "label": "API", "asoc": [["type conversion", "java.sql.date"]]}, {"span": "java.sql.date", "label": "API", "asoc": []}]}
{"text": "first of all ,  to retain a java.util.date into a database in java ,  you will have to convert it to java.sql.date", "tokens": ["first", "of", "all", ",", "", "to", "retain", "a", "java.util.date", "into", "a", "database", "in", "java", ",", "", "you", "will", "have", "to", "convert", "it", "to", "java.sql.date", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.date <extra_id_0> type conversion <extra_id_5> java.sql.date <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> java.sql.date <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "java.util.date"}, {"type": "API", "offset": [23], "text": "java.sql.date"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [8], "text": "java.util.date"}, {"type": "API", "offset": [23], "text": "java.sql.date"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "java.util.date", "label": "API", "asoc": [["type conversion", "java.sql.date"]]}, {"span": "java.sql.date", "label": "API", "asoc": []}]}
{"text": "first of all ,  to cache a java.util.date into a database in java ,  you will have to convert it to java.sql.date", "tokens": ["first", "of", "all", ",", "", "to", "cache", "a", "java.util.date", "into", "a", "database", "in", "java", ",", "", "you", "will", "have", "to", "convert", "it", "to", "java.sql.date", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.date <extra_id_0> type conversion <extra_id_5> java.sql.date <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> java.sql.date <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "java.util.date"}, {"type": "API", "offset": [23], "text": "java.sql.date"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [8], "text": "java.util.date"}, {"type": "API", "offset": [23], "text": "java.sql.date"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "java.util.date", "label": "API", "asoc": [["type conversion", "java.sql.date"]]}, {"span": "java.sql.date", "label": "API", "asoc": []}]}
{"text": "first of all ,  to stash a java.util.date into a database in java ,  you will have to convert it to java.sql.date", "tokens": ["first", "of", "all", ",", "", "to", "stash", "a", "java.util.date", "into", "a", "database", "in", "java", ",", "", "you", "will", "have", "to", "convert", "it", "to", "java.sql.date", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.date <extra_id_0> type conversion <extra_id_5> java.sql.date <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> java.sql.date <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "java.util.date"}, {"type": "API", "offset": [23], "text": "java.sql.date"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [8], "text": "java.util.date"}, {"type": "API", "offset": [23], "text": "java.sql.date"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "java.util.date", "label": "API", "asoc": [["type conversion", "java.sql.date"]]}, {"span": "java.sql.date", "label": "API", "asoc": []}]}
{"text": "first of all ,  to serialize a java.util.date into a database in java ,  you will have to convert it to java.sql.date", "tokens": ["first", "of", "all", ",", "", "to", "serialize", "a", "java.util.date", "into", "a", "database", "in", "java", ",", "", "you", "will", "have", "to", "convert", "it", "to", "java.sql.date", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.date <extra_id_0> type conversion <extra_id_5> java.sql.date <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> java.sql.date <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "java.util.date"}, {"type": "API", "offset": [23], "text": "java.sql.date"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [8], "text": "java.util.date"}, {"type": "API", "offset": [23], "text": "java.sql.date"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "java.util.date", "label": "API", "asoc": [["type conversion", "java.sql.date"]]}, {"span": "java.sql.date", "label": "API", "asoc": []}]}
{"text": "first of all ,  to deserialize a java.util.date into a database in java ,  you will have to convert it to java.sql.date", "tokens": ["first", "of", "all", ",", "", "to", "deserialize", "a", "java.util.date", "into", "a", "database", "in", "java", ",", "", "you", "will", "have", "to", "convert", "it", "to", "java.sql.date", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.date <extra_id_0> type conversion <extra_id_5> java.sql.date <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> java.sql.date <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "java.util.date"}, {"type": "API", "offset": [23], "text": "java.sql.date"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [8], "text": "java.util.date"}, {"type": "API", "offset": [23], "text": "java.sql.date"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "java.util.date", "label": "API", "asoc": [["type conversion", "java.sql.date"]]}, {"span": "java.sql.date", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to create a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "create", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to build a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "build", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to produce a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "produce", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to construct a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "construct", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to generate a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "generate", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to establish a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "establish", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to make a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "make", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to obtain a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "obtain", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to reconstitute a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "reconstitute", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to compose a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "compose", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to instantiate a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "instantiate", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to implement a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "implement", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to get a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "get", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to return a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "return", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to install a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "install", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to set up a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "set", "up", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [20], "text": "timestamp"}, {"type": "API", "offset": [26], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [20], "text": "timestamp"}, {"type": "API", "offset": [26], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to query a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "query", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to find a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "find", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to locate a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "locate", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to determine a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "determine", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to visit a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "visit", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to look a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "look", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to search a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "search", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to discover a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "discover", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to seek a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "seek", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to look up a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "look", "up", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [20], "text": "timestamp"}, {"type": "API", "offset": [26], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [20], "text": "timestamp"}, {"type": "API", "offset": [26], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to test a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "test", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to tell a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "tell", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to check a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "check", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to ascertain a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "ascertain", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to control a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "control", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to indicate a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "indicate", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to report a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "report", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to validate a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "validate", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to invalidate a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "invalidate", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to verify a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "verify", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to identify a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "identify", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to track a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "track", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to detect a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "detect", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "for mssql-jdbc versions prior to 7.1.0 ,  as others have suggested ,  you'll need to decide a timestamp and convert it to a localdatetime", "tokens": ["for", "mssql-jdbc", "versions", "prior", "to", "7.1.0", ",", "", "as", "others", "have", "suggested", ",", "", "you'll", "need", "to", "decide", "a", "timestamp", "and", "convert", "it", "to", "a", "localdatetime", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> timestamp <extra_id_0> type conversion <extra_id_5> localdatetime <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> localdatetime <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}], "relation": [{"type": "type conversion", "args": [{"type": "API", "offset": [19], "text": "timestamp"}, {"type": "API", "offset": [25], "text": "localdatetime"}]}], "event": [], "spot": ["API"], "asoc": ["type conversion"], "spot_asoc": [{"span": "timestamp", "label": "API", "asoc": [["type conversion", "localdatetime"]]}, {"span": "localdatetime", "label": "API", "asoc": []}]}
{"text": "to create a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "create", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to build a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "build", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to produce a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "produce", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to construct a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "construct", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to generate a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "generate", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to establish a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "establish", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to make a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "make", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to obtain a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "obtain", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to reconstitute a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "reconstitute", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to compose a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "compose", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to instantiate a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "instantiate", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to implement a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "implement", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to retrieve a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "retrieve", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to return a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "return", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to install a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "install", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to set up a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "set", "up", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to test a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "test", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to tell a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "tell", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to determine a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "determine", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to check a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "check", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to ascertain a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "ascertain", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to control a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "control", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to indicate a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "indicate", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to query a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "query", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to report a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "report", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to validate a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "validate", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to invalidate a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "invalidate", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to verify a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "verify", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to find a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "find", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to identify a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "identify", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to track a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "track", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to detect a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "detect", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "to decide a current download url ,  use storagereference.getdownloadur()", "tokens": ["to", "decide", "a", "current", "download", "url", ",", "", "use", "storagereference.getdownloadur()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> storagereference.getdownloadur() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "storagereference.getdownloadur()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "storagereference.getdownloadur()", "label": "API", "asoc": []}]}
{"text": "once we invoke pow() recursively ,  it's always with positive numbers and the sign doesn't change until it reaches 0", "tokens": ["once", "we", "invoke", "pow()", "recursively", ",", "", "it's", "always", "with", "positive", "numbers", "and", "the", "sign", "doesn't", "change", "until", "it", "reaches", "0", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pow() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pow()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pow()", "label": "API", "asoc": []}]}
{"text": "once we tell pow() recursively ,  it's always with positive numbers and the sign doesn't change until it reaches 0", "tokens": ["once", "we", "tell", "pow()", "recursively", ",", "", "it's", "always", "with", "positive", "numbers", "and", "the", "sign", "doesn't", "change", "until", "it", "reaches", "0", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pow() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pow()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pow()", "label": "API", "asoc": []}]}
{"text": "once we indicate pow() recursively ,  it's always with positive numbers and the sign doesn't change until it reaches 0", "tokens": ["once", "we", "indicate", "pow()", "recursively", ",", "", "it's", "always", "with", "positive", "numbers", "and", "the", "sign", "doesn't", "change", "until", "it", "reaches", "0", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pow() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pow()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pow()", "label": "API", "asoc": []}]}
{"text": "once we occur pow() recursively ,  it's always with positive numbers and the sign doesn't change until it reaches 0", "tokens": ["once", "we", "occur", "pow()", "recursively", ",", "", "it's", "always", "with", "positive", "numbers", "and", "the", "sign", "doesn't", "change", "until", "it", "reaches", "0", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pow() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pow()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pow()", "label": "API", "asoc": []}]}
{"text": "once we perform pow() recursively ,  it's always with positive numbers and the sign doesn't change until it reaches 0", "tokens": ["once", "we", "perform", "pow()", "recursively", ",", "", "it's", "always", "with", "positive", "numbers", "and", "the", "sign", "doesn't", "change", "until", "it", "reaches", "0", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pow() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pow()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pow()", "label": "API", "asoc": []}]}
{"text": "once we prompt pow() recursively ,  it's always with positive numbers and the sign doesn't change until it reaches 0", "tokens": ["once", "we", "prompt", "pow()", "recursively", ",", "", "it's", "always", "with", "positive", "numbers", "and", "the", "sign", "doesn't", "change", "until", "it", "reaches", "0", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pow() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pow()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pow()", "label": "API", "asoc": []}]}
{"text": "once we notify pow() recursively ,  it's always with positive numbers and the sign doesn't change until it reaches 0", "tokens": ["once", "we", "notify", "pow()", "recursively", ",", "", "it's", "always", "with", "positive", "numbers", "and", "the", "sign", "doesn't", "change", "until", "it", "reaches", "0", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pow() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pow()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pow()", "label": "API", "asoc": []}]}
{"text": "once we execute pow() recursively ,  it's always with positive numbers and the sign doesn't change until it reaches 0", "tokens": ["once", "we", "execute", "pow()", "recursively", ",", "", "it's", "always", "with", "positive", "numbers", "and", "the", "sign", "doesn't", "change", "until", "it", "reaches", "0", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pow() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pow()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pow()", "label": "API", "asoc": []}]}
{"text": "once we run pow() recursively ,  it's always with positive numbers and the sign doesn't change until it reaches 0", "tokens": ["once", "we", "run", "pow()", "recursively", ",", "", "it's", "always", "with", "positive", "numbers", "and", "the", "sign", "doesn't", "change", "until", "it", "reaches", "0", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pow() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pow()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pow()", "label": "API", "asoc": []}]}
{"text": "once we enforce pow() recursively ,  it's always with positive numbers and the sign doesn't change until it reaches 0", "tokens": ["once", "we", "enforce", "pow()", "recursively", ",", "", "it's", "always", "with", "positive", "numbers", "and", "the", "sign", "doesn't", "change", "until", "it", "reaches", "0", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pow() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pow()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pow()", "label": "API", "asoc": []}]}
{"text": "once we fire pow() recursively ,  it's always with positive numbers and the sign doesn't change until it reaches 0", "tokens": ["once", "we", "fire", "pow()", "recursively", ",", "", "it's", "always", "with", "positive", "numbers", "and", "the", "sign", "doesn't", "change", "until", "it", "reaches", "0", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pow() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pow()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pow()", "label": "API", "asoc": []}]}
{"text": "once we trigger pow() recursively ,  it's always with positive numbers and the sign doesn't change until it reaches 0", "tokens": ["once", "we", "trigger", "pow()", "recursively", ",", "", "it's", "always", "with", "positive", "numbers", "and", "the", "sign", "doesn't", "change", "until", "it", "reaches", "0", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pow() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pow()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pow()", "label": "API", "asoc": []}]}
{"text": "to use removeall() ,  you'll have to clone the set then use it", "tokens": ["to", "use", "removeall()", ",", "", "you'll", "have", "to", "clone", "the", "set", "then", "use", "it", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> removeall() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "removeall()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "removeall()", "label": "API", "asoc": []}]}
{"text": "now you can use substring() and the like on the data or query it with index ,  run regexp's on it ,  etc", "tokens": ["now", "you", "can", "use", "substring()", "and", "the", "like", "on", "the", "data", "or", "query", "it", "with", "index", ",", "", "run", "regexp's", "on", "it", ",", "", "etc", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> substring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "substring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "substring()", "label": "API", "asoc": []}]}
{"text": "now you can use substring() and the like on the data or find it with index ,  run regexp's on it ,  etc", "tokens": ["now", "you", "can", "use", "substring()", "and", "the", "like", "on", "the", "data", "or", "find", "it", "with", "index", ",", "", "run", "regexp's", "on", "it", ",", "", "etc", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> substring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "substring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "substring()", "label": "API", "asoc": []}]}
{"text": "now you can use substring() and the like on the data or locate it with index ,  run regexp's on it ,  etc", "tokens": ["now", "you", "can", "use", "substring()", "and", "the", "like", "on", "the", "data", "or", "locate", "it", "with", "index", ",", "", "run", "regexp's", "on", "it", ",", "", "etc", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> substring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "substring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "substring()", "label": "API", "asoc": []}]}
{"text": "now you can use substring() and the like on the data or determine it with index ,  run regexp's on it ,  etc", "tokens": ["now", "you", "can", "use", "substring()", "and", "the", "like", "on", "the", "data", "or", "determine", "it", "with", "index", ",", "", "run", "regexp's", "on", "it", ",", "", "etc", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> substring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "substring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "substring()", "label": "API", "asoc": []}]}
{"text": "now you can use substring() and the like on the data or retrieve it with index ,  run regexp's on it ,  etc", "tokens": ["now", "you", "can", "use", "substring()", "and", "the", "like", "on", "the", "data", "or", "retrieve", "it", "with", "index", ",", "", "run", "regexp's", "on", "it", ",", "", "etc", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> substring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "substring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "substring()", "label": "API", "asoc": []}]}
{"text": "now you can use substring() and the like on the data or visit it with index ,  run regexp's on it ,  etc", "tokens": ["now", "you", "can", "use", "substring()", "and", "the", "like", "on", "the", "data", "or", "visit", "it", "with", "index", ",", "", "run", "regexp's", "on", "it", ",", "", "etc", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> substring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "substring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "substring()", "label": "API", "asoc": []}]}
{"text": "now you can use substring() and the like on the data or look it with index ,  run regexp's on it ,  etc", "tokens": ["now", "you", "can", "use", "substring()", "and", "the", "like", "on", "the", "data", "or", "look", "it", "with", "index", ",", "", "run", "regexp's", "on", "it", ",", "", "etc", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> substring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "substring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "substring()", "label": "API", "asoc": []}]}
{"text": "now you can use substring() and the like on the data or discover it with index ,  run regexp's on it ,  etc", "tokens": ["now", "you", "can", "use", "substring()", "and", "the", "like", "on", "the", "data", "or", "discover", "it", "with", "index", ",", "", "run", "regexp's", "on", "it", ",", "", "etc", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> substring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "substring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "substring()", "label": "API", "asoc": []}]}
{"text": "now you can use substring() and the like on the data or seek it with index ,  run regexp's on it ,  etc", "tokens": ["now", "you", "can", "use", "substring()", "and", "the", "like", "on", "the", "data", "or", "seek", "it", "with", "index", ",", "", "run", "regexp's", "on", "it", ",", "", "etc", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> substring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "substring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "substring()", "label": "API", "asoc": []}]}
{"text": "now you can use substring() and the like on the data or look up it with index ,  run regexp's on it ,  etc", "tokens": ["now", "you", "can", "use", "substring()", "and", "the", "like", "on", "the", "data", "or", "look", "up", "it", "with", "index", ",", "", "run", "regexp's", "on", "it", ",", "", "etc", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> substring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "substring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "substring()", "label": "API", "asoc": []}]}
{"text": "i will display you few examples ,  together with hashcode() of each string and hashcode() of internal char[] value field (i will call it text to distinguish it from string)", "tokens": ["i", "will", "display", "you", "few", "examples", ",", "", "together", "with", "hashcode()", "of", "each", "string", "and", "hashcode()", "of", "internal", "char[]", "value", "field", "(i", "will", "call", "it", "text", "to", "distinguish", "it", "from", "string)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "hashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "hashcode()", "label": "API", "asoc": []}]}
{"text": "i will present you few examples ,  together with hashcode() of each string and hashcode() of internal char[] value field (i will call it text to distinguish it from string)", "tokens": ["i", "will", "present", "you", "few", "examples", ",", "", "together", "with", "hashcode()", "of", "each", "string", "and", "hashcode()", "of", "internal", "char[]", "value", "field", "(i", "will", "call", "it", "text", "to", "distinguish", "it", "from", "string)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "hashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "hashcode()", "label": "API", "asoc": []}]}
{"text": "i will bring you few examples ,  together with hashcode() of each string and hashcode() of internal char[] value field (i will call it text to distinguish it from string)", "tokens": ["i", "will", "bring", "you", "few", "examples", ",", "", "together", "with", "hashcode()", "of", "each", "string", "and", "hashcode()", "of", "internal", "char[]", "value", "field", "(i", "will", "call", "it", "text", "to", "distinguish", "it", "from", "string)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> hashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "hashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "hashcode()", "label": "API", "asoc": []}]}
{"text": "you can clear pattern.quote() if you want to use regex ,  but i don't guarantee anything if you do that", "tokens": ["you", "can", "clear", "pattern.quote()", "if", "you", "want", "to", "use", "regex", ",", "", "but", "i", "don't", "guarantee", "anything", "if", "you", "do", "that", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pattern.quote() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pattern.quote()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pattern.quote()", "label": "API", "asoc": []}]}
{"text": "you can clean pattern.quote() if you want to use regex ,  but i don't guarantee anything if you do that", "tokens": ["you", "can", "clean", "pattern.quote()", "if", "you", "want", "to", "use", "regex", ",", "", "but", "i", "don't", "guarantee", "anything", "if", "you", "do", "that", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pattern.quote() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pattern.quote()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pattern.quote()", "label": "API", "asoc": []}]}
{"text": "you can empty pattern.quote() if you want to use regex ,  but i don't guarantee anything if you do that", "tokens": ["you", "can", "empty", "pattern.quote()", "if", "you", "want", "to", "use", "regex", ",", "", "but", "i", "don't", "guarantee", "anything", "if", "you", "do", "that", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pattern.quote() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pattern.quote()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pattern.quote()", "label": "API", "asoc": []}]}
{"text": "you can exclude pattern.quote() if you want to use regex ,  but i don't guarantee anything if you do that", "tokens": ["you", "can", "exclude", "pattern.quote()", "if", "you", "want", "to", "use", "regex", ",", "", "but", "i", "don't", "guarantee", "anything", "if", "you", "do", "that", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pattern.quote() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pattern.quote()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pattern.quote()", "label": "API", "asoc": []}]}
{"text": "you can reduce pattern.quote() if you want to use regex ,  but i don't guarantee anything if you do that", "tokens": ["you", "can", "reduce", "pattern.quote()", "if", "you", "want", "to", "use", "regex", ",", "", "but", "i", "don't", "guarantee", "anything", "if", "you", "do", "that", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pattern.quote() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pattern.quote()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pattern.quote()", "label": "API", "asoc": []}]}
{"text": "you can delete pattern.quote() if you want to use regex ,  but i don't guarantee anything if you do that", "tokens": ["you", "can", "delete", "pattern.quote()", "if", "you", "want", "to", "use", "regex", ",", "", "but", "i", "don't", "guarantee", "anything", "if", "you", "do", "that", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pattern.quote() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pattern.quote()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pattern.quote()", "label": "API", "asoc": []}]}
{"text": "you can pop pattern.quote() if you want to use regex ,  but i don't guarantee anything if you do that", "tokens": ["you", "can", "pop", "pattern.quote()", "if", "you", "want", "to", "use", "regex", ",", "", "but", "i", "don't", "guarantee", "anything", "if", "you", "do", "that", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pattern.quote() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pattern.quote()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pattern.quote()", "label": "API", "asoc": []}]}
{"text": "you can uninstall pattern.quote() if you want to use regex ,  but i don't guarantee anything if you do that", "tokens": ["you", "can", "uninstall", "pattern.quote()", "if", "you", "want", "to", "use", "regex", ",", "", "but", "i", "don't", "guarantee", "anything", "if", "you", "do", "that", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pattern.quote() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pattern.quote()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pattern.quote()", "label": "API", "asoc": []}]}
{"text": "you can detach pattern.quote() if you want to use regex ,  but i don't guarantee anything if you do that", "tokens": ["you", "can", "detach", "pattern.quote()", "if", "you", "want", "to", "use", "regex", ",", "", "but", "i", "don't", "guarantee", "anything", "if", "you", "do", "that", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pattern.quote() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pattern.quote()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pattern.quote()", "label": "API", "asoc": []}]}
{"text": "you can decrement pattern.quote() if you want to use regex ,  but i don't guarantee anything if you do that", "tokens": ["you", "can", "decrement", "pattern.quote()", "if", "you", "want", "to", "use", "regex", ",", "", "but", "i", "don't", "guarantee", "anything", "if", "you", "do", "that", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pattern.quote() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pattern.quote()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pattern.quote()", "label": "API", "asoc": []}]}
{"text": "you can revoke pattern.quote() if you want to use regex ,  but i don't guarantee anything if you do that", "tokens": ["you", "can", "revoke", "pattern.quote()", "if", "you", "want", "to", "use", "regex", ",", "", "but", "i", "don't", "guarantee", "anything", "if", "you", "do", "that", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pattern.quote() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pattern.quote()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pattern.quote()", "label": "API", "asoc": []}]}
{"text": "you can dequeue pattern.quote() if you want to use regex ,  but i don't guarantee anything if you do that", "tokens": ["you", "can", "dequeue", "pattern.quote()", "if", "you", "want", "to", "use", "regex", ",", "", "but", "i", "don't", "guarantee", "anything", "if", "you", "do", "that", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pattern.quote() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pattern.quote()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pattern.quote()", "label": "API", "asoc": []}]}
{"text": "you can abandon pattern.quote() if you want to use regex ,  but i don't guarantee anything if you do that", "tokens": ["you", "can", "abandon", "pattern.quote()", "if", "you", "want", "to", "use", "regex", ",", "", "but", "i", "don't", "guarantee", "anything", "if", "you", "do", "that", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pattern.quote() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pattern.quote()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pattern.quote()", "label": "API", "asoc": []}]}
{"text": "you can discard pattern.quote() if you want to use regex ,  but i don't guarantee anything if you do that", "tokens": ["you", "can", "discard", "pattern.quote()", "if", "you", "want", "to", "use", "regex", ",", "", "but", "i", "don't", "guarantee", "anything", "if", "you", "do", "that", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pattern.quote() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pattern.quote()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pattern.quote()", "label": "API", "asoc": []}]}
{"text": "you can peek pattern.quote() if you want to use regex ,  but i don't guarantee anything if you do that", "tokens": ["you", "can", "peek", "pattern.quote()", "if", "you", "want", "to", "use", "regex", ",", "", "but", "i", "don't", "guarantee", "anything", "if", "you", "do", "that", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pattern.quote() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "pattern.quote()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pattern.quote()", "label": "API", "asoc": []}]}
{"text": "and it does have a reachable reference until (at least) the point at which the start() invoke returns", "tokens": ["and", "it", "does", "have", "a", "reachable", "reference", "until", "(at", "least)", "the", "point", "at", "which", "the", "start()", "invoke", "returns", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> start() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "start()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "start()", "label": "API", "asoc": []}]}
{"text": "and it does have a reachable reference until (at least) the point at which the start() tell returns", "tokens": ["and", "it", "does", "have", "a", "reachable", "reference", "until", "(at", "least)", "the", "point", "at", "which", "the", "start()", "tell", "returns", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> start() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "start()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "start()", "label": "API", "asoc": []}]}
{"text": "and it does have a reachable reference until (at least) the point at which the start() indicate returns", "tokens": ["and", "it", "does", "have", "a", "reachable", "reference", "until", "(at", "least)", "the", "point", "at", "which", "the", "start()", "indicate", "returns", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> start() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "start()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "start()", "label": "API", "asoc": []}]}
{"text": "and it does have a reachable reference until (at least) the point at which the start() occur returns", "tokens": ["and", "it", "does", "have", "a", "reachable", "reference", "until", "(at", "least)", "the", "point", "at", "which", "the", "start()", "occur", "returns", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> start() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "start()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "start()", "label": "API", "asoc": []}]}
{"text": "and it does have a reachable reference until (at least) the point at which the start() perform returns", "tokens": ["and", "it", "does", "have", "a", "reachable", "reference", "until", "(at", "least)", "the", "point", "at", "which", "the", "start()", "perform", "returns", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> start() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "start()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "start()", "label": "API", "asoc": []}]}
{"text": "and it does have a reachable reference until (at least) the point at which the start() prompt returns", "tokens": ["and", "it", "does", "have", "a", "reachable", "reference", "until", "(at", "least)", "the", "point", "at", "which", "the", "start()", "prompt", "returns", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> start() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "start()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "start()", "label": "API", "asoc": []}]}
{"text": "and it does have a reachable reference until (at least) the point at which the start() notify returns", "tokens": ["and", "it", "does", "have", "a", "reachable", "reference", "until", "(at", "least)", "the", "point", "at", "which", "the", "start()", "notify", "returns", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> start() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "start()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "start()", "label": "API", "asoc": []}]}
{"text": "and it does have a reachable reference until (at least) the point at which the start() execute returns", "tokens": ["and", "it", "does", "have", "a", "reachable", "reference", "until", "(at", "least)", "the", "point", "at", "which", "the", "start()", "execute", "returns", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> start() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "start()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "start()", "label": "API", "asoc": []}]}
{"text": "and it does have a reachable reference until (at least) the point at which the start() run returns", "tokens": ["and", "it", "does", "have", "a", "reachable", "reference", "until", "(at", "least)", "the", "point", "at", "which", "the", "start()", "run", "returns", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> start() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "start()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "start()", "label": "API", "asoc": []}]}
{"text": "and it does have a reachable reference until (at least) the point at which the start() enforce returns", "tokens": ["and", "it", "does", "have", "a", "reachable", "reference", "until", "(at", "least)", "the", "point", "at", "which", "the", "start()", "enforce", "returns", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> start() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "start()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "start()", "label": "API", "asoc": []}]}
{"text": "and it does have a reachable reference until (at least) the point at which the start() fire returns", "tokens": ["and", "it", "does", "have", "a", "reachable", "reference", "until", "(at", "least)", "the", "point", "at", "which", "the", "start()", "fire", "returns", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> start() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "start()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "start()", "label": "API", "asoc": []}]}
{"text": "and it does have a reachable reference until (at least) the point at which the start() trigger returns", "tokens": ["and", "it", "does", "have", "a", "reachable", "reference", "until", "(at", "least)", "the", "point", "at", "which", "the", "start()", "trigger", "returns", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> start() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "start()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "start()", "label": "API", "asoc": []}]}
{"text": "you call to call next() ; when you get the error", "tokens": ["you", "call", "to", "call", "next()", ";", "when", "you", "get", "the", "error", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "next()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "next()", "label": "API", "asoc": []}]}
{"text": "you invoke to call next() ; when you get the error", "tokens": ["you", "invoke", "to", "call", "next()", ";", "when", "you", "get", "the", "error", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "next()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "next()", "label": "API", "asoc": []}]}
{"text": "you tell to call next() ; when you get the error", "tokens": ["you", "tell", "to", "call", "next()", ";", "when", "you", "get", "the", "error", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "next()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "next()", "label": "API", "asoc": []}]}
{"text": "you indicate to call next() ; when you get the error", "tokens": ["you", "indicate", "to", "call", "next()", ";", "when", "you", "get", "the", "error", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "next()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "next()", "label": "API", "asoc": []}]}
{"text": "you occur to call next() ; when you get the error", "tokens": ["you", "occur", "to", "call", "next()", ";", "when", "you", "get", "the", "error", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "next()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "next()", "label": "API", "asoc": []}]}
{"text": "you perform to call next() ; when you get the error", "tokens": ["you", "perform", "to", "call", "next()", ";", "when", "you", "get", "the", "error", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "next()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "next()", "label": "API", "asoc": []}]}
{"text": "you prompt to call next() ; when you get the error", "tokens": ["you", "prompt", "to", "call", "next()", ";", "when", "you", "get", "the", "error", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "next()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "next()", "label": "API", "asoc": []}]}
{"text": "you notify to call next() ; when you get the error", "tokens": ["you", "notify", "to", "call", "next()", ";", "when", "you", "get", "the", "error", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "next()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "next()", "label": "API", "asoc": []}]}
{"text": "you execute to call next() ; when you get the error", "tokens": ["you", "execute", "to", "call", "next()", ";", "when", "you", "get", "the", "error", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "next()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "next()", "label": "API", "asoc": []}]}
{"text": "you run to call next() ; when you get the error", "tokens": ["you", "run", "to", "call", "next()", ";", "when", "you", "get", "the", "error", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "next()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "next()", "label": "API", "asoc": []}]}
{"text": "you enforce to call next() ; when you get the error", "tokens": ["you", "enforce", "to", "call", "next()", ";", "when", "you", "get", "the", "error", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "next()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "next()", "label": "API", "asoc": []}]}
{"text": "you fire to call next() ; when you get the error", "tokens": ["you", "fire", "to", "call", "next()", ";", "when", "you", "get", "the", "error", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "next()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "next()", "label": "API", "asoc": []}]}
{"text": "you trigger to call next() ; when you get the error", "tokens": ["you", "trigger", "to", "call", "next()", ";", "when", "you", "get", "the", "error", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "next()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "next()", "label": "API", "asoc": []}]}
{"text": "here's the working code: connect an import java.util.concurrent.timeunit", "tokens": ["here's", "the", "working", "code:", "connect", "an", "import", "java.util.concurrent.timeunit", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.concurrent.timeunit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "java.util.concurrent.timeunit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.concurrent.timeunit", "label": "API", "asoc": []}]}
{"text": "here's the working code: associate an import java.util.concurrent.timeunit", "tokens": ["here's", "the", "working", "code:", "associate", "an", "import", "java.util.concurrent.timeunit", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.concurrent.timeunit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "java.util.concurrent.timeunit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.concurrent.timeunit", "label": "API", "asoc": []}]}
{"text": "here's the working code: join an import java.util.concurrent.timeunit", "tokens": ["here's", "the", "working", "code:", "join", "an", "import", "java.util.concurrent.timeunit", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.concurrent.timeunit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "java.util.concurrent.timeunit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.concurrent.timeunit", "label": "API", "asoc": []}]}
{"text": "here's the working code: combine an import java.util.concurrent.timeunit", "tokens": ["here's", "the", "working", "code:", "combine", "an", "import", "java.util.concurrent.timeunit", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.concurrent.timeunit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "java.util.concurrent.timeunit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.concurrent.timeunit", "label": "API", "asoc": []}]}
{"text": "here's the working code: concatenate an import java.util.concurrent.timeunit", "tokens": ["here's", "the", "working", "code:", "concatenate", "an", "import", "java.util.concurrent.timeunit", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.concurrent.timeunit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "java.util.concurrent.timeunit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.concurrent.timeunit", "label": "API", "asoc": []}]}
{"text": "here's the working code: merge an import java.util.concurrent.timeunit", "tokens": ["here's", "the", "working", "code:", "merge", "an", "import", "java.util.concurrent.timeunit", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.concurrent.timeunit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "java.util.concurrent.timeunit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.concurrent.timeunit", "label": "API", "asoc": []}]}
{"text": "here's the working code: concat an import java.util.concurrent.timeunit", "tokens": ["here's", "the", "working", "code:", "concat", "an", "import", "java.util.concurrent.timeunit", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.concurrent.timeunit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "java.util.concurrent.timeunit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.concurrent.timeunit", "label": "API", "asoc": []}]}
{"text": "here's the working code: group an import java.util.concurrent.timeunit", "tokens": ["here's", "the", "working", "code:", "group", "an", "import", "java.util.concurrent.timeunit", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.concurrent.timeunit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "java.util.concurrent.timeunit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.concurrent.timeunit", "label": "API", "asoc": []}]}
{"text": "here's the working code: append an import java.util.concurrent.timeunit", "tokens": ["here's", "the", "working", "code:", "append", "an", "import", "java.util.concurrent.timeunit", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.concurrent.timeunit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "java.util.concurrent.timeunit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.concurrent.timeunit", "label": "API", "asoc": []}]}
{"text": "here's the working code: put an import java.util.concurrent.timeunit", "tokens": ["here's", "the", "working", "code:", "put", "an", "import", "java.util.concurrent.timeunit", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.concurrent.timeunit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "java.util.concurrent.timeunit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.concurrent.timeunit", "label": "API", "asoc": []}]}
{"text": "here's the working code: insert an import java.util.concurrent.timeunit", "tokens": ["here's", "the", "working", "code:", "insert", "an", "import", "java.util.concurrent.timeunit", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.concurrent.timeunit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "java.util.concurrent.timeunit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.concurrent.timeunit", "label": "API", "asoc": []}]}
{"text": "here's the working code: push an import java.util.concurrent.timeunit", "tokens": ["here's", "the", "working", "code:", "push", "an", "import", "java.util.concurrent.timeunit", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.concurrent.timeunit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "java.util.concurrent.timeunit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.concurrent.timeunit", "label": "API", "asoc": []}]}
{"text": "here's the working code: interpolate an import java.util.concurrent.timeunit", "tokens": ["here's", "the", "working", "code:", "interpolate", "an", "import", "java.util.concurrent.timeunit", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.concurrent.timeunit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "java.util.concurrent.timeunit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.concurrent.timeunit", "label": "API", "asoc": []}]}
{"text": "here's the working code: place an import java.util.concurrent.timeunit", "tokens": ["here's", "the", "working", "code:", "place", "an", "import", "java.util.concurrent.timeunit", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.concurrent.timeunit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "java.util.concurrent.timeunit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.concurrent.timeunit", "label": "API", "asoc": []}]}
{"text": "here's the working code: install an import java.util.concurrent.timeunit", "tokens": ["here's", "the", "working", "code:", "install", "an", "import", "java.util.concurrent.timeunit", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.concurrent.timeunit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "java.util.concurrent.timeunit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.concurrent.timeunit", "label": "API", "asoc": []}]}
{"text": "here's the working code: register an import java.util.concurrent.timeunit", "tokens": ["here's", "the", "working", "code:", "register", "an", "import", "java.util.concurrent.timeunit", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.concurrent.timeunit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "java.util.concurrent.timeunit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.concurrent.timeunit", "label": "API", "asoc": []}]}
{"text": "here's the working code: queue an import java.util.concurrent.timeunit", "tokens": ["here's", "the", "working", "code:", "queue", "an", "import", "java.util.concurrent.timeunit", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.concurrent.timeunit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "java.util.concurrent.timeunit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.concurrent.timeunit", "label": "API", "asoc": []}]}
{"text": "here's the working code: enqueue an import java.util.concurrent.timeunit", "tokens": ["here's", "the", "working", "code:", "enqueue", "an", "import", "java.util.concurrent.timeunit", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.concurrent.timeunit <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "java.util.concurrent.timeunit"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.concurrent.timeunit", "label": "API", "asoc": []}]}
{"text": "use the keys() iterator to iterate over all the properties ,  and invoke get() for each .", "tokens": ["use", "the", "keys()", "iterator", "to", "iterate", "over", "all", "the", "properties", ",", "", "and", "invoke", "get()", "for", "each", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> keys() <extra_id_0> logic constraint <extra_id_5> get() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "keys()"}, {"type": "API", "offset": [14], "text": "get()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [2], "text": "keys()"}, {"type": "API", "offset": [14], "text": "get()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "keys()", "label": "API", "asoc": [["logic constraint", "get()"]]}, {"span": "get()", "label": "API", "asoc": []}]}
{"text": "use the keys() iterator to iterate over all the properties ,  and tell get() for each .", "tokens": ["use", "the", "keys()", "iterator", "to", "iterate", "over", "all", "the", "properties", ",", "", "and", "tell", "get()", "for", "each", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> keys() <extra_id_0> logic constraint <extra_id_5> get() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "keys()"}, {"type": "API", "offset": [14], "text": "get()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [2], "text": "keys()"}, {"type": "API", "offset": [14], "text": "get()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "keys()", "label": "API", "asoc": [["logic constraint", "get()"]]}, {"span": "get()", "label": "API", "asoc": []}]}
{"text": "use the keys() iterator to iterate over all the properties ,  and indicate get() for each .", "tokens": ["use", "the", "keys()", "iterator", "to", "iterate", "over", "all", "the", "properties", ",", "", "and", "indicate", "get()", "for", "each", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> keys() <extra_id_0> logic constraint <extra_id_5> get() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "keys()"}, {"type": "API", "offset": [14], "text": "get()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [2], "text": "keys()"}, {"type": "API", "offset": [14], "text": "get()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "keys()", "label": "API", "asoc": [["logic constraint", "get()"]]}, {"span": "get()", "label": "API", "asoc": []}]}
{"text": "use the keys() iterator to iterate over all the properties ,  and occur get() for each .", "tokens": ["use", "the", "keys()", "iterator", "to", "iterate", "over", "all", "the", "properties", ",", "", "and", "occur", "get()", "for", "each", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> keys() <extra_id_0> logic constraint <extra_id_5> get() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "keys()"}, {"type": "API", "offset": [14], "text": "get()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [2], "text": "keys()"}, {"type": "API", "offset": [14], "text": "get()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "keys()", "label": "API", "asoc": [["logic constraint", "get()"]]}, {"span": "get()", "label": "API", "asoc": []}]}
{"text": "use the keys() iterator to iterate over all the properties ,  and perform get() for each .", "tokens": ["use", "the", "keys()", "iterator", "to", "iterate", "over", "all", "the", "properties", ",", "", "and", "perform", "get()", "for", "each", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> keys() <extra_id_0> logic constraint <extra_id_5> get() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "keys()"}, {"type": "API", "offset": [14], "text": "get()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [2], "text": "keys()"}, {"type": "API", "offset": [14], "text": "get()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "keys()", "label": "API", "asoc": [["logic constraint", "get()"]]}, {"span": "get()", "label": "API", "asoc": []}]}
{"text": "use the keys() iterator to iterate over all the properties ,  and prompt get() for each .", "tokens": ["use", "the", "keys()", "iterator", "to", "iterate", "over", "all", "the", "properties", ",", "", "and", "prompt", "get()", "for", "each", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> keys() <extra_id_0> logic constraint <extra_id_5> get() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "keys()"}, {"type": "API", "offset": [14], "text": "get()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [2], "text": "keys()"}, {"type": "API", "offset": [14], "text": "get()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "keys()", "label": "API", "asoc": [["logic constraint", "get()"]]}, {"span": "get()", "label": "API", "asoc": []}]}
{"text": "use the keys() iterator to iterate over all the properties ,  and notify get() for each .", "tokens": ["use", "the", "keys()", "iterator", "to", "iterate", "over", "all", "the", "properties", ",", "", "and", "notify", "get()", "for", "each", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> keys() <extra_id_0> logic constraint <extra_id_5> get() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "keys()"}, {"type": "API", "offset": [14], "text": "get()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [2], "text": "keys()"}, {"type": "API", "offset": [14], "text": "get()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "keys()", "label": "API", "asoc": [["logic constraint", "get()"]]}, {"span": "get()", "label": "API", "asoc": []}]}
{"text": "use the keys() iterator to iterate over all the properties ,  and execute get() for each .", "tokens": ["use", "the", "keys()", "iterator", "to", "iterate", "over", "all", "the", "properties", ",", "", "and", "execute", "get()", "for", "each", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> keys() <extra_id_0> logic constraint <extra_id_5> get() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "keys()"}, {"type": "API", "offset": [14], "text": "get()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [2], "text": "keys()"}, {"type": "API", "offset": [14], "text": "get()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "keys()", "label": "API", "asoc": [["logic constraint", "get()"]]}, {"span": "get()", "label": "API", "asoc": []}]}
{"text": "use the keys() iterator to iterate over all the properties ,  and run get() for each .", "tokens": ["use", "the", "keys()", "iterator", "to", "iterate", "over", "all", "the", "properties", ",", "", "and", "run", "get()", "for", "each", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> keys() <extra_id_0> logic constraint <extra_id_5> get() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "keys()"}, {"type": "API", "offset": [14], "text": "get()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [2], "text": "keys()"}, {"type": "API", "offset": [14], "text": "get()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "keys()", "label": "API", "asoc": [["logic constraint", "get()"]]}, {"span": "get()", "label": "API", "asoc": []}]}
{"text": "use the keys() iterator to iterate over all the properties ,  and enforce get() for each .", "tokens": ["use", "the", "keys()", "iterator", "to", "iterate", "over", "all", "the", "properties", ",", "", "and", "enforce", "get()", "for", "each", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> keys() <extra_id_0> logic constraint <extra_id_5> get() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "keys()"}, {"type": "API", "offset": [14], "text": "get()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [2], "text": "keys()"}, {"type": "API", "offset": [14], "text": "get()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "keys()", "label": "API", "asoc": [["logic constraint", "get()"]]}, {"span": "get()", "label": "API", "asoc": []}]}
{"text": "use the keys() iterator to iterate over all the properties ,  and fire get() for each .", "tokens": ["use", "the", "keys()", "iterator", "to", "iterate", "over", "all", "the", "properties", ",", "", "and", "fire", "get()", "for", "each", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> keys() <extra_id_0> logic constraint <extra_id_5> get() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "keys()"}, {"type": "API", "offset": [14], "text": "get()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [2], "text": "keys()"}, {"type": "API", "offset": [14], "text": "get()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "keys()", "label": "API", "asoc": [["logic constraint", "get()"]]}, {"span": "get()", "label": "API", "asoc": []}]}
{"text": "use the keys() iterator to iterate over all the properties ,  and trigger get() for each .", "tokens": ["use", "the", "keys()", "iterator", "to", "iterate", "over", "all", "the", "properties", ",", "", "and", "trigger", "get()", "for", "each", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> keys() <extra_id_0> logic constraint <extra_id_5> get() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [2], "text": "keys()"}, {"type": "API", "offset": [14], "text": "get()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [2], "text": "keys()"}, {"type": "API", "offset": [14], "text": "get()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "keys()", "label": "API", "asoc": [["logic constraint", "get()"]]}, {"span": "get()", "label": "API", "asoc": []}]}
{"text": "i recommend you test your format strings with the documentation if simpledateformat .", "tokens": ["i", "recommend", "you", "test", "your", "format", "strings", "with", "the", "documentation", "if", "simpledateformat", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> simpledateformat <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "simpledateformat"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "simpledateformat", "label": "API", "asoc": []}]}
{"text": "i recommend you tell your format strings with the documentation if simpledateformat .", "tokens": ["i", "recommend", "you", "tell", "your", "format", "strings", "with", "the", "documentation", "if", "simpledateformat", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> simpledateformat <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "simpledateformat"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "simpledateformat", "label": "API", "asoc": []}]}
{"text": "i recommend you determine your format strings with the documentation if simpledateformat .", "tokens": ["i", "recommend", "you", "determine", "your", "format", "strings", "with", "the", "documentation", "if", "simpledateformat", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> simpledateformat <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "simpledateformat"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "simpledateformat", "label": "API", "asoc": []}]}
{"text": "i recommend you retrieve your format strings with the documentation if simpledateformat .", "tokens": ["i", "recommend", "you", "retrieve", "your", "format", "strings", "with", "the", "documentation", "if", "simpledateformat", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> simpledateformat <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "simpledateformat"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "simpledateformat", "label": "API", "asoc": []}]}
{"text": "i recommend you ascertain your format strings with the documentation if simpledateformat .", "tokens": ["i", "recommend", "you", "ascertain", "your", "format", "strings", "with", "the", "documentation", "if", "simpledateformat", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> simpledateformat <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "simpledateformat"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "simpledateformat", "label": "API", "asoc": []}]}
{"text": "i recommend you return your format strings with the documentation if simpledateformat .", "tokens": ["i", "recommend", "you", "return", "your", "format", "strings", "with", "the", "documentation", "if", "simpledateformat", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> simpledateformat <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "simpledateformat"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "simpledateformat", "label": "API", "asoc": []}]}
{"text": "i recommend you control your format strings with the documentation if simpledateformat .", "tokens": ["i", "recommend", "you", "control", "your", "format", "strings", "with", "the", "documentation", "if", "simpledateformat", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> simpledateformat <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "simpledateformat"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "simpledateformat", "label": "API", "asoc": []}]}
{"text": "i recommend you indicate your format strings with the documentation if simpledateformat .", "tokens": ["i", "recommend", "you", "indicate", "your", "format", "strings", "with", "the", "documentation", "if", "simpledateformat", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> simpledateformat <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "simpledateformat"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "simpledateformat", "label": "API", "asoc": []}]}
{"text": "i recommend you query your format strings with the documentation if simpledateformat .", "tokens": ["i", "recommend", "you", "query", "your", "format", "strings", "with", "the", "documentation", "if", "simpledateformat", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> simpledateformat <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "simpledateformat"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "simpledateformat", "label": "API", "asoc": []}]}
{"text": "i recommend you report your format strings with the documentation if simpledateformat .", "tokens": ["i", "recommend", "you", "report", "your", "format", "strings", "with", "the", "documentation", "if", "simpledateformat", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> simpledateformat <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "simpledateformat"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "simpledateformat", "label": "API", "asoc": []}]}
{"text": "i recommend you validate your format strings with the documentation if simpledateformat .", "tokens": ["i", "recommend", "you", "validate", "your", "format", "strings", "with", "the", "documentation", "if", "simpledateformat", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> simpledateformat <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "simpledateformat"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "simpledateformat", "label": "API", "asoc": []}]}
{"text": "i recommend you get your format strings with the documentation if simpledateformat .", "tokens": ["i", "recommend", "you", "get", "your", "format", "strings", "with", "the", "documentation", "if", "simpledateformat", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> simpledateformat <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "simpledateformat"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "simpledateformat", "label": "API", "asoc": []}]}
{"text": "i recommend you invalidate your format strings with the documentation if simpledateformat .", "tokens": ["i", "recommend", "you", "invalidate", "your", "format", "strings", "with", "the", "documentation", "if", "simpledateformat", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> simpledateformat <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "simpledateformat"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "simpledateformat", "label": "API", "asoc": []}]}
{"text": "i recommend you verify your format strings with the documentation if simpledateformat .", "tokens": ["i", "recommend", "you", "verify", "your", "format", "strings", "with", "the", "documentation", "if", "simpledateformat", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> simpledateformat <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "simpledateformat"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "simpledateformat", "label": "API", "asoc": []}]}
{"text": "i recommend you find your format strings with the documentation if simpledateformat .", "tokens": ["i", "recommend", "you", "find", "your", "format", "strings", "with", "the", "documentation", "if", "simpledateformat", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> simpledateformat <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "simpledateformat"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "simpledateformat", "label": "API", "asoc": []}]}
{"text": "i recommend you identify your format strings with the documentation if simpledateformat .", "tokens": ["i", "recommend", "you", "identify", "your", "format", "strings", "with", "the", "documentation", "if", "simpledateformat", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> simpledateformat <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "simpledateformat"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "simpledateformat", "label": "API", "asoc": []}]}
{"text": "i recommend you track your format strings with the documentation if simpledateformat .", "tokens": ["i", "recommend", "you", "track", "your", "format", "strings", "with", "the", "documentation", "if", "simpledateformat", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> simpledateformat <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "simpledateformat"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "simpledateformat", "label": "API", "asoc": []}]}
{"text": "i recommend you detect your format strings with the documentation if simpledateformat .", "tokens": ["i", "recommend", "you", "detect", "your", "format", "strings", "with", "the", "documentation", "if", "simpledateformat", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> simpledateformat <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "simpledateformat"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "simpledateformat", "label": "API", "asoc": []}]}
{"text": "i recommend you decide your format strings with the documentation if simpledateformat .", "tokens": ["i", "recommend", "you", "decide", "your", "format", "strings", "with", "the", "documentation", "if", "simpledateformat", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> simpledateformat <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "simpledateformat"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "simpledateformat", "label": "API", "asoc": []}]}
{"text": "you can use java inbuilt method java.net.urlencoder to create url with param data", "tokens": ["you", "can", "use", "java", "inbuilt", "method", "java.net.urlencoder", "to", "create", "url", "with", "param", "data", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.net.urlencoder <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "java.net.urlencoder"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.net.urlencoder", "label": "API", "asoc": []}]}
{"text": "you can use java inbuilt method java.net.urlencoder to build url with param data", "tokens": ["you", "can", "use", "java", "inbuilt", "method", "java.net.urlencoder", "to", "build", "url", "with", "param", "data", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.net.urlencoder <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "java.net.urlencoder"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.net.urlencoder", "label": "API", "asoc": []}]}
{"text": "you can use java inbuilt method java.net.urlencoder to produce url with param data", "tokens": ["you", "can", "use", "java", "inbuilt", "method", "java.net.urlencoder", "to", "produce", "url", "with", "param", "data", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.net.urlencoder <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "java.net.urlencoder"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.net.urlencoder", "label": "API", "asoc": []}]}
{"text": "you can use java inbuilt method java.net.urlencoder to generate url with param data", "tokens": ["you", "can", "use", "java", "inbuilt", "method", "java.net.urlencoder", "to", "generate", "url", "with", "param", "data", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.net.urlencoder <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "java.net.urlencoder"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.net.urlencoder", "label": "API", "asoc": []}]}
{"text": "you can use java inbuilt method java.net.urlencoder to establish url with param data", "tokens": ["you", "can", "use", "java", "inbuilt", "method", "java.net.urlencoder", "to", "establish", "url", "with", "param", "data", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.net.urlencoder <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "java.net.urlencoder"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.net.urlencoder", "label": "API", "asoc": []}]}
{"text": "you can use java inbuilt method java.net.urlencoder to make url with param data", "tokens": ["you", "can", "use", "java", "inbuilt", "method", "java.net.urlencoder", "to", "make", "url", "with", "param", "data", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.net.urlencoder <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "java.net.urlencoder"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.net.urlencoder", "label": "API", "asoc": []}]}
{"text": "you can use java inbuilt method java.net.urlencoder to obtain url with param data", "tokens": ["you", "can", "use", "java", "inbuilt", "method", "java.net.urlencoder", "to", "obtain", "url", "with", "param", "data", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.net.urlencoder <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "java.net.urlencoder"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.net.urlencoder", "label": "API", "asoc": []}]}
{"text": "you can use java inbuilt method java.net.urlencoder to reconstitute url with param data", "tokens": ["you", "can", "use", "java", "inbuilt", "method", "java.net.urlencoder", "to", "reconstitute", "url", "with", "param", "data", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.net.urlencoder <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "java.net.urlencoder"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.net.urlencoder", "label": "API", "asoc": []}]}
{"text": "you can use java inbuilt method java.net.urlencoder to compose url with param data", "tokens": ["you", "can", "use", "java", "inbuilt", "method", "java.net.urlencoder", "to", "compose", "url", "with", "param", "data", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.net.urlencoder <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "java.net.urlencoder"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.net.urlencoder", "label": "API", "asoc": []}]}
{"text": "you can use java inbuilt method java.net.urlencoder to instantiate url with param data", "tokens": ["you", "can", "use", "java", "inbuilt", "method", "java.net.urlencoder", "to", "instantiate", "url", "with", "param", "data", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.net.urlencoder <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "java.net.urlencoder"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.net.urlencoder", "label": "API", "asoc": []}]}
{"text": "you can use java inbuilt method java.net.urlencoder to implement url with param data", "tokens": ["you", "can", "use", "java", "inbuilt", "method", "java.net.urlencoder", "to", "implement", "url", "with", "param", "data", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.net.urlencoder <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "java.net.urlencoder"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.net.urlencoder", "label": "API", "asoc": []}]}
{"text": "you can use java inbuilt method java.net.urlencoder to get url with param data", "tokens": ["you", "can", "use", "java", "inbuilt", "method", "java.net.urlencoder", "to", "get", "url", "with", "param", "data", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.net.urlencoder <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "java.net.urlencoder"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.net.urlencoder", "label": "API", "asoc": []}]}
{"text": "you can use java inbuilt method java.net.urlencoder to retrieve url with param data", "tokens": ["you", "can", "use", "java", "inbuilt", "method", "java.net.urlencoder", "to", "retrieve", "url", "with", "param", "data", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.net.urlencoder <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "java.net.urlencoder"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.net.urlencoder", "label": "API", "asoc": []}]}
{"text": "you can use java inbuilt method java.net.urlencoder to return url with param data", "tokens": ["you", "can", "use", "java", "inbuilt", "method", "java.net.urlencoder", "to", "return", "url", "with", "param", "data", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.net.urlencoder <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "java.net.urlencoder"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.net.urlencoder", "label": "API", "asoc": []}]}
{"text": "you can use java inbuilt method java.net.urlencoder to install url with param data", "tokens": ["you", "can", "use", "java", "inbuilt", "method", "java.net.urlencoder", "to", "install", "url", "with", "param", "data", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.net.urlencoder <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "java.net.urlencoder"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.net.urlencoder", "label": "API", "asoc": []}]}
{"text": "you can use java inbuilt method java.net.urlencoder to set up url with param data", "tokens": ["you", "can", "use", "java", "inbuilt", "method", "java.net.urlencoder", "to", "set", "up", "url", "with", "param", "data", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.net.urlencoder <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "java.net.urlencoder"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.net.urlencoder", "label": "API", "asoc": []}]}
{"text": "if you look at the source ,  you see that writeobject() does not store the backing array", "tokens": ["if", "you", "look", "at", "the", "source", ",", "", "you", "see", "that", "writeobject()", "does", "not", "store", "the", "backing", "array", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> writeobject() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "writeobject()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "writeobject()", "label": "API", "asoc": []}]}
{"text": "if you look at the source ,  you see that writeobject() does not dump the backing array", "tokens": ["if", "you", "look", "at", "the", "source", ",", "", "you", "see", "that", "writeobject()", "does", "not", "dump", "the", "backing", "array", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> writeobject() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "writeobject()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "writeobject()", "label": "API", "asoc": []}]}
{"text": "if you look at the source ,  you see that writeobject() does not retain the backing array", "tokens": ["if", "you", "look", "at", "the", "source", ",", "", "you", "see", "that", "writeobject()", "does", "not", "retain", "the", "backing", "array", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> writeobject() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "writeobject()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "writeobject()", "label": "API", "asoc": []}]}
{"text": "if you look at the source ,  you see that writeobject() does not cache the backing array", "tokens": ["if", "you", "look", "at", "the", "source", ",", "", "you", "see", "that", "writeobject()", "does", "not", "cache", "the", "backing", "array", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> writeobject() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "writeobject()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "writeobject()", "label": "API", "asoc": []}]}
{"text": "if you look at the source ,  you see that writeobject() does not stash the backing array", "tokens": ["if", "you", "look", "at", "the", "source", ",", "", "you", "see", "that", "writeobject()", "does", "not", "stash", "the", "backing", "array", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> writeobject() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "writeobject()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "writeobject()", "label": "API", "asoc": []}]}
{"text": "if you look at the source ,  you see that writeobject() does not serialize the backing array", "tokens": ["if", "you", "look", "at", "the", "source", ",", "", "you", "see", "that", "writeobject()", "does", "not", "serialize", "the", "backing", "array", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> writeobject() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "writeobject()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "writeobject()", "label": "API", "asoc": []}]}
{"text": "if you look at the source ,  you see that writeobject() does not deserialize the backing array", "tokens": ["if", "you", "look", "at", "the", "source", ",", "", "you", "see", "that", "writeobject()", "does", "not", "deserialize", "the", "backing", "array", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> writeobject() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "writeobject()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "writeobject()", "label": "API", "asoc": []}]}
{"text": "if you look at the source ,  you see that writeobject() does not persist the backing array", "tokens": ["if", "you", "look", "at", "the", "source", ",", "", "you", "see", "that", "writeobject()", "does", "not", "persist", "the", "backing", "array", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> writeobject() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "writeobject()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "writeobject()", "label": "API", "asoc": []}]}
{"text": "there is a bug in xp where the os invoke system.nanotime() uses is not consistent between sockets so as the thread switches which socket it is running on ,  you can expect to see this jumping around", "tokens": ["there", "is", "a", "bug", "in", "xp", "where", "the", "os", "invoke", "system.nanotime()", "uses", "is", "not", "consistent", "between", "sockets", "so", "as", "the", "thread", "switches", "which", "socket", "it", "is", "running", "on", ",", "", "you", "can", "expect", "to", "see", "this", "jumping", "around", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.nanotime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "system.nanotime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.nanotime()", "label": "API", "asoc": []}]}
{"text": "there is a bug in xp where the os tell system.nanotime() uses is not consistent between sockets so as the thread switches which socket it is running on ,  you can expect to see this jumping around", "tokens": ["there", "is", "a", "bug", "in", "xp", "where", "the", "os", "tell", "system.nanotime()", "uses", "is", "not", "consistent", "between", "sockets", "so", "as", "the", "thread", "switches", "which", "socket", "it", "is", "running", "on", ",", "", "you", "can", "expect", "to", "see", "this", "jumping", "around", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.nanotime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "system.nanotime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.nanotime()", "label": "API", "asoc": []}]}
{"text": "there is a bug in xp where the os indicate system.nanotime() uses is not consistent between sockets so as the thread switches which socket it is running on ,  you can expect to see this jumping around", "tokens": ["there", "is", "a", "bug", "in", "xp", "where", "the", "os", "indicate", "system.nanotime()", "uses", "is", "not", "consistent", "between", "sockets", "so", "as", "the", "thread", "switches", "which", "socket", "it", "is", "running", "on", ",", "", "you", "can", "expect", "to", "see", "this", "jumping", "around", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.nanotime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "system.nanotime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.nanotime()", "label": "API", "asoc": []}]}
{"text": "there is a bug in xp where the os occur system.nanotime() uses is not consistent between sockets so as the thread switches which socket it is running on ,  you can expect to see this jumping around", "tokens": ["there", "is", "a", "bug", "in", "xp", "where", "the", "os", "occur", "system.nanotime()", "uses", "is", "not", "consistent", "between", "sockets", "so", "as", "the", "thread", "switches", "which", "socket", "it", "is", "running", "on", ",", "", "you", "can", "expect", "to", "see", "this", "jumping", "around", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.nanotime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "system.nanotime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.nanotime()", "label": "API", "asoc": []}]}
{"text": "there is a bug in xp where the os perform system.nanotime() uses is not consistent between sockets so as the thread switches which socket it is running on ,  you can expect to see this jumping around", "tokens": ["there", "is", "a", "bug", "in", "xp", "where", "the", "os", "perform", "system.nanotime()", "uses", "is", "not", "consistent", "between", "sockets", "so", "as", "the", "thread", "switches", "which", "socket", "it", "is", "running", "on", ",", "", "you", "can", "expect", "to", "see", "this", "jumping", "around", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.nanotime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "system.nanotime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.nanotime()", "label": "API", "asoc": []}]}
{"text": "there is a bug in xp where the os prompt system.nanotime() uses is not consistent between sockets so as the thread switches which socket it is running on ,  you can expect to see this jumping around", "tokens": ["there", "is", "a", "bug", "in", "xp", "where", "the", "os", "prompt", "system.nanotime()", "uses", "is", "not", "consistent", "between", "sockets", "so", "as", "the", "thread", "switches", "which", "socket", "it", "is", "running", "on", ",", "", "you", "can", "expect", "to", "see", "this", "jumping", "around", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.nanotime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "system.nanotime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.nanotime()", "label": "API", "asoc": []}]}
{"text": "there is a bug in xp where the os notify system.nanotime() uses is not consistent between sockets so as the thread switches which socket it is running on ,  you can expect to see this jumping around", "tokens": ["there", "is", "a", "bug", "in", "xp", "where", "the", "os", "notify", "system.nanotime()", "uses", "is", "not", "consistent", "between", "sockets", "so", "as", "the", "thread", "switches", "which", "socket", "it", "is", "running", "on", ",", "", "you", "can", "expect", "to", "see", "this", "jumping", "around", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.nanotime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "system.nanotime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.nanotime()", "label": "API", "asoc": []}]}
{"text": "there is a bug in xp where the os execute system.nanotime() uses is not consistent between sockets so as the thread switches which socket it is running on ,  you can expect to see this jumping around", "tokens": ["there", "is", "a", "bug", "in", "xp", "where", "the", "os", "execute", "system.nanotime()", "uses", "is", "not", "consistent", "between", "sockets", "so", "as", "the", "thread", "switches", "which", "socket", "it", "is", "running", "on", ",", "", "you", "can", "expect", "to", "see", "this", "jumping", "around", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.nanotime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "system.nanotime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.nanotime()", "label": "API", "asoc": []}]}
{"text": "there is a bug in xp where the os run system.nanotime() uses is not consistent between sockets so as the thread switches which socket it is running on ,  you can expect to see this jumping around", "tokens": ["there", "is", "a", "bug", "in", "xp", "where", "the", "os", "run", "system.nanotime()", "uses", "is", "not", "consistent", "between", "sockets", "so", "as", "the", "thread", "switches", "which", "socket", "it", "is", "running", "on", ",", "", "you", "can", "expect", "to", "see", "this", "jumping", "around", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.nanotime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "system.nanotime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.nanotime()", "label": "API", "asoc": []}]}
{"text": "there is a bug in xp where the os enforce system.nanotime() uses is not consistent between sockets so as the thread switches which socket it is running on ,  you can expect to see this jumping around", "tokens": ["there", "is", "a", "bug", "in", "xp", "where", "the", "os", "enforce", "system.nanotime()", "uses", "is", "not", "consistent", "between", "sockets", "so", "as", "the", "thread", "switches", "which", "socket", "it", "is", "running", "on", ",", "", "you", "can", "expect", "to", "see", "this", "jumping", "around", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.nanotime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "system.nanotime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.nanotime()", "label": "API", "asoc": []}]}
{"text": "there is a bug in xp where the os fire system.nanotime() uses is not consistent between sockets so as the thread switches which socket it is running on ,  you can expect to see this jumping around", "tokens": ["there", "is", "a", "bug", "in", "xp", "where", "the", "os", "fire", "system.nanotime()", "uses", "is", "not", "consistent", "between", "sockets", "so", "as", "the", "thread", "switches", "which", "socket", "it", "is", "running", "on", ",", "", "you", "can", "expect", "to", "see", "this", "jumping", "around", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.nanotime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "system.nanotime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.nanotime()", "label": "API", "asoc": []}]}
{"text": "there is a bug in xp where the os trigger system.nanotime() uses is not consistent between sockets so as the thread switches which socket it is running on ,  you can expect to see this jumping around", "tokens": ["there", "is", "a", "bug", "in", "xp", "where", "the", "os", "trigger", "system.nanotime()", "uses", "is", "not", "consistent", "between", "sockets", "so", "as", "the", "thread", "switches", "which", "socket", "it", "is", "running", "on", ",", "", "you", "can", "expect", "to", "see", "this", "jumping", "around", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.nanotime() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "system.nanotime()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.nanotime()", "label": "API", "asoc": []}]}
{"text": "for sorting primarily by age ,  and then by name in case of ties: connect that with arrays.sort ,  and you are done .", "tokens": ["for", "sorting", "primarily", "by", "age", ",", "", "and", "then", "by", "name", "in", "case", "of", "ties:", "connect", "that", "with", "arrays.sort", ",", "", "and", "you", "are", "done", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "arrays.sort"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort", "label": "API", "asoc": []}]}
{"text": "for sorting primarily by age ,  and then by name in case of ties: associate that with arrays.sort ,  and you are done .", "tokens": ["for", "sorting", "primarily", "by", "age", ",", "", "and", "then", "by", "name", "in", "case", "of", "ties:", "associate", "that", "with", "arrays.sort", ",", "", "and", "you", "are", "done", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "arrays.sort"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort", "label": "API", "asoc": []}]}
{"text": "for sorting primarily by age ,  and then by name in case of ties: join that with arrays.sort ,  and you are done .", "tokens": ["for", "sorting", "primarily", "by", "age", ",", "", "and", "then", "by", "name", "in", "case", "of", "ties:", "join", "that", "with", "arrays.sort", ",", "", "and", "you", "are", "done", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "arrays.sort"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort", "label": "API", "asoc": []}]}
{"text": "for sorting primarily by age ,  and then by name in case of ties: concatenate that with arrays.sort ,  and you are done .", "tokens": ["for", "sorting", "primarily", "by", "age", ",", "", "and", "then", "by", "name", "in", "case", "of", "ties:", "concatenate", "that", "with", "arrays.sort", ",", "", "and", "you", "are", "done", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "arrays.sort"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort", "label": "API", "asoc": []}]}
{"text": "for sorting primarily by age ,  and then by name in case of ties: merge that with arrays.sort ,  and you are done .", "tokens": ["for", "sorting", "primarily", "by", "age", ",", "", "and", "then", "by", "name", "in", "case", "of", "ties:", "merge", "that", "with", "arrays.sort", ",", "", "and", "you", "are", "done", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "arrays.sort"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort", "label": "API", "asoc": []}]}
{"text": "for sorting primarily by age ,  and then by name in case of ties: concat that with arrays.sort ,  and you are done .", "tokens": ["for", "sorting", "primarily", "by", "age", ",", "", "and", "then", "by", "name", "in", "case", "of", "ties:", "concat", "that", "with", "arrays.sort", ",", "", "and", "you", "are", "done", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "arrays.sort"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort", "label": "API", "asoc": []}]}
{"text": "for sorting primarily by age ,  and then by name in case of ties: add that with arrays.sort ,  and you are done .", "tokens": ["for", "sorting", "primarily", "by", "age", ",", "", "and", "then", "by", "name", "in", "case", "of", "ties:", "add", "that", "with", "arrays.sort", ",", "", "and", "you", "are", "done", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "arrays.sort"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort", "label": "API", "asoc": []}]}
{"text": "for sorting primarily by age ,  and then by name in case of ties: group that with arrays.sort ,  and you are done .", "tokens": ["for", "sorting", "primarily", "by", "age", ",", "", "and", "then", "by", "name", "in", "case", "of", "ties:", "group", "that", "with", "arrays.sort", ",", "", "and", "you", "are", "done", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.sort <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "arrays.sort"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.sort", "label": "API", "asoc": []}]}
{"text": "the exception in your stacktrace says which essentially means that getcolumnindex() could not query the specified column in the cursor and -1 was returned as column index", "tokens": ["the", "exception", "in", "your", "stacktrace", "says", "which", "essentially", "means", "that", "getcolumnindex()", "could", "not", "query", "the", "specified", "column", "in", "the", "cursor", "and", "-1", "was", "returned", "as", "column", "index", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumnindex() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolumnindex()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumnindex()", "label": "API", "asoc": []}]}
{"text": "the exception in your stacktrace says which essentially means that getcolumnindex() could not locate the specified column in the cursor and -1 was returned as column index", "tokens": ["the", "exception", "in", "your", "stacktrace", "says", "which", "essentially", "means", "that", "getcolumnindex()", "could", "not", "locate", "the", "specified", "column", "in", "the", "cursor", "and", "-1", "was", "returned", "as", "column", "index", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumnindex() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolumnindex()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumnindex()", "label": "API", "asoc": []}]}
{"text": "the exception in your stacktrace says which essentially means that getcolumnindex() could not determine the specified column in the cursor and -1 was returned as column index", "tokens": ["the", "exception", "in", "your", "stacktrace", "says", "which", "essentially", "means", "that", "getcolumnindex()", "could", "not", "determine", "the", "specified", "column", "in", "the", "cursor", "and", "-1", "was", "returned", "as", "column", "index", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumnindex() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolumnindex()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumnindex()", "label": "API", "asoc": []}]}
{"text": "the exception in your stacktrace says which essentially means that getcolumnindex() could not retrieve the specified column in the cursor and -1 was returned as column index", "tokens": ["the", "exception", "in", "your", "stacktrace", "says", "which", "essentially", "means", "that", "getcolumnindex()", "could", "not", "retrieve", "the", "specified", "column", "in", "the", "cursor", "and", "-1", "was", "returned", "as", "column", "index", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumnindex() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolumnindex()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumnindex()", "label": "API", "asoc": []}]}
{"text": "the exception in your stacktrace says which essentially means that getcolumnindex() could not visit the specified column in the cursor and -1 was returned as column index", "tokens": ["the", "exception", "in", "your", "stacktrace", "says", "which", "essentially", "means", "that", "getcolumnindex()", "could", "not", "visit", "the", "specified", "column", "in", "the", "cursor", "and", "-1", "was", "returned", "as", "column", "index", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumnindex() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolumnindex()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumnindex()", "label": "API", "asoc": []}]}
{"text": "the exception in your stacktrace says which essentially means that getcolumnindex() could not look the specified column in the cursor and -1 was returned as column index", "tokens": ["the", "exception", "in", "your", "stacktrace", "says", "which", "essentially", "means", "that", "getcolumnindex()", "could", "not", "look", "the", "specified", "column", "in", "the", "cursor", "and", "-1", "was", "returned", "as", "column", "index", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumnindex() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolumnindex()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumnindex()", "label": "API", "asoc": []}]}
{"text": "the exception in your stacktrace says which essentially means that getcolumnindex() could not search the specified column in the cursor and -1 was returned as column index", "tokens": ["the", "exception", "in", "your", "stacktrace", "says", "which", "essentially", "means", "that", "getcolumnindex()", "could", "not", "search", "the", "specified", "column", "in", "the", "cursor", "and", "-1", "was", "returned", "as", "column", "index", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumnindex() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolumnindex()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumnindex()", "label": "API", "asoc": []}]}
{"text": "the exception in your stacktrace says which essentially means that getcolumnindex() could not discover the specified column in the cursor and -1 was returned as column index", "tokens": ["the", "exception", "in", "your", "stacktrace", "says", "which", "essentially", "means", "that", "getcolumnindex()", "could", "not", "discover", "the", "specified", "column", "in", "the", "cursor", "and", "-1", "was", "returned", "as", "column", "index", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumnindex() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolumnindex()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumnindex()", "label": "API", "asoc": []}]}
{"text": "the exception in your stacktrace says which essentially means that getcolumnindex() could not seek the specified column in the cursor and -1 was returned as column index", "tokens": ["the", "exception", "in", "your", "stacktrace", "says", "which", "essentially", "means", "that", "getcolumnindex()", "could", "not", "seek", "the", "specified", "column", "in", "the", "cursor", "and", "-1", "was", "returned", "as", "column", "index", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumnindex() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolumnindex()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumnindex()", "label": "API", "asoc": []}]}
{"text": "the exception in your stacktrace says which essentially means that getcolumnindex() could not look up the specified column in the cursor and -1 was returned as column index", "tokens": ["the", "exception", "in", "your", "stacktrace", "says", "which", "essentially", "means", "that", "getcolumnindex()", "could", "not", "look", "up", "the", "specified", "column", "in", "the", "cursor", "and", "-1", "was", "returned", "as", "column", "index", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumnindex() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolumnindex()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumnindex()", "label": "API", "asoc": []}]}
{"text": "the exception in your stacktrace says which essentially means that getcolumnindex() could not test the specified column in the cursor and -1 was returned as column index", "tokens": ["the", "exception", "in", "your", "stacktrace", "says", "which", "essentially", "means", "that", "getcolumnindex()", "could", "not", "test", "the", "specified", "column", "in", "the", "cursor", "and", "-1", "was", "returned", "as", "column", "index", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumnindex() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolumnindex()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumnindex()", "label": "API", "asoc": []}]}
{"text": "the exception in your stacktrace says which essentially means that getcolumnindex() could not tell the specified column in the cursor and -1 was returned as column index", "tokens": ["the", "exception", "in", "your", "stacktrace", "says", "which", "essentially", "means", "that", "getcolumnindex()", "could", "not", "tell", "the", "specified", "column", "in", "the", "cursor", "and", "-1", "was", "returned", "as", "column", "index", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumnindex() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolumnindex()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumnindex()", "label": "API", "asoc": []}]}
{"text": "the exception in your stacktrace says which essentially means that getcolumnindex() could not check the specified column in the cursor and -1 was returned as column index", "tokens": ["the", "exception", "in", "your", "stacktrace", "says", "which", "essentially", "means", "that", "getcolumnindex()", "could", "not", "check", "the", "specified", "column", "in", "the", "cursor", "and", "-1", "was", "returned", "as", "column", "index", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumnindex() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolumnindex()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumnindex()", "label": "API", "asoc": []}]}
{"text": "the exception in your stacktrace says which essentially means that getcolumnindex() could not ascertain the specified column in the cursor and -1 was returned as column index", "tokens": ["the", "exception", "in", "your", "stacktrace", "says", "which", "essentially", "means", "that", "getcolumnindex()", "could", "not", "ascertain", "the", "specified", "column", "in", "the", "cursor", "and", "-1", "was", "returned", "as", "column", "index", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumnindex() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolumnindex()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumnindex()", "label": "API", "asoc": []}]}
{"text": "the exception in your stacktrace says which essentially means that getcolumnindex() could not return the specified column in the cursor and -1 was returned as column index", "tokens": ["the", "exception", "in", "your", "stacktrace", "says", "which", "essentially", "means", "that", "getcolumnindex()", "could", "not", "return", "the", "specified", "column", "in", "the", "cursor", "and", "-1", "was", "returned", "as", "column", "index", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumnindex() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolumnindex()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumnindex()", "label": "API", "asoc": []}]}
{"text": "the exception in your stacktrace says which essentially means that getcolumnindex() could not control the specified column in the cursor and -1 was returned as column index", "tokens": ["the", "exception", "in", "your", "stacktrace", "says", "which", "essentially", "means", "that", "getcolumnindex()", "could", "not", "control", "the", "specified", "column", "in", "the", "cursor", "and", "-1", "was", "returned", "as", "column", "index", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumnindex() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolumnindex()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumnindex()", "label": "API", "asoc": []}]}
{"text": "the exception in your stacktrace says which essentially means that getcolumnindex() could not indicate the specified column in the cursor and -1 was returned as column index", "tokens": ["the", "exception", "in", "your", "stacktrace", "says", "which", "essentially", "means", "that", "getcolumnindex()", "could", "not", "indicate", "the", "specified", "column", "in", "the", "cursor", "and", "-1", "was", "returned", "as", "column", "index", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumnindex() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolumnindex()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumnindex()", "label": "API", "asoc": []}]}
{"text": "the exception in your stacktrace says which essentially means that getcolumnindex() could not report the specified column in the cursor and -1 was returned as column index", "tokens": ["the", "exception", "in", "your", "stacktrace", "says", "which", "essentially", "means", "that", "getcolumnindex()", "could", "not", "report", "the", "specified", "column", "in", "the", "cursor", "and", "-1", "was", "returned", "as", "column", "index", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumnindex() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolumnindex()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumnindex()", "label": "API", "asoc": []}]}
{"text": "the exception in your stacktrace says which essentially means that getcolumnindex() could not validate the specified column in the cursor and -1 was returned as column index", "tokens": ["the", "exception", "in", "your", "stacktrace", "says", "which", "essentially", "means", "that", "getcolumnindex()", "could", "not", "validate", "the", "specified", "column", "in", "the", "cursor", "and", "-1", "was", "returned", "as", "column", "index", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumnindex() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolumnindex()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumnindex()", "label": "API", "asoc": []}]}
{"text": "the exception in your stacktrace says which essentially means that getcolumnindex() could not get the specified column in the cursor and -1 was returned as column index", "tokens": ["the", "exception", "in", "your", "stacktrace", "says", "which", "essentially", "means", "that", "getcolumnindex()", "could", "not", "get", "the", "specified", "column", "in", "the", "cursor", "and", "-1", "was", "returned", "as", "column", "index", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumnindex() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolumnindex()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumnindex()", "label": "API", "asoc": []}]}
{"text": "the exception in your stacktrace says which essentially means that getcolumnindex() could not invalidate the specified column in the cursor and -1 was returned as column index", "tokens": ["the", "exception", "in", "your", "stacktrace", "says", "which", "essentially", "means", "that", "getcolumnindex()", "could", "not", "invalidate", "the", "specified", "column", "in", "the", "cursor", "and", "-1", "was", "returned", "as", "column", "index", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumnindex() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolumnindex()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumnindex()", "label": "API", "asoc": []}]}
{"text": "the exception in your stacktrace says which essentially means that getcolumnindex() could not verify the specified column in the cursor and -1 was returned as column index", "tokens": ["the", "exception", "in", "your", "stacktrace", "says", "which", "essentially", "means", "that", "getcolumnindex()", "could", "not", "verify", "the", "specified", "column", "in", "the", "cursor", "and", "-1", "was", "returned", "as", "column", "index", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumnindex() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolumnindex()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumnindex()", "label": "API", "asoc": []}]}
{"text": "the exception in your stacktrace says which essentially means that getcolumnindex() could not identify the specified column in the cursor and -1 was returned as column index", "tokens": ["the", "exception", "in", "your", "stacktrace", "says", "which", "essentially", "means", "that", "getcolumnindex()", "could", "not", "identify", "the", "specified", "column", "in", "the", "cursor", "and", "-1", "was", "returned", "as", "column", "index", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumnindex() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolumnindex()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumnindex()", "label": "API", "asoc": []}]}
{"text": "the exception in your stacktrace says which essentially means that getcolumnindex() could not track the specified column in the cursor and -1 was returned as column index", "tokens": ["the", "exception", "in", "your", "stacktrace", "says", "which", "essentially", "means", "that", "getcolumnindex()", "could", "not", "track", "the", "specified", "column", "in", "the", "cursor", "and", "-1", "was", "returned", "as", "column", "index", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumnindex() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolumnindex()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumnindex()", "label": "API", "asoc": []}]}
{"text": "the exception in your stacktrace says which essentially means that getcolumnindex() could not detect the specified column in the cursor and -1 was returned as column index", "tokens": ["the", "exception", "in", "your", "stacktrace", "says", "which", "essentially", "means", "that", "getcolumnindex()", "could", "not", "detect", "the", "specified", "column", "in", "the", "cursor", "and", "-1", "was", "returned", "as", "column", "index", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumnindex() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolumnindex()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumnindex()", "label": "API", "asoc": []}]}
{"text": "the exception in your stacktrace says which essentially means that getcolumnindex() could not decide the specified column in the cursor and -1 was returned as column index", "tokens": ["the", "exception", "in", "your", "stacktrace", "says", "which", "essentially", "means", "that", "getcolumnindex()", "could", "not", "decide", "the", "specified", "column", "in", "the", "cursor", "and", "-1", "was", "returned", "as", "column", "index", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcolumnindex() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "getcolumnindex()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcolumnindex()", "label": "API", "asoc": []}]}
{"text": "one thing you could do is use nextline() instead ,  then explicitly try and resolve the returned string into an integer", "tokens": ["one", "thing", "you", "could", "do", "is", "use", "nextline()", "instead", ",", "", "then", "explicitly", "try", "and", "resolve", "the", "returned", "string", "into", "an", "integer", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextline() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "nextline()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nextline()", "label": "API", "asoc": []}]}
{"text": "one thing you could do is use nextline() instead ,  then explicitly try and unwrap the returned string into an integer", "tokens": ["one", "thing", "you", "could", "do", "is", "use", "nextline()", "instead", ",", "", "then", "explicitly", "try", "and", "unwrap", "the", "returned", "string", "into", "an", "integer", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextline() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "nextline()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nextline()", "label": "API", "asoc": []}]}
{"text": "one thing you could do is use nextline() instead ,  then explicitly try and analyze the returned string into an integer", "tokens": ["one", "thing", "you", "could", "do", "is", "use", "nextline()", "instead", ",", "", "then", "explicitly", "try", "and", "analyze", "the", "returned", "string", "into", "an", "integer", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextline() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "nextline()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nextline()", "label": "API", "asoc": []}]}
{"text": "one thing you could do is use nextline() instead ,  then explicitly try and uncompress the returned string into an integer", "tokens": ["one", "thing", "you", "could", "do", "is", "use", "nextline()", "instead", ",", "", "then", "explicitly", "try", "and", "uncompress", "the", "returned", "string", "into", "an", "integer", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextline() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "nextline()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nextline()", "label": "API", "asoc": []}]}
{"text": "one thing you could do is use nextline() instead ,  then explicitly try and decode the returned string into an integer", "tokens": ["one", "thing", "you", "could", "do", "is", "use", "nextline()", "instead", ",", "", "then", "explicitly", "try", "and", "decode", "the", "returned", "string", "into", "an", "integer", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextline() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "nextline()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nextline()", "label": "API", "asoc": []}]}
{"text": "one thing you could do is use nextline() instead ,  then explicitly try and flatten the returned string into an integer", "tokens": ["one", "thing", "you", "could", "do", "is", "use", "nextline()", "instead", ",", "", "then", "explicitly", "try", "and", "flatten", "the", "returned", "string", "into", "an", "integer", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextline() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "nextline()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nextline()", "label": "API", "asoc": []}]}
{"text": "one thing you could do is use nextline() instead ,  then explicitly try and unmarshal the returned string into an integer", "tokens": ["one", "thing", "you", "could", "do", "is", "use", "nextline()", "instead", ",", "", "then", "explicitly", "try", "and", "unmarshal", "the", "returned", "string", "into", "an", "integer", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> nextline() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "nextline()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "nextline()", "label": "API", "asoc": []}]}
{"text": "if you want this \"as a string\" ,  the closest thing is to invoke tostring() on the jsonobject location", "tokens": ["if", "you", "want", "this", "\"as", "a", "string\"", ",", "", "the", "closest", "thing", "is", "to", "invoke", "tostring()", "on", "the", "jsonobject", "location", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "if you want this \"as a string\" ,  the closest thing is to tell tostring() on the jsonobject location", "tokens": ["if", "you", "want", "this", "\"as", "a", "string\"", ",", "", "the", "closest", "thing", "is", "to", "tell", "tostring()", "on", "the", "jsonobject", "location", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "if you want this \"as a string\" ,  the closest thing is to indicate tostring() on the jsonobject location", "tokens": ["if", "you", "want", "this", "\"as", "a", "string\"", ",", "", "the", "closest", "thing", "is", "to", "indicate", "tostring()", "on", "the", "jsonobject", "location", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "if you want this \"as a string\" ,  the closest thing is to occur tostring() on the jsonobject location", "tokens": ["if", "you", "want", "this", "\"as", "a", "string\"", ",", "", "the", "closest", "thing", "is", "to", "occur", "tostring()", "on", "the", "jsonobject", "location", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "if you want this \"as a string\" ,  the closest thing is to perform tostring() on the jsonobject location", "tokens": ["if", "you", "want", "this", "\"as", "a", "string\"", ",", "", "the", "closest", "thing", "is", "to", "perform", "tostring()", "on", "the", "jsonobject", "location", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "if you want this \"as a string\" ,  the closest thing is to prompt tostring() on the jsonobject location", "tokens": ["if", "you", "want", "this", "\"as", "a", "string\"", ",", "", "the", "closest", "thing", "is", "to", "prompt", "tostring()", "on", "the", "jsonobject", "location", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "if you want this \"as a string\" ,  the closest thing is to notify tostring() on the jsonobject location", "tokens": ["if", "you", "want", "this", "\"as", "a", "string\"", ",", "", "the", "closest", "thing", "is", "to", "notify", "tostring()", "on", "the", "jsonobject", "location", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "if you want this \"as a string\" ,  the closest thing is to execute tostring() on the jsonobject location", "tokens": ["if", "you", "want", "this", "\"as", "a", "string\"", ",", "", "the", "closest", "thing", "is", "to", "execute", "tostring()", "on", "the", "jsonobject", "location", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "if you want this \"as a string\" ,  the closest thing is to run tostring() on the jsonobject location", "tokens": ["if", "you", "want", "this", "\"as", "a", "string\"", ",", "", "the", "closest", "thing", "is", "to", "run", "tostring()", "on", "the", "jsonobject", "location", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "if you want this \"as a string\" ,  the closest thing is to enforce tostring() on the jsonobject location", "tokens": ["if", "you", "want", "this", "\"as", "a", "string\"", ",", "", "the", "closest", "thing", "is", "to", "enforce", "tostring()", "on", "the", "jsonobject", "location", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "if you want this \"as a string\" ,  the closest thing is to fire tostring() on the jsonobject location", "tokens": ["if", "you", "want", "this", "\"as", "a", "string\"", ",", "", "the", "closest", "thing", "is", "to", "fire", "tostring()", "on", "the", "jsonobject", "location", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "if you want this \"as a string\" ,  the closest thing is to trigger tostring() on the jsonobject location", "tokens": ["if", "you", "want", "this", "\"as", "a", "string\"", ",", "", "the", "closest", "thing", "is", "to", "trigger", "tostring()", "on", "the", "jsonobject", "location", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> tostring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "tostring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "tostring()", "label": "API", "asoc": []}]}
{"text": "for example ,  the call to files.lines doesn't actually load the file until you add a terminal operation on the stream .", "tokens": ["for", "example", ",", "", "the", "call", "to", "files.lines", "doesn't", "actually", "load", "the", "file", "until", "you", "add", "a", "terminal", "operation", "on", "the", "stream", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> files.lines <extra_id_0> logic constraint <extra_id_5> stream <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> stream <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "files.lines"}, {"type": "API", "offset": [21], "text": "stream"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [7], "text": "files.lines"}, {"type": "API", "offset": [21], "text": "stream"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "files.lines", "label": "API", "asoc": [["logic constraint", "stream"]]}, {"span": "stream", "label": "API", "asoc": []}]}
{"text": "for example ,  the call to files.lines doesn't actually reload the file until you add a terminal operation on the stream .", "tokens": ["for", "example", ",", "", "the", "call", "to", "files.lines", "doesn't", "actually", "reload", "the", "file", "until", "you", "add", "a", "terminal", "operation", "on", "the", "stream", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> files.lines <extra_id_0> logic constraint <extra_id_5> stream <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> stream <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "files.lines"}, {"type": "API", "offset": [21], "text": "stream"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [7], "text": "files.lines"}, {"type": "API", "offset": [21], "text": "stream"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "files.lines", "label": "API", "asoc": [["logic constraint", "stream"]]}, {"span": "stream", "label": "API", "asoc": []}]}
{"text": "since java doesn't support primitive collections there is no easy way to use arrays.aslist to package a primitive array", "tokens": ["since", "java", "doesn't", "support", "primitive", "collections", "there", "is", "no", "easy", "way", "to", "use", "arrays.aslist", "to", "package", "a", "primitive", "array", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.aslist <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "arrays.aslist"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.aslist", "label": "API", "asoc": []}]}
{"text": "since java doesn't support primitive collections there is no easy way to use arrays.aslist to encode a primitive array", "tokens": ["since", "java", "doesn't", "support", "primitive", "collections", "there", "is", "no", "easy", "way", "to", "use", "arrays.aslist", "to", "encode", "a", "primitive", "array", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.aslist <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "arrays.aslist"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.aslist", "label": "API", "asoc": []}]}
{"text": "since java doesn't support primitive collections there is no easy way to use arrays.aslist to marshal a primitive array", "tokens": ["since", "java", "doesn't", "support", "primitive", "collections", "there", "is", "no", "easy", "way", "to", "use", "arrays.aslist", "to", "marshal", "a", "primitive", "array", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.aslist <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "arrays.aslist"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.aslist", "label": "API", "asoc": []}]}
{"text": "since java doesn't support primitive collections there is no easy way to use arrays.aslist to synthesize a primitive array", "tokens": ["since", "java", "doesn't", "support", "primitive", "collections", "there", "is", "no", "easy", "way", "to", "use", "arrays.aslist", "to", "synthesize", "a", "primitive", "array", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.aslist <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "arrays.aslist"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.aslist", "label": "API", "asoc": []}]}
{"text": "since java doesn't support primitive collections there is no easy way to use arrays.aslist to compress a primitive array", "tokens": ["since", "java", "doesn't", "support", "primitive", "collections", "there", "is", "no", "easy", "way", "to", "use", "arrays.aslist", "to", "compress", "a", "primitive", "array", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.aslist <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "arrays.aslist"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.aslist", "label": "API", "asoc": []}]}
{"text": "since java doesn't support primitive collections there is no easy way to use arrays.aslist to pack a primitive array", "tokens": ["since", "java", "doesn't", "support", "primitive", "collections", "there", "is", "no", "easy", "way", "to", "use", "arrays.aslist", "to", "pack", "a", "primitive", "array", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.aslist <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "arrays.aslist"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.aslist", "label": "API", "asoc": []}]}
{"text": "since java doesn't support primitive collections there is no easy way to use arrays.aslist to compact a primitive array", "tokens": ["since", "java", "doesn't", "support", "primitive", "collections", "there", "is", "no", "easy", "way", "to", "use", "arrays.aslist", "to", "compact", "a", "primitive", "array", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.aslist <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "arrays.aslist"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.aslist", "label": "API", "asoc": []}]}
{"text": "since java doesn't support primitive collections there is no easy way to use arrays.aslist to encrypt a primitive array", "tokens": ["since", "java", "doesn't", "support", "primitive", "collections", "there", "is", "no", "easy", "way", "to", "use", "arrays.aslist", "to", "encrypt", "a", "primitive", "array", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.aslist <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "arrays.aslist"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.aslist", "label": "API", "asoc": []}]}
{"text": "since java doesn't support primitive collections there is no easy way to use arrays.aslist to escape a primitive array", "tokens": ["since", "java", "doesn't", "support", "primitive", "collections", "there", "is", "no", "easy", "way", "to", "use", "arrays.aslist", "to", "escape", "a", "primitive", "array", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.aslist <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "arrays.aslist"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.aslist", "label": "API", "asoc": []}]}
{"text": "so when you invoke arrays.aslist(ar) the arrays creates a list with exactly one item - the int array ar", "tokens": ["so", "when", "you", "invoke", "arrays.aslist(ar)", "the", "arrays", "creates", "a", "list", "with", "exactly", "one", "item", "-", "the", "int", "array", "ar", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.aslist(ar) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "arrays.aslist(ar)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.aslist(ar)", "label": "API", "asoc": []}]}
{"text": "so when you tell arrays.aslist(ar) the arrays creates a list with exactly one item - the int array ar", "tokens": ["so", "when", "you", "tell", "arrays.aslist(ar)", "the", "arrays", "creates", "a", "list", "with", "exactly", "one", "item", "-", "the", "int", "array", "ar", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.aslist(ar) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "arrays.aslist(ar)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.aslist(ar)", "label": "API", "asoc": []}]}
{"text": "so when you indicate arrays.aslist(ar) the arrays creates a list with exactly one item - the int array ar", "tokens": ["so", "when", "you", "indicate", "arrays.aslist(ar)", "the", "arrays", "creates", "a", "list", "with", "exactly", "one", "item", "-", "the", "int", "array", "ar", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.aslist(ar) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "arrays.aslist(ar)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.aslist(ar)", "label": "API", "asoc": []}]}
{"text": "so when you occur arrays.aslist(ar) the arrays creates a list with exactly one item - the int array ar", "tokens": ["so", "when", "you", "occur", "arrays.aslist(ar)", "the", "arrays", "creates", "a", "list", "with", "exactly", "one", "item", "-", "the", "int", "array", "ar", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.aslist(ar) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "arrays.aslist(ar)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.aslist(ar)", "label": "API", "asoc": []}]}
{"text": "so when you perform arrays.aslist(ar) the arrays creates a list with exactly one item - the int array ar", "tokens": ["so", "when", "you", "perform", "arrays.aslist(ar)", "the", "arrays", "creates", "a", "list", "with", "exactly", "one", "item", "-", "the", "int", "array", "ar", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.aslist(ar) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "arrays.aslist(ar)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.aslist(ar)", "label": "API", "asoc": []}]}
{"text": "so when you prompt arrays.aslist(ar) the arrays creates a list with exactly one item - the int array ar", "tokens": ["so", "when", "you", "prompt", "arrays.aslist(ar)", "the", "arrays", "creates", "a", "list", "with", "exactly", "one", "item", "-", "the", "int", "array", "ar", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.aslist(ar) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "arrays.aslist(ar)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.aslist(ar)", "label": "API", "asoc": []}]}
{"text": "so when you notify arrays.aslist(ar) the arrays creates a list with exactly one item - the int array ar", "tokens": ["so", "when", "you", "notify", "arrays.aslist(ar)", "the", "arrays", "creates", "a", "list", "with", "exactly", "one", "item", "-", "the", "int", "array", "ar", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.aslist(ar) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "arrays.aslist(ar)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.aslist(ar)", "label": "API", "asoc": []}]}
{"text": "so when you execute arrays.aslist(ar) the arrays creates a list with exactly one item - the int array ar", "tokens": ["so", "when", "you", "execute", "arrays.aslist(ar)", "the", "arrays", "creates", "a", "list", "with", "exactly", "one", "item", "-", "the", "int", "array", "ar", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.aslist(ar) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "arrays.aslist(ar)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.aslist(ar)", "label": "API", "asoc": []}]}
{"text": "so when you run arrays.aslist(ar) the arrays creates a list with exactly one item - the int array ar", "tokens": ["so", "when", "you", "run", "arrays.aslist(ar)", "the", "arrays", "creates", "a", "list", "with", "exactly", "one", "item", "-", "the", "int", "array", "ar", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.aslist(ar) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "arrays.aslist(ar)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.aslist(ar)", "label": "API", "asoc": []}]}
{"text": "so when you enforce arrays.aslist(ar) the arrays creates a list with exactly one item - the int array ar", "tokens": ["so", "when", "you", "enforce", "arrays.aslist(ar)", "the", "arrays", "creates", "a", "list", "with", "exactly", "one", "item", "-", "the", "int", "array", "ar", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.aslist(ar) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "arrays.aslist(ar)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.aslist(ar)", "label": "API", "asoc": []}]}
{"text": "so when you fire arrays.aslist(ar) the arrays creates a list with exactly one item - the int array ar", "tokens": ["so", "when", "you", "fire", "arrays.aslist(ar)", "the", "arrays", "creates", "a", "list", "with", "exactly", "one", "item", "-", "the", "int", "array", "ar", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.aslist(ar) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "arrays.aslist(ar)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.aslist(ar)", "label": "API", "asoc": []}]}
{"text": "so when you trigger arrays.aslist(ar) the arrays creates a list with exactly one item - the int array ar", "tokens": ["so", "when", "you", "trigger", "arrays.aslist(ar)", "the", "arrays", "creates", "a", "list", "with", "exactly", "one", "item", "-", "the", "int", "array", "ar", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> arrays.aslist(ar) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "arrays.aslist(ar)"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "arrays.aslist(ar)", "label": "API", "asoc": []}]}
{"text": "what is the potential damage if it was possible to call wait() outside a synchronized block", "tokens": ["what", "is", "the", "potential", "damage", "if", "it", "was", "possible", "to", "call", "wait()", "outside", "a", "synchronized", "block", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "what is the potential damage if it was possible to tell wait() outside a synchronized block", "tokens": ["what", "is", "the", "potential", "damage", "if", "it", "was", "possible", "to", "tell", "wait()", "outside", "a", "synchronized", "block", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "what is the potential damage if it was possible to indicate wait() outside a synchronized block", "tokens": ["what", "is", "the", "potential", "damage", "if", "it", "was", "possible", "to", "indicate", "wait()", "outside", "a", "synchronized", "block", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "what is the potential damage if it was possible to occur wait() outside a synchronized block", "tokens": ["what", "is", "the", "potential", "damage", "if", "it", "was", "possible", "to", "occur", "wait()", "outside", "a", "synchronized", "block", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "what is the potential damage if it was possible to perform wait() outside a synchronized block", "tokens": ["what", "is", "the", "potential", "damage", "if", "it", "was", "possible", "to", "perform", "wait()", "outside", "a", "synchronized", "block", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "what is the potential damage if it was possible to prompt wait() outside a synchronized block", "tokens": ["what", "is", "the", "potential", "damage", "if", "it", "was", "possible", "to", "prompt", "wait()", "outside", "a", "synchronized", "block", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "what is the potential damage if it was possible to notify wait() outside a synchronized block", "tokens": ["what", "is", "the", "potential", "damage", "if", "it", "was", "possible", "to", "notify", "wait()", "outside", "a", "synchronized", "block", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "what is the potential damage if it was possible to execute wait() outside a synchronized block", "tokens": ["what", "is", "the", "potential", "damage", "if", "it", "was", "possible", "to", "execute", "wait()", "outside", "a", "synchronized", "block", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "what is the potential damage if it was possible to run wait() outside a synchronized block", "tokens": ["what", "is", "the", "potential", "damage", "if", "it", "was", "possible", "to", "run", "wait()", "outside", "a", "synchronized", "block", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "what is the potential damage if it was possible to enforce wait() outside a synchronized block", "tokens": ["what", "is", "the", "potential", "damage", "if", "it", "was", "possible", "to", "enforce", "wait()", "outside", "a", "synchronized", "block", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "what is the potential damage if it was possible to fire wait() outside a synchronized block", "tokens": ["what", "is", "the", "potential", "damage", "if", "it", "was", "possible", "to", "fire", "wait()", "outside", "a", "synchronized", "block", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "what is the potential damage if it was possible to trigger wait() outside a synchronized block", "tokens": ["what", "is", "the", "potential", "damage", "if", "it", "was", "possible", "to", "trigger", "wait()", "outside", "a", "synchronized", "block", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [11], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "note that you can invoke unordered() to release the ordering contract and potentially increase performance", "tokens": ["note", "that", "you", "can", "invoke", "unordered()", "to", "release", "the", "ordering", "contract", "and", "potentially", "increase", "performance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> unordered() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "unordered()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "unordered()", "label": "API", "asoc": []}]}
{"text": "note that you can tell unordered() to release the ordering contract and potentially increase performance", "tokens": ["note", "that", "you", "can", "tell", "unordered()", "to", "release", "the", "ordering", "contract", "and", "potentially", "increase", "performance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> unordered() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "unordered()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "unordered()", "label": "API", "asoc": []}]}
{"text": "note that you can indicate unordered() to release the ordering contract and potentially increase performance", "tokens": ["note", "that", "you", "can", "indicate", "unordered()", "to", "release", "the", "ordering", "contract", "and", "potentially", "increase", "performance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> unordered() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "unordered()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "unordered()", "label": "API", "asoc": []}]}
{"text": "note that you can occur unordered() to release the ordering contract and potentially increase performance", "tokens": ["note", "that", "you", "can", "occur", "unordered()", "to", "release", "the", "ordering", "contract", "and", "potentially", "increase", "performance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> unordered() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "unordered()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "unordered()", "label": "API", "asoc": []}]}
{"text": "note that you can perform unordered() to release the ordering contract and potentially increase performance", "tokens": ["note", "that", "you", "can", "perform", "unordered()", "to", "release", "the", "ordering", "contract", "and", "potentially", "increase", "performance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> unordered() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "unordered()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "unordered()", "label": "API", "asoc": []}]}
{"text": "note that you can prompt unordered() to release the ordering contract and potentially increase performance", "tokens": ["note", "that", "you", "can", "prompt", "unordered()", "to", "release", "the", "ordering", "contract", "and", "potentially", "increase", "performance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> unordered() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "unordered()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "unordered()", "label": "API", "asoc": []}]}
{"text": "note that you can notify unordered() to release the ordering contract and potentially increase performance", "tokens": ["note", "that", "you", "can", "notify", "unordered()", "to", "release", "the", "ordering", "contract", "and", "potentially", "increase", "performance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> unordered() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "unordered()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "unordered()", "label": "API", "asoc": []}]}
{"text": "note that you can execute unordered() to release the ordering contract and potentially increase performance", "tokens": ["note", "that", "you", "can", "execute", "unordered()", "to", "release", "the", "ordering", "contract", "and", "potentially", "increase", "performance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> unordered() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "unordered()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "unordered()", "label": "API", "asoc": []}]}
{"text": "note that you can run unordered() to release the ordering contract and potentially increase performance", "tokens": ["note", "that", "you", "can", "run", "unordered()", "to", "release", "the", "ordering", "contract", "and", "potentially", "increase", "performance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> unordered() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "unordered()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "unordered()", "label": "API", "asoc": []}]}
{"text": "note that you can enforce unordered() to release the ordering contract and potentially increase performance", "tokens": ["note", "that", "you", "can", "enforce", "unordered()", "to", "release", "the", "ordering", "contract", "and", "potentially", "increase", "performance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> unordered() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "unordered()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "unordered()", "label": "API", "asoc": []}]}
{"text": "note that you can fire unordered() to release the ordering contract and potentially increase performance", "tokens": ["note", "that", "you", "can", "fire", "unordered()", "to", "release", "the", "ordering", "contract", "and", "potentially", "increase", "performance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> unordered() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "unordered()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "unordered()", "label": "API", "asoc": []}]}
{"text": "note that you can trigger unordered() to release the ordering contract and potentially increase performance", "tokens": ["note", "that", "you", "can", "trigger", "unordered()", "to", "release", "the", "ordering", "contract", "and", "potentially", "increase", "performance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> unordered() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "unordered()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "unordered()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always create null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "create", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always build null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "build", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always produce null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "produce", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always construct null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "construct", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always generate null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "generate", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always establish null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "establish", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always make null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "make", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always obtain null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "obtain", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always reconstitute null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "reconstitute", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always compose null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "compose", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always instantiate null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "instantiate", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always implement null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "implement", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always get null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "get", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always retrieve null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "retrieve", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always install null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "install", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always set up null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "set", "up", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always format null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "format", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always convert null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "convert", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always change null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "change", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always transfer null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "transfer", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always map null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "map", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always turn null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "turn", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always transform null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "transform", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always reconvert null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "reconvert", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always move null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "move", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always adapt null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "adapt", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always translate null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "translate", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always force null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "force", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always cast null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "cast", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always compute null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "compute", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always calculate null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "calculate", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always determine null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "determine", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always evaluate null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "evaluate", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always solve null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "solve", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always scale null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "scale", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always measure null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "measure", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always recalculate null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "recalculate", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always multiply null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "multiply", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always count null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "count", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always figure null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "figure", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always subtract null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "subtract", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always increase null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "increase", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always estimate null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "estimate", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always increment null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "increment", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always test null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "test", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always tell null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "tell", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always check null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "check", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always ascertain null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "ascertain", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always control null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "control", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always indicate null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "indicate", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always query null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "query", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always report null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "report", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always validate null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "validate", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always invalidate null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "invalidate", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always verify null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "verify", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always find null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "find", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always identify null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "identify", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always track null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "track", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always detect null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "detect", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always decide null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "decide", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "set to false (the default) in security conscious environments ,  to make getcontext() always compare null", "tokens": ["set", "to", "false", "(the", "default)", "in", "security", "conscious", "environments", ",", "", "to", "make", "getcontext()", "always", "compare", "null", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getcontext() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "getcontext()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getcontext()", "label": "API", "asoc": []}]}
{"text": "edit: i just realized i can simplify the regex quite a bit by putting the alternation inside the lookahead: by the way ,  have you considered using format() to create the regex instead of replace() ?", "tokens": ["edit:", "i", "just", "realized", "i", "can", "simplify", "the", "regex", "quite", "a", "bit", "by", "putting", "the", "alternation", "inside", "the", "lookahead:", "by", "the", "way", ",", "", "have", "you", "considered", "using", "format()", "to", "create", "the", "regex", "instead", "of", "replace()", "?", "", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> format() <extra_id_0> function replace <extra_id_5> replace() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "format()", "label": "API", "asoc": [["function replace", "replace()"]]}, {"span": "replace()", "label": "API", "asoc": []}]}
{"text": "edit: i just realized i can simplify the regex quite a bit by putting the alternation inside the lookahead: by the way ,  have you considered using format() to produce the regex instead of replace() ?", "tokens": ["edit:", "i", "just", "realized", "i", "can", "simplify", "the", "regex", "quite", "a", "bit", "by", "putting", "the", "alternation", "inside", "the", "lookahead:", "by", "the", "way", ",", "", "have", "you", "considered", "using", "format()", "to", "produce", "the", "regex", "instead", "of", "replace()", "?", "", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> format() <extra_id_0> function replace <extra_id_5> replace() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "format()", "label": "API", "asoc": [["function replace", "replace()"]]}, {"span": "replace()", "label": "API", "asoc": []}]}
{"text": "edit: i just realized i can simplify the regex quite a bit by putting the alternation inside the lookahead: by the way ,  have you considered using format() to construct the regex instead of replace() ?", "tokens": ["edit:", "i", "just", "realized", "i", "can", "simplify", "the", "regex", "quite", "a", "bit", "by", "putting", "the", "alternation", "inside", "the", "lookahead:", "by", "the", "way", ",", "", "have", "you", "considered", "using", "format()", "to", "construct", "the", "regex", "instead", "of", "replace()", "?", "", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> format() <extra_id_0> function replace <extra_id_5> replace() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "format()", "label": "API", "asoc": [["function replace", "replace()"]]}, {"span": "replace()", "label": "API", "asoc": []}]}
{"text": "edit: i just realized i can simplify the regex quite a bit by putting the alternation inside the lookahead: by the way ,  have you considered using format() to generate the regex instead of replace() ?", "tokens": ["edit:", "i", "just", "realized", "i", "can", "simplify", "the", "regex", "quite", "a", "bit", "by", "putting", "the", "alternation", "inside", "the", "lookahead:", "by", "the", "way", ",", "", "have", "you", "considered", "using", "format()", "to", "generate", "the", "regex", "instead", "of", "replace()", "?", "", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> format() <extra_id_0> function replace <extra_id_5> replace() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "format()", "label": "API", "asoc": [["function replace", "replace()"]]}, {"span": "replace()", "label": "API", "asoc": []}]}
{"text": "edit: i just realized i can simplify the regex quite a bit by putting the alternation inside the lookahead: by the way ,  have you considered using format() to establish the regex instead of replace() ?", "tokens": ["edit:", "i", "just", "realized", "i", "can", "simplify", "the", "regex", "quite", "a", "bit", "by", "putting", "the", "alternation", "inside", "the", "lookahead:", "by", "the", "way", ",", "", "have", "you", "considered", "using", "format()", "to", "establish", "the", "regex", "instead", "of", "replace()", "?", "", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> format() <extra_id_0> function replace <extra_id_5> replace() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "format()", "label": "API", "asoc": [["function replace", "replace()"]]}, {"span": "replace()", "label": "API", "asoc": []}]}
{"text": "edit: i just realized i can simplify the regex quite a bit by putting the alternation inside the lookahead: by the way ,  have you considered using format() to make the regex instead of replace() ?", "tokens": ["edit:", "i", "just", "realized", "i", "can", "simplify", "the", "regex", "quite", "a", "bit", "by", "putting", "the", "alternation", "inside", "the", "lookahead:", "by", "the", "way", ",", "", "have", "you", "considered", "using", "format()", "to", "make", "the", "regex", "instead", "of", "replace()", "?", "", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> format() <extra_id_0> function replace <extra_id_5> replace() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "format()", "label": "API", "asoc": [["function replace", "replace()"]]}, {"span": "replace()", "label": "API", "asoc": []}]}
{"text": "edit: i just realized i can simplify the regex quite a bit by putting the alternation inside the lookahead: by the way ,  have you considered using format() to obtain the regex instead of replace() ?", "tokens": ["edit:", "i", "just", "realized", "i", "can", "simplify", "the", "regex", "quite", "a", "bit", "by", "putting", "the", "alternation", "inside", "the", "lookahead:", "by", "the", "way", ",", "", "have", "you", "considered", "using", "format()", "to", "obtain", "the", "regex", "instead", "of", "replace()", "?", "", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> format() <extra_id_0> function replace <extra_id_5> replace() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "format()", "label": "API", "asoc": [["function replace", "replace()"]]}, {"span": "replace()", "label": "API", "asoc": []}]}
{"text": "edit: i just realized i can simplify the regex quite a bit by putting the alternation inside the lookahead: by the way ,  have you considered using format() to reconstitute the regex instead of replace() ?", "tokens": ["edit:", "i", "just", "realized", "i", "can", "simplify", "the", "regex", "quite", "a", "bit", "by", "putting", "the", "alternation", "inside", "the", "lookahead:", "by", "the", "way", ",", "", "have", "you", "considered", "using", "format()", "to", "reconstitute", "the", "regex", "instead", "of", "replace()", "?", "", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> format() <extra_id_0> function replace <extra_id_5> replace() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "format()", "label": "API", "asoc": [["function replace", "replace()"]]}, {"span": "replace()", "label": "API", "asoc": []}]}
{"text": "edit: i just realized i can simplify the regex quite a bit by putting the alternation inside the lookahead: by the way ,  have you considered using format() to compose the regex instead of replace() ?", "tokens": ["edit:", "i", "just", "realized", "i", "can", "simplify", "the", "regex", "quite", "a", "bit", "by", "putting", "the", "alternation", "inside", "the", "lookahead:", "by", "the", "way", ",", "", "have", "you", "considered", "using", "format()", "to", "compose", "the", "regex", "instead", "of", "replace()", "?", "", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> format() <extra_id_0> function replace <extra_id_5> replace() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "format()", "label": "API", "asoc": [["function replace", "replace()"]]}, {"span": "replace()", "label": "API", "asoc": []}]}
{"text": "edit: i just realized i can simplify the regex quite a bit by putting the alternation inside the lookahead: by the way ,  have you considered using format() to instantiate the regex instead of replace() ?", "tokens": ["edit:", "i", "just", "realized", "i", "can", "simplify", "the", "regex", "quite", "a", "bit", "by", "putting", "the", "alternation", "inside", "the", "lookahead:", "by", "the", "way", ",", "", "have", "you", "considered", "using", "format()", "to", "instantiate", "the", "regex", "instead", "of", "replace()", "?", "", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> format() <extra_id_0> function replace <extra_id_5> replace() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "format()", "label": "API", "asoc": [["function replace", "replace()"]]}, {"span": "replace()", "label": "API", "asoc": []}]}
{"text": "edit: i just realized i can simplify the regex quite a bit by putting the alternation inside the lookahead: by the way ,  have you considered using format() to implement the regex instead of replace() ?", "tokens": ["edit:", "i", "just", "realized", "i", "can", "simplify", "the", "regex", "quite", "a", "bit", "by", "putting", "the", "alternation", "inside", "the", "lookahead:", "by", "the", "way", ",", "", "have", "you", "considered", "using", "format()", "to", "implement", "the", "regex", "instead", "of", "replace()", "?", "", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> format() <extra_id_0> function replace <extra_id_5> replace() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "format()", "label": "API", "asoc": [["function replace", "replace()"]]}, {"span": "replace()", "label": "API", "asoc": []}]}
{"text": "edit: i just realized i can simplify the regex quite a bit by putting the alternation inside the lookahead: by the way ,  have you considered using format() to get the regex instead of replace() ?", "tokens": ["edit:", "i", "just", "realized", "i", "can", "simplify", "the", "regex", "quite", "a", "bit", "by", "putting", "the", "alternation", "inside", "the", "lookahead:", "by", "the", "way", ",", "", "have", "you", "considered", "using", "format()", "to", "get", "the", "regex", "instead", "of", "replace()", "?", "", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> format() <extra_id_0> function replace <extra_id_5> replace() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "format()", "label": "API", "asoc": [["function replace", "replace()"]]}, {"span": "replace()", "label": "API", "asoc": []}]}
{"text": "edit: i just realized i can simplify the regex quite a bit by putting the alternation inside the lookahead: by the way ,  have you considered using format() to retrieve the regex instead of replace() ?", "tokens": ["edit:", "i", "just", "realized", "i", "can", "simplify", "the", "regex", "quite", "a", "bit", "by", "putting", "the", "alternation", "inside", "the", "lookahead:", "by", "the", "way", ",", "", "have", "you", "considered", "using", "format()", "to", "retrieve", "the", "regex", "instead", "of", "replace()", "?", "", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> format() <extra_id_0> function replace <extra_id_5> replace() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "format()", "label": "API", "asoc": [["function replace", "replace()"]]}, {"span": "replace()", "label": "API", "asoc": []}]}
{"text": "edit: i just realized i can simplify the regex quite a bit by putting the alternation inside the lookahead: by the way ,  have you considered using format() to return the regex instead of replace() ?", "tokens": ["edit:", "i", "just", "realized", "i", "can", "simplify", "the", "regex", "quite", "a", "bit", "by", "putting", "the", "alternation", "inside", "the", "lookahead:", "by", "the", "way", ",", "", "have", "you", "considered", "using", "format()", "to", "return", "the", "regex", "instead", "of", "replace()", "?", "", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> format() <extra_id_0> function replace <extra_id_5> replace() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "format()", "label": "API", "asoc": [["function replace", "replace()"]]}, {"span": "replace()", "label": "API", "asoc": []}]}
{"text": "edit: i just realized i can simplify the regex quite a bit by putting the alternation inside the lookahead: by the way ,  have you considered using format() to install the regex instead of replace() ?", "tokens": ["edit:", "i", "just", "realized", "i", "can", "simplify", "the", "regex", "quite", "a", "bit", "by", "putting", "the", "alternation", "inside", "the", "lookahead:", "by", "the", "way", ",", "", "have", "you", "considered", "using", "format()", "to", "install", "the", "regex", "instead", "of", "replace()", "?", "", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> format() <extra_id_0> function replace <extra_id_5> replace() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [35], "text": "replace()"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "format()", "label": "API", "asoc": [["function replace", "replace()"]]}, {"span": "replace()", "label": "API", "asoc": []}]}
{"text": "edit: i just realized i can simplify the regex quite a bit by putting the alternation inside the lookahead: by the way ,  have you considered using format() to set up the regex instead of replace() ?", "tokens": ["edit:", "i", "just", "realized", "i", "can", "simplify", "the", "regex", "quite", "a", "bit", "by", "putting", "the", "alternation", "inside", "the", "lookahead:", "by", "the", "way", ",", "", "have", "you", "considered", "using", "format()", "to", "set", "up", "the", "regex", "instead", "of", "replace()", "?", "", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> format() <extra_id_0> function replace <extra_id_5> replace() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> replace() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [36], "text": "replace()"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [28], "text": "format()"}, {"type": "API", "offset": [36], "text": "replace()"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "format()", "label": "API", "asoc": [["function replace", "replace()"]]}, {"span": "replace()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not request you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "request", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not ask you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "ask", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not allow you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "allow", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not send you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "send", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not pass you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "pass", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not dispatch you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "dispatch", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not post you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "post", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not issue you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "issue", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not propagate you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "propagate", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not forward you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "forward", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not broadcast you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "broadcast", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not transmit you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "transmit", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not emit you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "emit", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not notify you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "notify", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not signal you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "signal", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not provide you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "provide", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not supply you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "supply", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not set you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "set", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not control you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "control", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not describe you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "describe", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not define you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "define", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not specify you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "specify", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not tell you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "tell", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not assign you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "assign", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not determine you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "determine", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not indicate you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "indicate", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not configure you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "configure", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not schedule you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "schedule", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not declare you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "declare", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not reassign you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "reassign", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not clamp you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "clamp", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not put you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "put", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "you need to create a new instance of hashmap before the second put() call map.clear() does not designate you a new map instance", "tokens": ["you", "need", "to", "create", "a", "new", "instance", "of", "hashmap", "before", "the", "second", "put()", "call", "map.clear()", "does", "not", "designate", "you", "a", "new", "map", "instance", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> put() <extra_id_0> logic constraint <extra_id_5> map.clear() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> map.clear() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [12], "text": "put()"}, {"type": "API", "offset": [14], "text": "map.clear()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "put()", "label": "API", "asoc": [["logic constraint", "map.clear()"]]}, {"span": "map.clear()", "label": "API", "asoc": []}]}
{"text": "java.awt.point  ,  you can put the weights into a map: then ,  you create an image ,  and for each x , y coordinate ,  find the best score", "tokens": ["java.awt.point", "", ",", "", "you", "can", "put", "the", "weights", "into", "a", "map:", "then", ",", "", "you", "create", "an", "image", ",", "", "and", "for", "each", "x", ",", "y", "coordinate", ",", "", "find", "the", "best", "score", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.awt.point <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "java.awt.point"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.awt.point", "label": "API", "asoc": []}]}
{"text": "java.awt.point  ,  you can put the weights into a map: then ,  you build an image ,  and for each x , y coordinate ,  find the best score", "tokens": ["java.awt.point", "", ",", "", "you", "can", "put", "the", "weights", "into", "a", "map:", "then", ",", "", "you", "build", "an", "image", ",", "", "and", "for", "each", "x", ",", "y", "coordinate", ",", "", "find", "the", "best", "score", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.awt.point <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "java.awt.point"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.awt.point", "label": "API", "asoc": []}]}
{"text": "java.awt.point  ,  you can put the weights into a map: then ,  you produce an image ,  and for each x , y coordinate ,  find the best score", "tokens": ["java.awt.point", "", ",", "", "you", "can", "put", "the", "weights", "into", "a", "map:", "then", ",", "", "you", "produce", "an", "image", ",", "", "and", "for", "each", "x", ",", "y", "coordinate", ",", "", "find", "the", "best", "score", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.awt.point <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "java.awt.point"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.awt.point", "label": "API", "asoc": []}]}
{"text": "java.awt.point  ,  you can put the weights into a map: then ,  you construct an image ,  and for each x , y coordinate ,  find the best score", "tokens": ["java.awt.point", "", ",", "", "you", "can", "put", "the", "weights", "into", "a", "map:", "then", ",", "", "you", "construct", "an", "image", ",", "", "and", "for", "each", "x", ",", "y", "coordinate", ",", "", "find", "the", "best", "score", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.awt.point <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "java.awt.point"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.awt.point", "label": "API", "asoc": []}]}
{"text": "java.awt.point  ,  you can put the weights into a map: then ,  you generate an image ,  and for each x , y coordinate ,  find the best score", "tokens": ["java.awt.point", "", ",", "", "you", "can", "put", "the", "weights", "into", "a", "map:", "then", ",", "", "you", "generate", "an", "image", ",", "", "and", "for", "each", "x", ",", "y", "coordinate", ",", "", "find", "the", "best", "score", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.awt.point <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "java.awt.point"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.awt.point", "label": "API", "asoc": []}]}
{"text": "java.awt.point  ,  you can put the weights into a map: then ,  you establish an image ,  and for each x , y coordinate ,  find the best score", "tokens": ["java.awt.point", "", ",", "", "you", "can", "put", "the", "weights", "into", "a", "map:", "then", ",", "", "you", "establish", "an", "image", ",", "", "and", "for", "each", "x", ",", "y", "coordinate", ",", "", "find", "the", "best", "score", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.awt.point <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "java.awt.point"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.awt.point", "label": "API", "asoc": []}]}
{"text": "java.awt.point  ,  you can put the weights into a map: then ,  you obtain an image ,  and for each x , y coordinate ,  find the best score", "tokens": ["java.awt.point", "", ",", "", "you", "can", "put", "the", "weights", "into", "a", "map:", "then", ",", "", "you", "obtain", "an", "image", ",", "", "and", "for", "each", "x", ",", "y", "coordinate", ",", "", "find", "the", "best", "score", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.awt.point <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "java.awt.point"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.awt.point", "label": "API", "asoc": []}]}
{"text": "java.awt.point  ,  you can put the weights into a map: then ,  you reconstitute an image ,  and for each x , y coordinate ,  find the best score", "tokens": ["java.awt.point", "", ",", "", "you", "can", "put", "the", "weights", "into", "a", "map:", "then", ",", "", "you", "reconstitute", "an", "image", ",", "", "and", "for", "each", "x", ",", "y", "coordinate", ",", "", "find", "the", "best", "score", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.awt.point <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "java.awt.point"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.awt.point", "label": "API", "asoc": []}]}
{"text": "java.awt.point  ,  you can put the weights into a map: then ,  you compose an image ,  and for each x , y coordinate ,  find the best score", "tokens": ["java.awt.point", "", ",", "", "you", "can", "put", "the", "weights", "into", "a", "map:", "then", ",", "", "you", "compose", "an", "image", ",", "", "and", "for", "each", "x", ",", "y", "coordinate", ",", "", "find", "the", "best", "score", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.awt.point <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "java.awt.point"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.awt.point", "label": "API", "asoc": []}]}
{"text": "java.awt.point  ,  you can put the weights into a map: then ,  you instantiate an image ,  and for each x , y coordinate ,  find the best score", "tokens": ["java.awt.point", "", ",", "", "you", "can", "put", "the", "weights", "into", "a", "map:", "then", ",", "", "you", "instantiate", "an", "image", ",", "", "and", "for", "each", "x", ",", "y", "coordinate", ",", "", "find", "the", "best", "score", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.awt.point <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "java.awt.point"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.awt.point", "label": "API", "asoc": []}]}
{"text": "java.awt.point  ,  you can put the weights into a map: then ,  you implement an image ,  and for each x , y coordinate ,  find the best score", "tokens": ["java.awt.point", "", ",", "", "you", "can", "put", "the", "weights", "into", "a", "map:", "then", ",", "", "you", "implement", "an", "image", ",", "", "and", "for", "each", "x", ",", "y", "coordinate", ",", "", "find", "the", "best", "score", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.awt.point <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "java.awt.point"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.awt.point", "label": "API", "asoc": []}]}
{"text": "java.awt.point  ,  you can put the weights into a map: then ,  you get an image ,  and for each x , y coordinate ,  find the best score", "tokens": ["java.awt.point", "", ",", "", "you", "can", "put", "the", "weights", "into", "a", "map:", "then", ",", "", "you", "get", "an", "image", ",", "", "and", "for", "each", "x", ",", "y", "coordinate", ",", "", "find", "the", "best", "score", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.awt.point <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "java.awt.point"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.awt.point", "label": "API", "asoc": []}]}
{"text": "java.awt.point  ,  you can put the weights into a map: then ,  you retrieve an image ,  and for each x , y coordinate ,  find the best score", "tokens": ["java.awt.point", "", ",", "", "you", "can", "put", "the", "weights", "into", "a", "map:", "then", ",", "", "you", "retrieve", "an", "image", ",", "", "and", "for", "each", "x", ",", "y", "coordinate", ",", "", "find", "the", "best", "score", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.awt.point <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "java.awt.point"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.awt.point", "label": "API", "asoc": []}]}
{"text": "java.awt.point  ,  you can put the weights into a map: then ,  you return an image ,  and for each x , y coordinate ,  find the best score", "tokens": ["java.awt.point", "", ",", "", "you", "can", "put", "the", "weights", "into", "a", "map:", "then", ",", "", "you", "return", "an", "image", ",", "", "and", "for", "each", "x", ",", "y", "coordinate", ",", "", "find", "the", "best", "score", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.awt.point <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "java.awt.point"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.awt.point", "label": "API", "asoc": []}]}
{"text": "java.awt.point  ,  you can put the weights into a map: then ,  you install an image ,  and for each x , y coordinate ,  find the best score", "tokens": ["java.awt.point", "", ",", "", "you", "can", "put", "the", "weights", "into", "a", "map:", "then", ",", "", "you", "install", "an", "image", ",", "", "and", "for", "each", "x", ",", "y", "coordinate", ",", "", "find", "the", "best", "score", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.awt.point <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "java.awt.point"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.awt.point", "label": "API", "asoc": []}]}
{"text": "java.awt.point  ,  you can put the weights into a map: then ,  you set up an image ,  and for each x , y coordinate ,  find the best score", "tokens": ["java.awt.point", "", ",", "", "you", "can", "put", "the", "weights", "into", "a", "map:", "then", ",", "", "you", "set", "up", "an", "image", ",", "", "and", "for", "each", "x", ",", "y", "coordinate", ",", "", "find", "the", "best", "score", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.awt.point <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "java.awt.point"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.awt.point", "label": "API", "asoc": []}]}
{"text": "java.awt.point  ,  you can put the weights into a map: then ,  you cause an image ,  and for each x , y coordinate ,  find the best score", "tokens": ["java.awt.point", "", ",", "", "you", "can", "put", "the", "weights", "into", "a", "map:", "then", ",", "", "you", "cause", "an", "image", ",", "", "and", "for", "each", "x", ",", "y", "coordinate", ",", "", "find", "the", "best", "score", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.awt.point <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "java.awt.point"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.awt.point", "label": "API", "asoc": []}]}
{"text": "java.awt.point  ,  you can put the weights into a map: then ,  you instruct an image ,  and for each x , y coordinate ,  find the best score", "tokens": ["java.awt.point", "", ",", "", "you", "can", "put", "the", "weights", "into", "a", "map:", "then", ",", "", "you", "instruct", "an", "image", ",", "", "and", "for", "each", "x", ",", "y", "coordinate", ",", "", "find", "the", "best", "score", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.awt.point <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "java.awt.point"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.awt.point", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can handle the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "handle", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can process the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "process", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can compute the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "compute", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can calculate the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "calculate", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can evaluate the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "evaluate", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can solve the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "solve", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can scale the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "scale", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can measure the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "measure", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can recalculate the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "recalculate", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can multiply the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "multiply", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can count the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "count", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can figure the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "figure", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can subtract the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "subtract", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can increase the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "increase", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can estimate the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "estimate", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can return the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "return", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can increment the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "increment", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can query the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "query", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can find the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "find", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can locate the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "locate", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can retrieve the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "retrieve", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can visit the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "visit", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can look the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "look", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can search the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "search", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can discover the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "discover", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can seek the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "seek", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can look up the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "look", "up", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can test the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "test", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can tell the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "tell", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can check the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "check", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can ascertain the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "ascertain", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can control the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "control", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can indicate the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "indicate", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can report the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "report", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can validate the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "validate", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can get the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "get", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can invalidate the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "invalidate", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can verify the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "verify", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can identify the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "identify", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can track the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "track", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can detect the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "detect", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can decide the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "decide", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can confirm the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "confirm", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can ensure the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "ensure", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can set the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "set", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can describe the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "describe", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can define the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "define", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can specify the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "specify", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can give the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "give", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can assign the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "assign", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can configure the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "configure", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can schedule the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "schedule", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can declare the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "declare", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can reassign the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "reassign", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can clamp the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "clamp", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can put the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "put", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "and count() may not process any elements at all when it can designate the size of the stream without processing the items", "tokens": ["and", "count()", "may", "not", "process", "any", "elements", "at", "all", "when", "it", "can", "designate", "the", "size", "of", "the", "stream", "without", "processing", "the", "items", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> count() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "count()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "count()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't create a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "create", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't build a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "build", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't produce a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "produce", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't construct a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "construct", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't generate a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "generate", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't establish a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "establish", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't make a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "make", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't obtain a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "obtain", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't reconstitute a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "reconstitute", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't compose a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "compose", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't instantiate a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "instantiate", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't implement a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "implement", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't get a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "get", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't retrieve a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "retrieve", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't return a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "return", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't install a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "install", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't set up a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "set", "up", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't format a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "format", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't convert a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "convert", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't change a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "change", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't transfer a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "transfer", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't map a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "map", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't turn a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "turn", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't transform a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "transform", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't reconvert a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "reconvert", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't move a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "move", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't adapt a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "adapt", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't translate a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "translate", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't force a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "force", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't cast a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "cast", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't compute a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "compute", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't calculate a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "calculate", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't determine a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "determine", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't evaluate a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "evaluate", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't solve a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "solve", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't scale a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "scale", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't measure a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "measure", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't recalculate a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "recalculate", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't multiply a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "multiply", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't count a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "count", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't figure a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "figure", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't subtract a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "subtract", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't increase a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "increase", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't estimate a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "estimate", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't increment a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "increment", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't test a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "test", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't tell a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "tell", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't check a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "check", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't ascertain a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "ascertain", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't control a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "control", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't indicate a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "indicate", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't query a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "query", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't report a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "report", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't validate a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "validate", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't invalidate a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "invalidate", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't verify a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "verify", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't find a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "find", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't identify a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "identify", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't track a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "track", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't detect a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "detect", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't decide a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "decide", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "the file.length() will return zero in some cases where you don't compare a zero length file; e.g", "tokens": ["the", "file.length()", "will", "return", "zero", "in", "some", "cases", "where", "you", "don't", "compare", "a", "zero", "length", "file;", "e.g", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.length() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "file.length()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.length()", "label": "API", "asoc": []}]}
{"text": "instead ,  you need to set map as a volatile and implement your refresh() method as per your question", "tokens": ["instead", ",", "", "you", "need", "to", "set", "map", "as", "a", "volatile", "and", "implement", "your", "refresh()", "method", "as", "per", "your", "question", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> refresh() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "refresh()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "refresh()", "label": "API", "asoc": []}]}
{"text": "instead ,  you need to control map as a volatile and implement your refresh() method as per your question", "tokens": ["instead", ",", "", "you", "need", "to", "control", "map", "as", "a", "volatile", "and", "implement", "your", "refresh()", "method", "as", "per", "your", "question", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> refresh() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "refresh()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "refresh()", "label": "API", "asoc": []}]}
{"text": "instead ,  you need to describe map as a volatile and implement your refresh() method as per your question", "tokens": ["instead", ",", "", "you", "need", "to", "describe", "map", "as", "a", "volatile", "and", "implement", "your", "refresh()", "method", "as", "per", "your", "question", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> refresh() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "refresh()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "refresh()", "label": "API", "asoc": []}]}
{"text": "instead ,  you need to define map as a volatile and implement your refresh() method as per your question", "tokens": ["instead", ",", "", "you", "need", "to", "define", "map", "as", "a", "volatile", "and", "implement", "your", "refresh()", "method", "as", "per", "your", "question", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> refresh() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "refresh()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "refresh()", "label": "API", "asoc": []}]}
{"text": "instead ,  you need to specify map as a volatile and implement your refresh() method as per your question", "tokens": ["instead", ",", "", "you", "need", "to", "specify", "map", "as", "a", "volatile", "and", "implement", "your", "refresh()", "method", "as", "per", "your", "question", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> refresh() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "refresh()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "refresh()", "label": "API", "asoc": []}]}
{"text": "instead ,  you need to tell map as a volatile and implement your refresh() method as per your question", "tokens": ["instead", ",", "", "you", "need", "to", "tell", "map", "as", "a", "volatile", "and", "implement", "your", "refresh()", "method", "as", "per", "your", "question", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> refresh() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "refresh()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "refresh()", "label": "API", "asoc": []}]}
{"text": "instead ,  you need to give map as a volatile and implement your refresh() method as per your question", "tokens": ["instead", ",", "", "you", "need", "to", "give", "map", "as", "a", "volatile", "and", "implement", "your", "refresh()", "method", "as", "per", "your", "question", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> refresh() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "refresh()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "refresh()", "label": "API", "asoc": []}]}
{"text": "instead ,  you need to assign map as a volatile and implement your refresh() method as per your question", "tokens": ["instead", ",", "", "you", "need", "to", "assign", "map", "as", "a", "volatile", "and", "implement", "your", "refresh()", "method", "as", "per", "your", "question", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> refresh() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "refresh()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "refresh()", "label": "API", "asoc": []}]}
{"text": "instead ,  you need to determine map as a volatile and implement your refresh() method as per your question", "tokens": ["instead", ",", "", "you", "need", "to", "determine", "map", "as", "a", "volatile", "and", "implement", "your", "refresh()", "method", "as", "per", "your", "question", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> refresh() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "refresh()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "refresh()", "label": "API", "asoc": []}]}
{"text": "instead ,  you need to indicate map as a volatile and implement your refresh() method as per your question", "tokens": ["instead", ",", "", "you", "need", "to", "indicate", "map", "as", "a", "volatile", "and", "implement", "your", "refresh()", "method", "as", "per", "your", "question", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> refresh() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "refresh()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "refresh()", "label": "API", "asoc": []}]}
{"text": "instead ,  you need to configure map as a volatile and implement your refresh() method as per your question", "tokens": ["instead", ",", "", "you", "need", "to", "configure", "map", "as", "a", "volatile", "and", "implement", "your", "refresh()", "method", "as", "per", "your", "question", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> refresh() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "refresh()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "refresh()", "label": "API", "asoc": []}]}
{"text": "instead ,  you need to schedule map as a volatile and implement your refresh() method as per your question", "tokens": ["instead", ",", "", "you", "need", "to", "schedule", "map", "as", "a", "volatile", "and", "implement", "your", "refresh()", "method", "as", "per", "your", "question", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> refresh() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "refresh()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "refresh()", "label": "API", "asoc": []}]}
{"text": "instead ,  you need to reassign map as a volatile and implement your refresh() method as per your question", "tokens": ["instead", ",", "", "you", "need", "to", "reassign", "map", "as", "a", "volatile", "and", "implement", "your", "refresh()", "method", "as", "per", "your", "question", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> refresh() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "refresh()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "refresh()", "label": "API", "asoc": []}]}
{"text": "instead ,  you need to clamp map as a volatile and implement your refresh() method as per your question", "tokens": ["instead", ",", "", "you", "need", "to", "clamp", "map", "as", "a", "volatile", "and", "implement", "your", "refresh()", "method", "as", "per", "your", "question", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> refresh() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "refresh()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "refresh()", "label": "API", "asoc": []}]}
{"text": "instead ,  you need to put map as a volatile and implement your refresh() method as per your question", "tokens": ["instead", ",", "", "you", "need", "to", "put", "map", "as", "a", "volatile", "and", "implement", "your", "refresh()", "method", "as", "per", "your", "question", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> refresh() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "refresh()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "refresh()", "label": "API", "asoc": []}]}
{"text": "instead ,  you need to designate map as a volatile and implement your refresh() method as per your question", "tokens": ["instead", ",", "", "you", "need", "to", "designate", "map", "as", "a", "volatile", "and", "implement", "your", "refresh()", "method", "as", "per", "your", "question", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> refresh() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "refresh()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "refresh()", "label": "API", "asoc": []}]}
{"text": "the standard oracle jdk 7 implementation uses what's called a linear congruential generator  to create random values in java.util.random", "tokens": ["the", "standard", "oracle", "jdk", "7", "implementation", "uses", "what's", "called", "a", "linear", "congruential", "generator", "", "to", "create", "random", "values", "in", "java.util.random", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "java.util.random"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.random", "label": "API", "asoc": []}]}
{"text": "the standard oracle jdk 7 implementation uses what's called a linear congruential generator  to build random values in java.util.random", "tokens": ["the", "standard", "oracle", "jdk", "7", "implementation", "uses", "what's", "called", "a", "linear", "congruential", "generator", "", "to", "build", "random", "values", "in", "java.util.random", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "java.util.random"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.random", "label": "API", "asoc": []}]}
{"text": "the standard oracle jdk 7 implementation uses what's called a linear congruential generator  to construct random values in java.util.random", "tokens": ["the", "standard", "oracle", "jdk", "7", "implementation", "uses", "what's", "called", "a", "linear", "congruential", "generator", "", "to", "construct", "random", "values", "in", "java.util.random", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "java.util.random"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.random", "label": "API", "asoc": []}]}
{"text": "the standard oracle jdk 7 implementation uses what's called a linear congruential generator  to generate random values in java.util.random", "tokens": ["the", "standard", "oracle", "jdk", "7", "implementation", "uses", "what's", "called", "a", "linear", "congruential", "generator", "", "to", "generate", "random", "values", "in", "java.util.random", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "java.util.random"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.random", "label": "API", "asoc": []}]}
{"text": "the standard oracle jdk 7 implementation uses what's called a linear congruential generator  to establish random values in java.util.random", "tokens": ["the", "standard", "oracle", "jdk", "7", "implementation", "uses", "what's", "called", "a", "linear", "congruential", "generator", "", "to", "establish", "random", "values", "in", "java.util.random", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "java.util.random"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.random", "label": "API", "asoc": []}]}
{"text": "the standard oracle jdk 7 implementation uses what's called a linear congruential generator  to make random values in java.util.random", "tokens": ["the", "standard", "oracle", "jdk", "7", "implementation", "uses", "what's", "called", "a", "linear", "congruential", "generator", "", "to", "make", "random", "values", "in", "java.util.random", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "java.util.random"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.random", "label": "API", "asoc": []}]}
{"text": "the standard oracle jdk 7 implementation uses what's called a linear congruential generator  to obtain random values in java.util.random", "tokens": ["the", "standard", "oracle", "jdk", "7", "implementation", "uses", "what's", "called", "a", "linear", "congruential", "generator", "", "to", "obtain", "random", "values", "in", "java.util.random", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "java.util.random"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.random", "label": "API", "asoc": []}]}
{"text": "the standard oracle jdk 7 implementation uses what's called a linear congruential generator  to reconstitute random values in java.util.random", "tokens": ["the", "standard", "oracle", "jdk", "7", "implementation", "uses", "what's", "called", "a", "linear", "congruential", "generator", "", "to", "reconstitute", "random", "values", "in", "java.util.random", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "java.util.random"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.random", "label": "API", "asoc": []}]}
{"text": "the standard oracle jdk 7 implementation uses what's called a linear congruential generator  to compose random values in java.util.random", "tokens": ["the", "standard", "oracle", "jdk", "7", "implementation", "uses", "what's", "called", "a", "linear", "congruential", "generator", "", "to", "compose", "random", "values", "in", "java.util.random", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "java.util.random"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.random", "label": "API", "asoc": []}]}
{"text": "the standard oracle jdk 7 implementation uses what's called a linear congruential generator  to instantiate random values in java.util.random", "tokens": ["the", "standard", "oracle", "jdk", "7", "implementation", "uses", "what's", "called", "a", "linear", "congruential", "generator", "", "to", "instantiate", "random", "values", "in", "java.util.random", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "java.util.random"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.random", "label": "API", "asoc": []}]}
{"text": "the standard oracle jdk 7 implementation uses what's called a linear congruential generator  to implement random values in java.util.random", "tokens": ["the", "standard", "oracle", "jdk", "7", "implementation", "uses", "what's", "called", "a", "linear", "congruential", "generator", "", "to", "implement", "random", "values", "in", "java.util.random", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "java.util.random"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.random", "label": "API", "asoc": []}]}
{"text": "the standard oracle jdk 7 implementation uses what's called a linear congruential generator  to get random values in java.util.random", "tokens": ["the", "standard", "oracle", "jdk", "7", "implementation", "uses", "what's", "called", "a", "linear", "congruential", "generator", "", "to", "get", "random", "values", "in", "java.util.random", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "java.util.random"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.random", "label": "API", "asoc": []}]}
{"text": "the standard oracle jdk 7 implementation uses what's called a linear congruential generator  to retrieve random values in java.util.random", "tokens": ["the", "standard", "oracle", "jdk", "7", "implementation", "uses", "what's", "called", "a", "linear", "congruential", "generator", "", "to", "retrieve", "random", "values", "in", "java.util.random", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "java.util.random"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.random", "label": "API", "asoc": []}]}
{"text": "the standard oracle jdk 7 implementation uses what's called a linear congruential generator  to return random values in java.util.random", "tokens": ["the", "standard", "oracle", "jdk", "7", "implementation", "uses", "what's", "called", "a", "linear", "congruential", "generator", "", "to", "return", "random", "values", "in", "java.util.random", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "java.util.random"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.random", "label": "API", "asoc": []}]}
{"text": "the standard oracle jdk 7 implementation uses what's called a linear congruential generator  to install random values in java.util.random", "tokens": ["the", "standard", "oracle", "jdk", "7", "implementation", "uses", "what's", "called", "a", "linear", "congruential", "generator", "", "to", "install", "random", "values", "in", "java.util.random", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [19], "text": "java.util.random"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.random", "label": "API", "asoc": []}]}
{"text": "the standard oracle jdk 7 implementation uses what's called a linear congruential generator  to set up random values in java.util.random", "tokens": ["the", "standard", "oracle", "jdk", "7", "implementation", "uses", "what's", "called", "a", "linear", "congruential", "generator", "", "to", "set", "up", "random", "values", "in", "java.util.random", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.util.random <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [20], "text": "java.util.random"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.util.random", "label": "API", "asoc": []}]}
{"text": "as shown in dependentcolumn ,  you can compute derived values in your implementation of getvalueat()", "tokens": ["as", "shown", "in", "dependentcolumn", ",", "", "you", "can", "compute", "derived", "values", "in", "your", "implementation", "of", "getvalueat()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getvalueat() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "getvalueat()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getvalueat()", "label": "API", "asoc": []}]}
{"text": "as shown in dependentcolumn ,  you can determine derived values in your implementation of getvalueat()", "tokens": ["as", "shown", "in", "dependentcolumn", ",", "", "you", "can", "determine", "derived", "values", "in", "your", "implementation", "of", "getvalueat()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getvalueat() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "getvalueat()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getvalueat()", "label": "API", "asoc": []}]}
{"text": "as shown in dependentcolumn ,  you can evaluate derived values in your implementation of getvalueat()", "tokens": ["as", "shown", "in", "dependentcolumn", ",", "", "you", "can", "evaluate", "derived", "values", "in", "your", "implementation", "of", "getvalueat()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getvalueat() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "getvalueat()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getvalueat()", "label": "API", "asoc": []}]}
{"text": "as shown in dependentcolumn ,  you can solve derived values in your implementation of getvalueat()", "tokens": ["as", "shown", "in", "dependentcolumn", ",", "", "you", "can", "solve", "derived", "values", "in", "your", "implementation", "of", "getvalueat()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getvalueat() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "getvalueat()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getvalueat()", "label": "API", "asoc": []}]}
{"text": "as shown in dependentcolumn ,  you can scale derived values in your implementation of getvalueat()", "tokens": ["as", "shown", "in", "dependentcolumn", ",", "", "you", "can", "scale", "derived", "values", "in", "your", "implementation", "of", "getvalueat()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getvalueat() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "getvalueat()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getvalueat()", "label": "API", "asoc": []}]}
{"text": "as shown in dependentcolumn ,  you can measure derived values in your implementation of getvalueat()", "tokens": ["as", "shown", "in", "dependentcolumn", ",", "", "you", "can", "measure", "derived", "values", "in", "your", "implementation", "of", "getvalueat()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getvalueat() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "getvalueat()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getvalueat()", "label": "API", "asoc": []}]}
{"text": "as shown in dependentcolumn ,  you can recalculate derived values in your implementation of getvalueat()", "tokens": ["as", "shown", "in", "dependentcolumn", ",", "", "you", "can", "recalculate", "derived", "values", "in", "your", "implementation", "of", "getvalueat()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getvalueat() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "getvalueat()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getvalueat()", "label": "API", "asoc": []}]}
{"text": "as shown in dependentcolumn ,  you can multiply derived values in your implementation of getvalueat()", "tokens": ["as", "shown", "in", "dependentcolumn", ",", "", "you", "can", "multiply", "derived", "values", "in", "your", "implementation", "of", "getvalueat()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getvalueat() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "getvalueat()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getvalueat()", "label": "API", "asoc": []}]}
{"text": "as shown in dependentcolumn ,  you can count derived values in your implementation of getvalueat()", "tokens": ["as", "shown", "in", "dependentcolumn", ",", "", "you", "can", "count", "derived", "values", "in", "your", "implementation", "of", "getvalueat()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getvalueat() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "getvalueat()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getvalueat()", "label": "API", "asoc": []}]}
{"text": "as shown in dependentcolumn ,  you can figure derived values in your implementation of getvalueat()", "tokens": ["as", "shown", "in", "dependentcolumn", ",", "", "you", "can", "figure", "derived", "values", "in", "your", "implementation", "of", "getvalueat()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getvalueat() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "getvalueat()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getvalueat()", "label": "API", "asoc": []}]}
{"text": "as shown in dependentcolumn ,  you can subtract derived values in your implementation of getvalueat()", "tokens": ["as", "shown", "in", "dependentcolumn", ",", "", "you", "can", "subtract", "derived", "values", "in", "your", "implementation", "of", "getvalueat()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getvalueat() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "getvalueat()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getvalueat()", "label": "API", "asoc": []}]}
{"text": "as shown in dependentcolumn ,  you can increase derived values in your implementation of getvalueat()", "tokens": ["as", "shown", "in", "dependentcolumn", ",", "", "you", "can", "increase", "derived", "values", "in", "your", "implementation", "of", "getvalueat()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getvalueat() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "getvalueat()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getvalueat()", "label": "API", "asoc": []}]}
{"text": "as shown in dependentcolumn ,  you can estimate derived values in your implementation of getvalueat()", "tokens": ["as", "shown", "in", "dependentcolumn", ",", "", "you", "can", "estimate", "derived", "values", "in", "your", "implementation", "of", "getvalueat()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getvalueat() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "getvalueat()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getvalueat()", "label": "API", "asoc": []}]}
{"text": "as shown in dependentcolumn ,  you can return derived values in your implementation of getvalueat()", "tokens": ["as", "shown", "in", "dependentcolumn", ",", "", "you", "can", "return", "derived", "values", "in", "your", "implementation", "of", "getvalueat()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getvalueat() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "getvalueat()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getvalueat()", "label": "API", "asoc": []}]}
{"text": "as shown in dependentcolumn ,  you can increment derived values in your implementation of getvalueat()", "tokens": ["as", "shown", "in", "dependentcolumn", ",", "", "you", "can", "increment", "derived", "values", "in", "your", "implementation", "of", "getvalueat()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getvalueat() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [15], "text": "getvalueat()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getvalueat()", "label": "API", "asoc": []}]}
{"text": "to parse your date you can use  but if that fails and you are parse  java.text.parseexception", "tokens": ["to", "parse", "your", "date", "you", "can", "use", "", "but", "if", "that", "fails", "and", "you", "are", "parse", "", "java.text.parseexception", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.text.parseexception <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "java.text.parseexception"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.text.parseexception", "label": "API", "asoc": []}]}
{"text": "to parse your date you can use  but if that fails and you are resolve  java.text.parseexception", "tokens": ["to", "parse", "your", "date", "you", "can", "use", "", "but", "if", "that", "fails", "and", "you", "are", "resolve", "", "java.text.parseexception", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.text.parseexception <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "java.text.parseexception"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.text.parseexception", "label": "API", "asoc": []}]}
{"text": "to parse your date you can use  but if that fails and you are unwrap  java.text.parseexception", "tokens": ["to", "parse", "your", "date", "you", "can", "use", "", "but", "if", "that", "fails", "and", "you", "are", "unwrap", "", "java.text.parseexception", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.text.parseexception <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "java.text.parseexception"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.text.parseexception", "label": "API", "asoc": []}]}
{"text": "to parse your date you can use  but if that fails and you are analyze  java.text.parseexception", "tokens": ["to", "parse", "your", "date", "you", "can", "use", "", "but", "if", "that", "fails", "and", "you", "are", "analyze", "", "java.text.parseexception", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.text.parseexception <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "java.text.parseexception"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.text.parseexception", "label": "API", "asoc": []}]}
{"text": "to parse your date you can use  but if that fails and you are uncompress  java.text.parseexception", "tokens": ["to", "parse", "your", "date", "you", "can", "use", "", "but", "if", "that", "fails", "and", "you", "are", "uncompress", "", "java.text.parseexception", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.text.parseexception <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "java.text.parseexception"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.text.parseexception", "label": "API", "asoc": []}]}
{"text": "to parse your date you can use  but if that fails and you are decode  java.text.parseexception", "tokens": ["to", "parse", "your", "date", "you", "can", "use", "", "but", "if", "that", "fails", "and", "you", "are", "decode", "", "java.text.parseexception", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.text.parseexception <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "java.text.parseexception"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.text.parseexception", "label": "API", "asoc": []}]}
{"text": "to parse your date you can use  but if that fails and you are flatten  java.text.parseexception", "tokens": ["to", "parse", "your", "date", "you", "can", "use", "", "but", "if", "that", "fails", "and", "you", "are", "flatten", "", "java.text.parseexception", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.text.parseexception <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "java.text.parseexception"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.text.parseexception", "label": "API", "asoc": []}]}
{"text": "to parse your date you can use  but if that fails and you are unmarshal  java.text.parseexception", "tokens": ["to", "parse", "your", "date", "you", "can", "use", "", "but", "if", "that", "fails", "and", "you", "are", "unmarshal", "", "java.text.parseexception", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.text.parseexception <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "java.text.parseexception"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.text.parseexception", "label": "API", "asoc": []}]}
{"text": "by the time that you invoke dispose() ,  the observable is done ,  and nothing will happen -- disposing a completed observable has no effect .", "tokens": ["by", "the", "time", "that", "you", "invoke", "dispose()", ",", "", "the", "observable", "is", "done", ",", "", "and", "nothing", "will", "happen", "--", "disposing", "a", "completed", "observable", "has", "no", "effect", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> dispose() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "dispose()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "dispose()", "label": "API", "asoc": []}]}
{"text": "by the time that you tell dispose() ,  the observable is done ,  and nothing will happen -- disposing a completed observable has no effect .", "tokens": ["by", "the", "time", "that", "you", "tell", "dispose()", ",", "", "the", "observable", "is", "done", ",", "", "and", "nothing", "will", "happen", "--", "disposing", "a", "completed", "observable", "has", "no", "effect", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> dispose() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "dispose()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "dispose()", "label": "API", "asoc": []}]}
{"text": "by the time that you indicate dispose() ,  the observable is done ,  and nothing will happen -- disposing a completed observable has no effect .", "tokens": ["by", "the", "time", "that", "you", "indicate", "dispose()", ",", "", "the", "observable", "is", "done", ",", "", "and", "nothing", "will", "happen", "--", "disposing", "a", "completed", "observable", "has", "no", "effect", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> dispose() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "dispose()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "dispose()", "label": "API", "asoc": []}]}
{"text": "by the time that you occur dispose() ,  the observable is done ,  and nothing will happen -- disposing a completed observable has no effect .", "tokens": ["by", "the", "time", "that", "you", "occur", "dispose()", ",", "", "the", "observable", "is", "done", ",", "", "and", "nothing", "will", "happen", "--", "disposing", "a", "completed", "observable", "has", "no", "effect", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> dispose() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "dispose()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "dispose()", "label": "API", "asoc": []}]}
{"text": "by the time that you perform dispose() ,  the observable is done ,  and nothing will happen -- disposing a completed observable has no effect .", "tokens": ["by", "the", "time", "that", "you", "perform", "dispose()", ",", "", "the", "observable", "is", "done", ",", "", "and", "nothing", "will", "happen", "--", "disposing", "a", "completed", "observable", "has", "no", "effect", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> dispose() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "dispose()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "dispose()", "label": "API", "asoc": []}]}
{"text": "by the time that you prompt dispose() ,  the observable is done ,  and nothing will happen -- disposing a completed observable has no effect .", "tokens": ["by", "the", "time", "that", "you", "prompt", "dispose()", ",", "", "the", "observable", "is", "done", ",", "", "and", "nothing", "will", "happen", "--", "disposing", "a", "completed", "observable", "has", "no", "effect", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> dispose() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "dispose()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "dispose()", "label": "API", "asoc": []}]}
{"text": "by the time that you notify dispose() ,  the observable is done ,  and nothing will happen -- disposing a completed observable has no effect .", "tokens": ["by", "the", "time", "that", "you", "notify", "dispose()", ",", "", "the", "observable", "is", "done", ",", "", "and", "nothing", "will", "happen", "--", "disposing", "a", "completed", "observable", "has", "no", "effect", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> dispose() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "dispose()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "dispose()", "label": "API", "asoc": []}]}
{"text": "by the time that you execute dispose() ,  the observable is done ,  and nothing will happen -- disposing a completed observable has no effect .", "tokens": ["by", "the", "time", "that", "you", "execute", "dispose()", ",", "", "the", "observable", "is", "done", ",", "", "and", "nothing", "will", "happen", "--", "disposing", "a", "completed", "observable", "has", "no", "effect", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> dispose() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "dispose()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "dispose()", "label": "API", "asoc": []}]}
{"text": "by the time that you run dispose() ,  the observable is done ,  and nothing will happen -- disposing a completed observable has no effect .", "tokens": ["by", "the", "time", "that", "you", "run", "dispose()", ",", "", "the", "observable", "is", "done", ",", "", "and", "nothing", "will", "happen", "--", "disposing", "a", "completed", "observable", "has", "no", "effect", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> dispose() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "dispose()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "dispose()", "label": "API", "asoc": []}]}
{"text": "by the time that you enforce dispose() ,  the observable is done ,  and nothing will happen -- disposing a completed observable has no effect .", "tokens": ["by", "the", "time", "that", "you", "enforce", "dispose()", ",", "", "the", "observable", "is", "done", ",", "", "and", "nothing", "will", "happen", "--", "disposing", "a", "completed", "observable", "has", "no", "effect", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> dispose() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "dispose()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "dispose()", "label": "API", "asoc": []}]}
{"text": "by the time that you fire dispose() ,  the observable is done ,  and nothing will happen -- disposing a completed observable has no effect .", "tokens": ["by", "the", "time", "that", "you", "fire", "dispose()", ",", "", "the", "observable", "is", "done", ",", "", "and", "nothing", "will", "happen", "--", "disposing", "a", "completed", "observable", "has", "no", "effect", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> dispose() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "dispose()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "dispose()", "label": "API", "asoc": []}]}
{"text": "by the time that you trigger dispose() ,  the observable is done ,  and nothing will happen -- disposing a completed observable has no effect .", "tokens": ["by", "the", "time", "that", "you", "trigger", "dispose()", ",", "", "the", "observable", "is", "done", ",", "", "and", "nothing", "will", "happen", "--", "disposing", "a", "completed", "observable", "has", "no", "effect", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> dispose() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "dispose()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "dispose()", "label": "API", "asoc": []}]}
{"text": "using java.nio.channels.filechannel : java nio classes were introduced in java 1.4 and filechannel can be used to clone file in java", "tokens": ["using", "java.nio.channels.filechannel", ":", "java", "nio", "classes", "were", "introduced", "in", "java", "1.4", "and", "filechannel", "can", "be", "used", "to", "clone", "file", "in", "java", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.nio.channels.filechannel <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "java.nio.channels.filechannel"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.nio.channels.filechannel", "label": "API", "asoc": []}]}
{"text": "to build a formatted string out a localdatetime object you can use the format() method", "tokens": ["to", "build", "a", "formatted", "string", "out", "a", "localdatetime", "object", "you", "can", "use", "the", "format()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> localdatetime <extra_id_0> logic constraint <extra_id_5> format() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> format() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "localdatetime", "label": "API", "asoc": [["logic constraint", "format()"]]}, {"span": "format()", "label": "API", "asoc": []}]}
{"text": "to produce a formatted string out a localdatetime object you can use the format() method", "tokens": ["to", "produce", "a", "formatted", "string", "out", "a", "localdatetime", "object", "you", "can", "use", "the", "format()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> localdatetime <extra_id_0> logic constraint <extra_id_5> format() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> format() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "localdatetime", "label": "API", "asoc": [["logic constraint", "format()"]]}, {"span": "format()", "label": "API", "asoc": []}]}
{"text": "to construct a formatted string out a localdatetime object you can use the format() method", "tokens": ["to", "construct", "a", "formatted", "string", "out", "a", "localdatetime", "object", "you", "can", "use", "the", "format()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> localdatetime <extra_id_0> logic constraint <extra_id_5> format() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> format() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "localdatetime", "label": "API", "asoc": [["logic constraint", "format()"]]}, {"span": "format()", "label": "API", "asoc": []}]}
{"text": "to generate a formatted string out a localdatetime object you can use the format() method", "tokens": ["to", "generate", "a", "formatted", "string", "out", "a", "localdatetime", "object", "you", "can", "use", "the", "format()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> localdatetime <extra_id_0> logic constraint <extra_id_5> format() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> format() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "localdatetime", "label": "API", "asoc": [["logic constraint", "format()"]]}, {"span": "format()", "label": "API", "asoc": []}]}
{"text": "to establish a formatted string out a localdatetime object you can use the format() method", "tokens": ["to", "establish", "a", "formatted", "string", "out", "a", "localdatetime", "object", "you", "can", "use", "the", "format()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> localdatetime <extra_id_0> logic constraint <extra_id_5> format() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> format() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "localdatetime", "label": "API", "asoc": [["logic constraint", "format()"]]}, {"span": "format()", "label": "API", "asoc": []}]}
{"text": "to make a formatted string out a localdatetime object you can use the format() method", "tokens": ["to", "make", "a", "formatted", "string", "out", "a", "localdatetime", "object", "you", "can", "use", "the", "format()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> localdatetime <extra_id_0> logic constraint <extra_id_5> format() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> format() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "localdatetime", "label": "API", "asoc": [["logic constraint", "format()"]]}, {"span": "format()", "label": "API", "asoc": []}]}
{"text": "to obtain a formatted string out a localdatetime object you can use the format() method", "tokens": ["to", "obtain", "a", "formatted", "string", "out", "a", "localdatetime", "object", "you", "can", "use", "the", "format()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> localdatetime <extra_id_0> logic constraint <extra_id_5> format() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> format() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "localdatetime", "label": "API", "asoc": [["logic constraint", "format()"]]}, {"span": "format()", "label": "API", "asoc": []}]}
{"text": "to reconstitute a formatted string out a localdatetime object you can use the format() method", "tokens": ["to", "reconstitute", "a", "formatted", "string", "out", "a", "localdatetime", "object", "you", "can", "use", "the", "format()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> localdatetime <extra_id_0> logic constraint <extra_id_5> format() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> format() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "localdatetime", "label": "API", "asoc": [["logic constraint", "format()"]]}, {"span": "format()", "label": "API", "asoc": []}]}
{"text": "to compose a formatted string out a localdatetime object you can use the format() method", "tokens": ["to", "compose", "a", "formatted", "string", "out", "a", "localdatetime", "object", "you", "can", "use", "the", "format()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> localdatetime <extra_id_0> logic constraint <extra_id_5> format() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> format() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "localdatetime", "label": "API", "asoc": [["logic constraint", "format()"]]}, {"span": "format()", "label": "API", "asoc": []}]}
{"text": "to instantiate a formatted string out a localdatetime object you can use the format() method", "tokens": ["to", "instantiate", "a", "formatted", "string", "out", "a", "localdatetime", "object", "you", "can", "use", "the", "format()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> localdatetime <extra_id_0> logic constraint <extra_id_5> format() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> format() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "localdatetime", "label": "API", "asoc": [["logic constraint", "format()"]]}, {"span": "format()", "label": "API", "asoc": []}]}
{"text": "to implement a formatted string out a localdatetime object you can use the format() method", "tokens": ["to", "implement", "a", "formatted", "string", "out", "a", "localdatetime", "object", "you", "can", "use", "the", "format()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> localdatetime <extra_id_0> logic constraint <extra_id_5> format() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> format() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "localdatetime", "label": "API", "asoc": [["logic constraint", "format()"]]}, {"span": "format()", "label": "API", "asoc": []}]}
{"text": "to get a formatted string out a localdatetime object you can use the format() method", "tokens": ["to", "get", "a", "formatted", "string", "out", "a", "localdatetime", "object", "you", "can", "use", "the", "format()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> localdatetime <extra_id_0> logic constraint <extra_id_5> format() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> format() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "localdatetime", "label": "API", "asoc": [["logic constraint", "format()"]]}, {"span": "format()", "label": "API", "asoc": []}]}
{"text": "to retrieve a formatted string out a localdatetime object you can use the format() method", "tokens": ["to", "retrieve", "a", "formatted", "string", "out", "a", "localdatetime", "object", "you", "can", "use", "the", "format()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> localdatetime <extra_id_0> logic constraint <extra_id_5> format() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> format() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "localdatetime", "label": "API", "asoc": [["logic constraint", "format()"]]}, {"span": "format()", "label": "API", "asoc": []}]}
{"text": "to return a formatted string out a localdatetime object you can use the format() method", "tokens": ["to", "return", "a", "formatted", "string", "out", "a", "localdatetime", "object", "you", "can", "use", "the", "format()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> localdatetime <extra_id_0> logic constraint <extra_id_5> format() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> format() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "localdatetime", "label": "API", "asoc": [["logic constraint", "format()"]]}, {"span": "format()", "label": "API", "asoc": []}]}
{"text": "to install a formatted string out a localdatetime object you can use the format() method", "tokens": ["to", "install", "a", "formatted", "string", "out", "a", "localdatetime", "object", "you", "can", "use", "the", "format()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> localdatetime <extra_id_0> logic constraint <extra_id_5> format() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> format() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [7], "text": "localdatetime"}, {"type": "API", "offset": [13], "text": "format()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "localdatetime", "label": "API", "asoc": [["logic constraint", "format()"]]}, {"span": "format()", "label": "API", "asoc": []}]}
{"text": "to set up a formatted string out a localdatetime object you can use the format() method", "tokens": ["to", "set", "up", "a", "formatted", "string", "out", "a", "localdatetime", "object", "you", "can", "use", "the", "format()", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> localdatetime <extra_id_0> logic constraint <extra_id_5> format() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> format() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "localdatetime"}, {"type": "API", "offset": [14], "text": "format()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [8], "text": "localdatetime"}, {"type": "API", "offset": [14], "text": "format()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "localdatetime", "label": "API", "asoc": [["logic constraint", "format()"]]}, {"span": "format()", "label": "API", "asoc": []}]}
{"text": "you can invoke get() on a future as often as you like ,  and it will only block if the task that produces the result has not finished yet", "tokens": ["you", "can", "invoke", "get()", "on", "a", "future", "as", "often", "as", "you", "like", ",", "", "and", "it", "will", "only", "block", "if", "the", "task", "that", "produces", "the", "result", "has", "not", "finished", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "get()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "get()", "label": "API", "asoc": []}]}
{"text": "you can tell get() on a future as often as you like ,  and it will only block if the task that produces the result has not finished yet", "tokens": ["you", "can", "tell", "get()", "on", "a", "future", "as", "often", "as", "you", "like", ",", "", "and", "it", "will", "only", "block", "if", "the", "task", "that", "produces", "the", "result", "has", "not", "finished", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "get()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "get()", "label": "API", "asoc": []}]}
{"text": "you can indicate get() on a future as often as you like ,  and it will only block if the task that produces the result has not finished yet", "tokens": ["you", "can", "indicate", "get()", "on", "a", "future", "as", "often", "as", "you", "like", ",", "", "and", "it", "will", "only", "block", "if", "the", "task", "that", "produces", "the", "result", "has", "not", "finished", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "get()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "get()", "label": "API", "asoc": []}]}
{"text": "you can occur get() on a future as often as you like ,  and it will only block if the task that produces the result has not finished yet", "tokens": ["you", "can", "occur", "get()", "on", "a", "future", "as", "often", "as", "you", "like", ",", "", "and", "it", "will", "only", "block", "if", "the", "task", "that", "produces", "the", "result", "has", "not", "finished", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "get()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "get()", "label": "API", "asoc": []}]}
{"text": "you can perform get() on a future as often as you like ,  and it will only block if the task that produces the result has not finished yet", "tokens": ["you", "can", "perform", "get()", "on", "a", "future", "as", "often", "as", "you", "like", ",", "", "and", "it", "will", "only", "block", "if", "the", "task", "that", "produces", "the", "result", "has", "not", "finished", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "get()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "get()", "label": "API", "asoc": []}]}
{"text": "you can prompt get() on a future as often as you like ,  and it will only block if the task that produces the result has not finished yet", "tokens": ["you", "can", "prompt", "get()", "on", "a", "future", "as", "often", "as", "you", "like", ",", "", "and", "it", "will", "only", "block", "if", "the", "task", "that", "produces", "the", "result", "has", "not", "finished", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "get()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "get()", "label": "API", "asoc": []}]}
{"text": "you can notify get() on a future as often as you like ,  and it will only block if the task that produces the result has not finished yet", "tokens": ["you", "can", "notify", "get()", "on", "a", "future", "as", "often", "as", "you", "like", ",", "", "and", "it", "will", "only", "block", "if", "the", "task", "that", "produces", "the", "result", "has", "not", "finished", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "get()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "get()", "label": "API", "asoc": []}]}
{"text": "you can execute get() on a future as often as you like ,  and it will only block if the task that produces the result has not finished yet", "tokens": ["you", "can", "execute", "get()", "on", "a", "future", "as", "often", "as", "you", "like", ",", "", "and", "it", "will", "only", "block", "if", "the", "task", "that", "produces", "the", "result", "has", "not", "finished", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "get()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "get()", "label": "API", "asoc": []}]}
{"text": "you can run get() on a future as often as you like ,  and it will only block if the task that produces the result has not finished yet", "tokens": ["you", "can", "run", "get()", "on", "a", "future", "as", "often", "as", "you", "like", ",", "", "and", "it", "will", "only", "block", "if", "the", "task", "that", "produces", "the", "result", "has", "not", "finished", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "get()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "get()", "label": "API", "asoc": []}]}
{"text": "you can enforce get() on a future as often as you like ,  and it will only block if the task that produces the result has not finished yet", "tokens": ["you", "can", "enforce", "get()", "on", "a", "future", "as", "often", "as", "you", "like", ",", "", "and", "it", "will", "only", "block", "if", "the", "task", "that", "produces", "the", "result", "has", "not", "finished", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "get()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "get()", "label": "API", "asoc": []}]}
{"text": "you can fire get() on a future as often as you like ,  and it will only block if the task that produces the result has not finished yet", "tokens": ["you", "can", "fire", "get()", "on", "a", "future", "as", "often", "as", "you", "like", ",", "", "and", "it", "will", "only", "block", "if", "the", "task", "that", "produces", "the", "result", "has", "not", "finished", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "get()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "get()", "label": "API", "asoc": []}]}
{"text": "you can trigger get() on a future as often as you like ,  and it will only block if the task that produces the result has not finished yet", "tokens": ["you", "can", "trigger", "get()", "on", "a", "future", "as", "often", "as", "you", "like", ",", "", "and", "it", "will", "only", "block", "if", "the", "task", "that", "produces", "the", "result", "has", "not", "finished", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> get() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "get()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "get()", "label": "API", "asoc": []}]}
{"text": "through the use of a single javax.swing.timer ,  you could visit through the balls list and update there positions", "tokens": ["through", "the", "use", "of", "a", "single", "javax.swing.timer", ",", "", "you", "could", "visit", "through", "the", "balls", "list", "and", "update", "there", "positions", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> javax.swing.timer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "javax.swing.timer"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "javax.swing.timer", "label": "API", "asoc": []}]}
{"text": "through the use of a single javax.swing.timer ,  you could rescan through the balls list and update there positions", "tokens": ["through", "the", "use", "of", "a", "single", "javax.swing.timer", ",", "", "you", "could", "rescan", "through", "the", "balls", "list", "and", "update", "there", "positions", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> javax.swing.timer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "javax.swing.timer"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "javax.swing.timer", "label": "API", "asoc": []}]}
{"text": "through the use of a single javax.swing.timer ,  you could scan through the balls list and update there positions", "tokens": ["through", "the", "use", "of", "a", "single", "javax.swing.timer", ",", "", "you", "could", "scan", "through", "the", "balls", "list", "and", "update", "there", "positions", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> javax.swing.timer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "javax.swing.timer"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "javax.swing.timer", "label": "API", "asoc": []}]}
{"text": "through the use of a single javax.swing.timer ,  you could walk through the balls list and update there positions", "tokens": ["through", "the", "use", "of", "a", "single", "javax.swing.timer", ",", "", "you", "could", "walk", "through", "the", "balls", "list", "and", "update", "there", "positions", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> javax.swing.timer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "javax.swing.timer"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "javax.swing.timer", "label": "API", "asoc": []}]}
{"text": "through the use of a single javax.swing.timer ,  you could access through the balls list and update there positions", "tokens": ["through", "the", "use", "of", "a", "single", "javax.swing.timer", ",", "", "you", "could", "access", "through", "the", "balls", "list", "and", "update", "there", "positions", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> javax.swing.timer <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "javax.swing.timer"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "javax.swing.timer", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can create the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "create", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can build the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "build", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can produce the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "produce", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can construct the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "construct", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can generate the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "generate", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can establish the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "establish", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can make the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "make", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can obtain the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "obtain", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can reconstitute the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "reconstitute", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can compose the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "compose", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can instantiate the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "instantiate", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can implement the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "implement", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can get the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "get", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can retrieve the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "retrieve", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can install the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "install", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can set up the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "set", "up", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can format the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "format", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can convert the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "convert", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can change the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "change", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can transfer the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "transfer", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can map the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "map", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can turn the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "turn", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can transform the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "transform", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can reconvert the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "reconvert", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can move the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "move", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can adapt the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "adapt", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can translate the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "translate", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can force the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "force", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can cast the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "cast", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can compute the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "compute", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can calculate the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "calculate", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can determine the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "determine", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can evaluate the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "evaluate", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can solve the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "solve", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can scale the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "scale", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can measure the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "measure", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can recalculate the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "recalculate", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can multiply the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "multiply", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can count the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "count", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can figure the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "figure", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can subtract the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "subtract", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can increase the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "increase", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can estimate the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "estimate", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can increment the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "increment", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can test the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "test", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can tell the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "tell", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can check the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "check", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can ascertain the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "ascertain", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can control the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "control", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can indicate the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "indicate", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can query the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "query", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can report the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "report", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can validate the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "validate", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can invalidate the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "invalidate", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can verify the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "verify", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can find the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "find", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can identify the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "identify", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can track the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "track", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can detect the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "detect", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can decide the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "decide", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "nevertheless ,  even system.identityhashcode() can compare the same hash for multiple objects", "tokens": ["nevertheless", ",", "", "even", "system.identityhashcode()", "can", "compare", "the", "same", "hash", "for", "multiple", "objects", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> system.identityhashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "system.identityhashcode()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "system.identityhashcode()", "label": "API", "asoc": []}]}
{"text": "you should never invoke thread.sleep() on the edt", "tokens": ["you", "should", "never", "invoke", "thread.sleep()", "on", "the", "edt", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "thread.sleep()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep()", "label": "API", "asoc": []}]}
{"text": "you should never tell thread.sleep() on the edt", "tokens": ["you", "should", "never", "tell", "thread.sleep()", "on", "the", "edt", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "thread.sleep()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep()", "label": "API", "asoc": []}]}
{"text": "you should never indicate thread.sleep() on the edt", "tokens": ["you", "should", "never", "indicate", "thread.sleep()", "on", "the", "edt", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "thread.sleep()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep()", "label": "API", "asoc": []}]}
{"text": "you should never occur thread.sleep() on the edt", "tokens": ["you", "should", "never", "occur", "thread.sleep()", "on", "the", "edt", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "thread.sleep()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep()", "label": "API", "asoc": []}]}
{"text": "you should never perform thread.sleep() on the edt", "tokens": ["you", "should", "never", "perform", "thread.sleep()", "on", "the", "edt", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "thread.sleep()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep()", "label": "API", "asoc": []}]}
{"text": "you should never prompt thread.sleep() on the edt", "tokens": ["you", "should", "never", "prompt", "thread.sleep()", "on", "the", "edt", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "thread.sleep()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep()", "label": "API", "asoc": []}]}
{"text": "you should never notify thread.sleep() on the edt", "tokens": ["you", "should", "never", "notify", "thread.sleep()", "on", "the", "edt", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "thread.sleep()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep()", "label": "API", "asoc": []}]}
{"text": "you should never execute thread.sleep() on the edt", "tokens": ["you", "should", "never", "execute", "thread.sleep()", "on", "the", "edt", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "thread.sleep()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep()", "label": "API", "asoc": []}]}
{"text": "you should never run thread.sleep() on the edt", "tokens": ["you", "should", "never", "run", "thread.sleep()", "on", "the", "edt", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "thread.sleep()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep()", "label": "API", "asoc": []}]}
{"text": "you should never enforce thread.sleep() on the edt", "tokens": ["you", "should", "never", "enforce", "thread.sleep()", "on", "the", "edt", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "thread.sleep()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep()", "label": "API", "asoc": []}]}
{"text": "you should never fire thread.sleep() on the edt", "tokens": ["you", "should", "never", "fire", "thread.sleep()", "on", "the", "edt", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "thread.sleep()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep()", "label": "API", "asoc": []}]}
{"text": "you should never trigger thread.sleep() on the edt", "tokens": ["you", "should", "never", "trigger", "thread.sleep()", "on", "the", "edt", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "thread.sleep()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep()", "label": "API", "asoc": []}]}
{"text": "so i was expecting a compiling error due to the fact that the compiler would not be able to query the java.lang.string class file", "tokens": ["so", "i", "was", "expecting", "a", "compiling", "error", "due", "to", "the", "fact", "that", "the", "compiler", "would", "not", "be", "able", "to", "query", "the", "java.lang.string", "class", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "so i was expecting a compiling error due to the fact that the compiler would not be able to locate the java.lang.string class file", "tokens": ["so", "i", "was", "expecting", "a", "compiling", "error", "due", "to", "the", "fact", "that", "the", "compiler", "would", "not", "be", "able", "to", "locate", "the", "java.lang.string", "class", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "so i was expecting a compiling error due to the fact that the compiler would not be able to determine the java.lang.string class file", "tokens": ["so", "i", "was", "expecting", "a", "compiling", "error", "due", "to", "the", "fact", "that", "the", "compiler", "would", "not", "be", "able", "to", "determine", "the", "java.lang.string", "class", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "so i was expecting a compiling error due to the fact that the compiler would not be able to retrieve the java.lang.string class file", "tokens": ["so", "i", "was", "expecting", "a", "compiling", "error", "due", "to", "the", "fact", "that", "the", "compiler", "would", "not", "be", "able", "to", "retrieve", "the", "java.lang.string", "class", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "so i was expecting a compiling error due to the fact that the compiler would not be able to visit the java.lang.string class file", "tokens": ["so", "i", "was", "expecting", "a", "compiling", "error", "due", "to", "the", "fact", "that", "the", "compiler", "would", "not", "be", "able", "to", "visit", "the", "java.lang.string", "class", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "so i was expecting a compiling error due to the fact that the compiler would not be able to look the java.lang.string class file", "tokens": ["so", "i", "was", "expecting", "a", "compiling", "error", "due", "to", "the", "fact", "that", "the", "compiler", "would", "not", "be", "able", "to", "look", "the", "java.lang.string", "class", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "so i was expecting a compiling error due to the fact that the compiler would not be able to search the java.lang.string class file", "tokens": ["so", "i", "was", "expecting", "a", "compiling", "error", "due", "to", "the", "fact", "that", "the", "compiler", "would", "not", "be", "able", "to", "search", "the", "java.lang.string", "class", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "so i was expecting a compiling error due to the fact that the compiler would not be able to discover the java.lang.string class file", "tokens": ["so", "i", "was", "expecting", "a", "compiling", "error", "due", "to", "the", "fact", "that", "the", "compiler", "would", "not", "be", "able", "to", "discover", "the", "java.lang.string", "class", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "so i was expecting a compiling error due to the fact that the compiler would not be able to seek the java.lang.string class file", "tokens": ["so", "i", "was", "expecting", "a", "compiling", "error", "due", "to", "the", "fact", "that", "the", "compiler", "would", "not", "be", "able", "to", "seek", "the", "java.lang.string", "class", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "so i was expecting a compiling error due to the fact that the compiler would not be able to look up the java.lang.string class file", "tokens": ["so", "i", "was", "expecting", "a", "compiling", "error", "due", "to", "the", "fact", "that", "the", "compiler", "would", "not", "be", "able", "to", "look", "up", "the", "java.lang.string", "class", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "so i was expecting a compiling error due to the fact that the compiler would not be able to test the java.lang.string class file", "tokens": ["so", "i", "was", "expecting", "a", "compiling", "error", "due", "to", "the", "fact", "that", "the", "compiler", "would", "not", "be", "able", "to", "test", "the", "java.lang.string", "class", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "so i was expecting a compiling error due to the fact that the compiler would not be able to tell the java.lang.string class file", "tokens": ["so", "i", "was", "expecting", "a", "compiling", "error", "due", "to", "the", "fact", "that", "the", "compiler", "would", "not", "be", "able", "to", "tell", "the", "java.lang.string", "class", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "so i was expecting a compiling error due to the fact that the compiler would not be able to check the java.lang.string class file", "tokens": ["so", "i", "was", "expecting", "a", "compiling", "error", "due", "to", "the", "fact", "that", "the", "compiler", "would", "not", "be", "able", "to", "check", "the", "java.lang.string", "class", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "so i was expecting a compiling error due to the fact that the compiler would not be able to ascertain the java.lang.string class file", "tokens": ["so", "i", "was", "expecting", "a", "compiling", "error", "due", "to", "the", "fact", "that", "the", "compiler", "would", "not", "be", "able", "to", "ascertain", "the", "java.lang.string", "class", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "so i was expecting a compiling error due to the fact that the compiler would not be able to return the java.lang.string class file", "tokens": ["so", "i", "was", "expecting", "a", "compiling", "error", "due", "to", "the", "fact", "that", "the", "compiler", "would", "not", "be", "able", "to", "return", "the", "java.lang.string", "class", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "so i was expecting a compiling error due to the fact that the compiler would not be able to control the java.lang.string class file", "tokens": ["so", "i", "was", "expecting", "a", "compiling", "error", "due", "to", "the", "fact", "that", "the", "compiler", "would", "not", "be", "able", "to", "control", "the", "java.lang.string", "class", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "so i was expecting a compiling error due to the fact that the compiler would not be able to indicate the java.lang.string class file", "tokens": ["so", "i", "was", "expecting", "a", "compiling", "error", "due", "to", "the", "fact", "that", "the", "compiler", "would", "not", "be", "able", "to", "indicate", "the", "java.lang.string", "class", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "so i was expecting a compiling error due to the fact that the compiler would not be able to report the java.lang.string class file", "tokens": ["so", "i", "was", "expecting", "a", "compiling", "error", "due", "to", "the", "fact", "that", "the", "compiler", "would", "not", "be", "able", "to", "report", "the", "java.lang.string", "class", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "so i was expecting a compiling error due to the fact that the compiler would not be able to validate the java.lang.string class file", "tokens": ["so", "i", "was", "expecting", "a", "compiling", "error", "due", "to", "the", "fact", "that", "the", "compiler", "would", "not", "be", "able", "to", "validate", "the", "java.lang.string", "class", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "so i was expecting a compiling error due to the fact that the compiler would not be able to get the java.lang.string class file", "tokens": ["so", "i", "was", "expecting", "a", "compiling", "error", "due", "to", "the", "fact", "that", "the", "compiler", "would", "not", "be", "able", "to", "get", "the", "java.lang.string", "class", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "so i was expecting a compiling error due to the fact that the compiler would not be able to invalidate the java.lang.string class file", "tokens": ["so", "i", "was", "expecting", "a", "compiling", "error", "due", "to", "the", "fact", "that", "the", "compiler", "would", "not", "be", "able", "to", "invalidate", "the", "java.lang.string", "class", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "so i was expecting a compiling error due to the fact that the compiler would not be able to verify the java.lang.string class file", "tokens": ["so", "i", "was", "expecting", "a", "compiling", "error", "due", "to", "the", "fact", "that", "the", "compiler", "would", "not", "be", "able", "to", "verify", "the", "java.lang.string", "class", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "so i was expecting a compiling error due to the fact that the compiler would not be able to identify the java.lang.string class file", "tokens": ["so", "i", "was", "expecting", "a", "compiling", "error", "due", "to", "the", "fact", "that", "the", "compiler", "would", "not", "be", "able", "to", "identify", "the", "java.lang.string", "class", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "so i was expecting a compiling error due to the fact that the compiler would not be able to track the java.lang.string class file", "tokens": ["so", "i", "was", "expecting", "a", "compiling", "error", "due", "to", "the", "fact", "that", "the", "compiler", "would", "not", "be", "able", "to", "track", "the", "java.lang.string", "class", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "so i was expecting a compiling error due to the fact that the compiler would not be able to detect the java.lang.string class file", "tokens": ["so", "i", "was", "expecting", "a", "compiling", "error", "due", "to", "the", "fact", "that", "the", "compiler", "would", "not", "be", "able", "to", "detect", "the", "java.lang.string", "class", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "so i was expecting a compiling error due to the fact that the compiler would not be able to decide the java.lang.string class file", "tokens": ["so", "i", "was", "expecting", "a", "compiling", "error", "due", "to", "the", "fact", "that", "the", "compiler", "would", "not", "be", "able", "to", "decide", "the", "java.lang.string", "class", "file", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.lang.string <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [21], "text": "java.lang.string"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.lang.string", "label": "API", "asoc": []}]}
{"text": "join() will make the currently create thread to wait for the the thread it is called on to die", "tokens": ["join()", "will", "make", "the", "currently", "create", "thread", "to", "wait", "for", "the", "the", "thread", "it", "is", "called", "on", "to", "die", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> join() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "join()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "join()", "label": "API", "asoc": []}]}
{"text": "join() will make the currently build thread to wait for the the thread it is called on to die", "tokens": ["join()", "will", "make", "the", "currently", "build", "thread", "to", "wait", "for", "the", "the", "thread", "it", "is", "called", "on", "to", "die", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> join() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "join()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "join()", "label": "API", "asoc": []}]}
{"text": "join() will make the currently produce thread to wait for the the thread it is called on to die", "tokens": ["join()", "will", "make", "the", "currently", "produce", "thread", "to", "wait", "for", "the", "the", "thread", "it", "is", "called", "on", "to", "die", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> join() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "join()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "join()", "label": "API", "asoc": []}]}
{"text": "join() will make the currently construct thread to wait for the the thread it is called on to die", "tokens": ["join()", "will", "make", "the", "currently", "construct", "thread", "to", "wait", "for", "the", "the", "thread", "it", "is", "called", "on", "to", "die", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> join() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "join()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "join()", "label": "API", "asoc": []}]}
{"text": "join() will make the currently generate thread to wait for the the thread it is called on to die", "tokens": ["join()", "will", "make", "the", "currently", "generate", "thread", "to", "wait", "for", "the", "the", "thread", "it", "is", "called", "on", "to", "die", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> join() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "join()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "join()", "label": "API", "asoc": []}]}
{"text": "join() will make the currently establish thread to wait for the the thread it is called on to die", "tokens": ["join()", "will", "make", "the", "currently", "establish", "thread", "to", "wait", "for", "the", "the", "thread", "it", "is", "called", "on", "to", "die", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> join() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "join()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "join()", "label": "API", "asoc": []}]}
{"text": "join() will make the currently make thread to wait for the the thread it is called on to die", "tokens": ["join()", "will", "make", "the", "currently", "make", "thread", "to", "wait", "for", "the", "the", "thread", "it", "is", "called", "on", "to", "die", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> join() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "join()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "join()", "label": "API", "asoc": []}]}
{"text": "join() will make the currently obtain thread to wait for the the thread it is called on to die", "tokens": ["join()", "will", "make", "the", "currently", "obtain", "thread", "to", "wait", "for", "the", "the", "thread", "it", "is", "called", "on", "to", "die", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> join() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "join()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "join()", "label": "API", "asoc": []}]}
{"text": "join() will make the currently reconstitute thread to wait for the the thread it is called on to die", "tokens": ["join()", "will", "make", "the", "currently", "reconstitute", "thread", "to", "wait", "for", "the", "the", "thread", "it", "is", "called", "on", "to", "die", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> join() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "join()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "join()", "label": "API", "asoc": []}]}
{"text": "join() will make the currently compose thread to wait for the the thread it is called on to die", "tokens": ["join()", "will", "make", "the", "currently", "compose", "thread", "to", "wait", "for", "the", "the", "thread", "it", "is", "called", "on", "to", "die", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> join() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "join()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "join()", "label": "API", "asoc": []}]}
{"text": "join() will make the currently instantiate thread to wait for the the thread it is called on to die", "tokens": ["join()", "will", "make", "the", "currently", "instantiate", "thread", "to", "wait", "for", "the", "the", "thread", "it", "is", "called", "on", "to", "die", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> join() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "join()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "join()", "label": "API", "asoc": []}]}
{"text": "join() will make the currently implement thread to wait for the the thread it is called on to die", "tokens": ["join()", "will", "make", "the", "currently", "implement", "thread", "to", "wait", "for", "the", "the", "thread", "it", "is", "called", "on", "to", "die", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> join() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "join()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "join()", "label": "API", "asoc": []}]}
{"text": "join() will make the currently get thread to wait for the the thread it is called on to die", "tokens": ["join()", "will", "make", "the", "currently", "get", "thread", "to", "wait", "for", "the", "the", "thread", "it", "is", "called", "on", "to", "die", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> join() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "join()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "join()", "label": "API", "asoc": []}]}
{"text": "join() will make the currently retrieve thread to wait for the the thread it is called on to die", "tokens": ["join()", "will", "make", "the", "currently", "retrieve", "thread", "to", "wait", "for", "the", "the", "thread", "it", "is", "called", "on", "to", "die", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> join() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "join()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "join()", "label": "API", "asoc": []}]}
{"text": "join() will make the currently return thread to wait for the the thread it is called on to die", "tokens": ["join()", "will", "make", "the", "currently", "return", "thread", "to", "wait", "for", "the", "the", "thread", "it", "is", "called", "on", "to", "die", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> join() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "join()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "join()", "label": "API", "asoc": []}]}
{"text": "join() will make the currently install thread to wait for the the thread it is called on to die", "tokens": ["join()", "will", "make", "the", "currently", "install", "thread", "to", "wait", "for", "the", "the", "thread", "it", "is", "called", "on", "to", "die", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> join() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "join()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "join()", "label": "API", "asoc": []}]}
{"text": "join() will make the currently set up thread to wait for the the thread it is called on to die", "tokens": ["join()", "will", "make", "the", "currently", "set", "up", "thread", "to", "wait", "for", "the", "the", "thread", "it", "is", "called", "on", "to", "die", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> join() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "join()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "join()", "label": "API", "asoc": []}]}
{"text": "join() will make the currently cause thread to wait for the the thread it is called on to die", "tokens": ["join()", "will", "make", "the", "currently", "cause", "thread", "to", "wait", "for", "the", "the", "thread", "it", "is", "called", "on", "to", "die", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> join() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "join()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "join()", "label": "API", "asoc": []}]}
{"text": "join() will make the currently instruct thread to wait for the the thread it is called on to die", "tokens": ["join()", "will", "make", "the", "currently", "instruct", "thread", "to", "wait", "for", "the", "the", "thread", "it", "is", "called", "on", "to", "die", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> join() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "join()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "join()", "label": "API", "asoc": []}]}
{"text": "you can visit the text by calling the text() method on the element", "tokens": ["you", "can", "visit", "the", "text", "by", "calling", "the", "text()", "method", "on", "the", "element", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> text() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "text()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "text()", "label": "API", "asoc": []}]}
{"text": "you can rescan the text by calling the text() method on the element", "tokens": ["you", "can", "rescan", "the", "text", "by", "calling", "the", "text()", "method", "on", "the", "element", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> text() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "text()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "text()", "label": "API", "asoc": []}]}
{"text": "you can scan the text by calling the text() method on the element", "tokens": ["you", "can", "scan", "the", "text", "by", "calling", "the", "text()", "method", "on", "the", "element", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> text() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "text()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "text()", "label": "API", "asoc": []}]}
{"text": "you can walk the text by calling the text() method on the element", "tokens": ["you", "can", "walk", "the", "text", "by", "calling", "the", "text()", "method", "on", "the", "element", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> text() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "text()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "text()", "label": "API", "asoc": []}]}
{"text": "you can iterate the text by calling the text() method on the element", "tokens": ["you", "can", "iterate", "the", "text", "by", "calling", "the", "text()", "method", "on", "the", "element", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> text() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "text()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "text()", "label": "API", "asoc": []}]}
{"text": "you can't modify this map while iterating on it ,  except by update remove() on the iterator", "tokens": ["you", "can't", "modify", "this", "map", "while", "iterating", "on", "it", ",", "", "except", "by", "update", "remove()", "on", "the", "iterator", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "remove()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove()", "label": "API", "asoc": []}]}
{"text": "you can't modify this map while iterating on it ,  except by modify remove() on the iterator", "tokens": ["you", "can't", "modify", "this", "map", "while", "iterating", "on", "it", ",", "", "except", "by", "modify", "remove()", "on", "the", "iterator", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "remove()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove()", "label": "API", "asoc": []}]}
{"text": "you can't modify this map while iterating on it ,  except by fill remove() on the iterator", "tokens": ["you", "can't", "modify", "this", "map", "while", "iterating", "on", "it", ",", "", "except", "by", "fill", "remove()", "on", "the", "iterator", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "remove()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove()", "label": "API", "asoc": []}]}
{"text": "you can't modify this map while iterating on it ,  except by edit remove() on the iterator", "tokens": ["you", "can't", "modify", "this", "map", "while", "iterating", "on", "it", ",", "", "except", "by", "edit", "remove()", "on", "the", "iterator", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "remove()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove()", "label": "API", "asoc": []}]}
{"text": "you can't modify this map while iterating on it ,  except by change remove() on the iterator", "tokens": ["you", "can't", "modify", "this", "map", "while", "iterating", "on", "it", ",", "", "except", "by", "change", "remove()", "on", "the", "iterator", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "remove()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove()", "label": "API", "asoc": []}]}
{"text": "you can't modify this map while iterating on it ,  except by rename remove() on the iterator", "tokens": ["you", "can't", "modify", "this", "map", "while", "iterating", "on", "it", ",", "", "except", "by", "rename", "remove()", "on", "the", "iterator", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "remove()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove()", "label": "API", "asoc": []}]}
{"text": "you can't modify this map while iterating on it ,  except by populate remove() on the iterator", "tokens": ["you", "can't", "modify", "this", "map", "while", "iterating", "on", "it", ",", "", "except", "by", "populate", "remove()", "on", "the", "iterator", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "remove()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove()", "label": "API", "asoc": []}]}
{"text": "you can't modify this map while iterating on it ,  except by adjust remove() on the iterator", "tokens": ["you", "can't", "modify", "this", "map", "while", "iterating", "on", "it", ",", "", "except", "by", "adjust", "remove()", "on", "the", "iterator", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "remove()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove()", "label": "API", "asoc": []}]}
{"text": "you can't modify this map while iterating on it ,  except by flush remove() on the iterator", "tokens": ["you", "can't", "modify", "this", "map", "while", "iterating", "on", "it", ",", "", "except", "by", "flush", "remove()", "on", "the", "iterator", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "remove()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove()", "label": "API", "asoc": []}]}
{"text": "you can't modify this map while iterating on it ,  except by trim remove() on the iterator", "tokens": ["you", "can't", "modify", "this", "map", "while", "iterating", "on", "it", ",", "", "except", "by", "trim", "remove()", "on", "the", "iterator", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "remove()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove()", "label": "API", "asoc": []}]}
{"text": "you can't modify this map while iterating on it ,  except by adapt remove() on the iterator", "tokens": ["you", "can't", "modify", "this", "map", "while", "iterating", "on", "it", ",", "", "except", "by", "adapt", "remove()", "on", "the", "iterator", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "remove()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove()", "label": "API", "asoc": []}]}
{"text": "you can't modify this map while iterating on it ,  except by reconcile remove() on the iterator", "tokens": ["you", "can't", "modify", "this", "map", "while", "iterating", "on", "it", ",", "", "except", "by", "reconcile", "remove()", "on", "the", "iterator", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "remove()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove()", "label": "API", "asoc": []}]}
{"text": "you can't modify this map while iterating on it ,  except by resize remove() on the iterator", "tokens": ["you", "can't", "modify", "this", "map", "while", "iterating", "on", "it", ",", "", "except", "by", "resize", "remove()", "on", "the", "iterator", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "remove()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "remove()", "label": "API", "asoc": []}]}
{"text": "withzonesamelocal() will convert the zone but keep all the other fields the same", "tokens": ["withzonesamelocal()", "will", "convert", "the", "zone", "but", "keep", "all", "the", "other", "fields", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> withzonesamelocal() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "withzonesamelocal()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "withzonesamelocal()", "label": "API", "asoc": []}]}
{"text": "withzonesamelocal() will transfer the zone but keep all the other fields the same", "tokens": ["withzonesamelocal()", "will", "transfer", "the", "zone", "but", "keep", "all", "the", "other", "fields", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> withzonesamelocal() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "withzonesamelocal()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "withzonesamelocal()", "label": "API", "asoc": []}]}
{"text": "withzonesamelocal() will map the zone but keep all the other fields the same", "tokens": ["withzonesamelocal()", "will", "map", "the", "zone", "but", "keep", "all", "the", "other", "fields", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> withzonesamelocal() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "withzonesamelocal()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "withzonesamelocal()", "label": "API", "asoc": []}]}
{"text": "withzonesamelocal() will turn the zone but keep all the other fields the same", "tokens": ["withzonesamelocal()", "will", "turn", "the", "zone", "but", "keep", "all", "the", "other", "fields", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> withzonesamelocal() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "withzonesamelocal()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "withzonesamelocal()", "label": "API", "asoc": []}]}
{"text": "withzonesamelocal() will transform the zone but keep all the other fields the same", "tokens": ["withzonesamelocal()", "will", "transform", "the", "zone", "but", "keep", "all", "the", "other", "fields", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> withzonesamelocal() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "withzonesamelocal()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "withzonesamelocal()", "label": "API", "asoc": []}]}
{"text": "withzonesamelocal() will reconvert the zone but keep all the other fields the same", "tokens": ["withzonesamelocal()", "will", "reconvert", "the", "zone", "but", "keep", "all", "the", "other", "fields", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> withzonesamelocal() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "withzonesamelocal()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "withzonesamelocal()", "label": "API", "asoc": []}]}
{"text": "withzonesamelocal() will move the zone but keep all the other fields the same", "tokens": ["withzonesamelocal()", "will", "move", "the", "zone", "but", "keep", "all", "the", "other", "fields", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> withzonesamelocal() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "withzonesamelocal()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "withzonesamelocal()", "label": "API", "asoc": []}]}
{"text": "withzonesamelocal() will adapt the zone but keep all the other fields the same", "tokens": ["withzonesamelocal()", "will", "adapt", "the", "zone", "but", "keep", "all", "the", "other", "fields", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> withzonesamelocal() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "withzonesamelocal()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "withzonesamelocal()", "label": "API", "asoc": []}]}
{"text": "withzonesamelocal() will translate the zone but keep all the other fields the same", "tokens": ["withzonesamelocal()", "will", "translate", "the", "zone", "but", "keep", "all", "the", "other", "fields", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> withzonesamelocal() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "withzonesamelocal()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "withzonesamelocal()", "label": "API", "asoc": []}]}
{"text": "withzonesamelocal() will force the zone but keep all the other fields the same", "tokens": ["withzonesamelocal()", "will", "force", "the", "zone", "but", "keep", "all", "the", "other", "fields", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> withzonesamelocal() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "withzonesamelocal()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "withzonesamelocal()", "label": "API", "asoc": []}]}
{"text": "withzonesamelocal() will cast the zone but keep all the other fields the same", "tokens": ["withzonesamelocal()", "will", "cast", "the", "zone", "but", "keep", "all", "the", "other", "fields", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> withzonesamelocal() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "withzonesamelocal()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "withzonesamelocal()", "label": "API", "asoc": []}]}
{"text": "withzonesamelocal() will return the zone but keep all the other fields the same", "tokens": ["withzonesamelocal()", "will", "return", "the", "zone", "but", "keep", "all", "the", "other", "fields", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> withzonesamelocal() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "withzonesamelocal()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "withzonesamelocal()", "label": "API", "asoc": []}]}
{"text": "withzonesamelocal() will update the zone but keep all the other fields the same", "tokens": ["withzonesamelocal()", "will", "update", "the", "zone", "but", "keep", "all", "the", "other", "fields", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> withzonesamelocal() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "withzonesamelocal()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "withzonesamelocal()", "label": "API", "asoc": []}]}
{"text": "withzonesamelocal() will modify the zone but keep all the other fields the same", "tokens": ["withzonesamelocal()", "will", "modify", "the", "zone", "but", "keep", "all", "the", "other", "fields", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> withzonesamelocal() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "withzonesamelocal()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "withzonesamelocal()", "label": "API", "asoc": []}]}
{"text": "withzonesamelocal() will fill the zone but keep all the other fields the same", "tokens": ["withzonesamelocal()", "will", "fill", "the", "zone", "but", "keep", "all", "the", "other", "fields", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> withzonesamelocal() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "withzonesamelocal()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "withzonesamelocal()", "label": "API", "asoc": []}]}
{"text": "withzonesamelocal() will edit the zone but keep all the other fields the same", "tokens": ["withzonesamelocal()", "will", "edit", "the", "zone", "but", "keep", "all", "the", "other", "fields", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> withzonesamelocal() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "withzonesamelocal()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "withzonesamelocal()", "label": "API", "asoc": []}]}
{"text": "withzonesamelocal() will rename the zone but keep all the other fields the same", "tokens": ["withzonesamelocal()", "will", "rename", "the", "zone", "but", "keep", "all", "the", "other", "fields", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> withzonesamelocal() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "withzonesamelocal()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "withzonesamelocal()", "label": "API", "asoc": []}]}
{"text": "withzonesamelocal() will populate the zone but keep all the other fields the same", "tokens": ["withzonesamelocal()", "will", "populate", "the", "zone", "but", "keep", "all", "the", "other", "fields", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> withzonesamelocal() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "withzonesamelocal()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "withzonesamelocal()", "label": "API", "asoc": []}]}
{"text": "withzonesamelocal() will adjust the zone but keep all the other fields the same", "tokens": ["withzonesamelocal()", "will", "adjust", "the", "zone", "but", "keep", "all", "the", "other", "fields", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> withzonesamelocal() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "withzonesamelocal()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "withzonesamelocal()", "label": "API", "asoc": []}]}
{"text": "withzonesamelocal() will flush the zone but keep all the other fields the same", "tokens": ["withzonesamelocal()", "will", "flush", "the", "zone", "but", "keep", "all", "the", "other", "fields", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> withzonesamelocal() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "withzonesamelocal()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "withzonesamelocal()", "label": "API", "asoc": []}]}
{"text": "withzonesamelocal() will trim the zone but keep all the other fields the same", "tokens": ["withzonesamelocal()", "will", "trim", "the", "zone", "but", "keep", "all", "the", "other", "fields", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> withzonesamelocal() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "withzonesamelocal()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "withzonesamelocal()", "label": "API", "asoc": []}]}
{"text": "withzonesamelocal() will reconcile the zone but keep all the other fields the same", "tokens": ["withzonesamelocal()", "will", "reconcile", "the", "zone", "but", "keep", "all", "the", "other", "fields", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> withzonesamelocal() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "withzonesamelocal()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "withzonesamelocal()", "label": "API", "asoc": []}]}
{"text": "withzonesamelocal() will resize the zone but keep all the other fields the same", "tokens": ["withzonesamelocal()", "will", "resize", "the", "zone", "but", "keep", "all", "the", "other", "fields", "the", "same", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> withzonesamelocal() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "withzonesamelocal()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "withzonesamelocal()", "label": "API", "asoc": []}]}
{"text": "you need to invoke repaint() and revalidate()", "tokens": ["you", "need", "to", "invoke", "repaint()", "and", "revalidate()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_0> function collaboration <extra_id_5> revalidate() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> revalidate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "repaint()"}, {"type": "API", "offset": [6], "text": "revalidate()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [4], "text": "repaint()"}, {"type": "API", "offset": [6], "text": "revalidate()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": [["function collaboration", "revalidate()"]]}, {"span": "revalidate()", "label": "API", "asoc": []}]}
{"text": "you need to tell repaint() and revalidate()", "tokens": ["you", "need", "to", "tell", "repaint()", "and", "revalidate()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_0> function collaboration <extra_id_5> revalidate() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> revalidate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "repaint()"}, {"type": "API", "offset": [6], "text": "revalidate()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [4], "text": "repaint()"}, {"type": "API", "offset": [6], "text": "revalidate()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": [["function collaboration", "revalidate()"]]}, {"span": "revalidate()", "label": "API", "asoc": []}]}
{"text": "you need to indicate repaint() and revalidate()", "tokens": ["you", "need", "to", "indicate", "repaint()", "and", "revalidate()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_0> function collaboration <extra_id_5> revalidate() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> revalidate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "repaint()"}, {"type": "API", "offset": [6], "text": "revalidate()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [4], "text": "repaint()"}, {"type": "API", "offset": [6], "text": "revalidate()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": [["function collaboration", "revalidate()"]]}, {"span": "revalidate()", "label": "API", "asoc": []}]}
{"text": "you need to occur repaint() and revalidate()", "tokens": ["you", "need", "to", "occur", "repaint()", "and", "revalidate()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_0> function collaboration <extra_id_5> revalidate() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> revalidate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "repaint()"}, {"type": "API", "offset": [6], "text": "revalidate()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [4], "text": "repaint()"}, {"type": "API", "offset": [6], "text": "revalidate()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": [["function collaboration", "revalidate()"]]}, {"span": "revalidate()", "label": "API", "asoc": []}]}
{"text": "you need to perform repaint() and revalidate()", "tokens": ["you", "need", "to", "perform", "repaint()", "and", "revalidate()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_0> function collaboration <extra_id_5> revalidate() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> revalidate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "repaint()"}, {"type": "API", "offset": [6], "text": "revalidate()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [4], "text": "repaint()"}, {"type": "API", "offset": [6], "text": "revalidate()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": [["function collaboration", "revalidate()"]]}, {"span": "revalidate()", "label": "API", "asoc": []}]}
{"text": "you need to prompt repaint() and revalidate()", "tokens": ["you", "need", "to", "prompt", "repaint()", "and", "revalidate()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_0> function collaboration <extra_id_5> revalidate() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> revalidate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "repaint()"}, {"type": "API", "offset": [6], "text": "revalidate()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [4], "text": "repaint()"}, {"type": "API", "offset": [6], "text": "revalidate()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": [["function collaboration", "revalidate()"]]}, {"span": "revalidate()", "label": "API", "asoc": []}]}
{"text": "you need to notify repaint() and revalidate()", "tokens": ["you", "need", "to", "notify", "repaint()", "and", "revalidate()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_0> function collaboration <extra_id_5> revalidate() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> revalidate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "repaint()"}, {"type": "API", "offset": [6], "text": "revalidate()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [4], "text": "repaint()"}, {"type": "API", "offset": [6], "text": "revalidate()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": [["function collaboration", "revalidate()"]]}, {"span": "revalidate()", "label": "API", "asoc": []}]}
{"text": "you need to execute repaint() and revalidate()", "tokens": ["you", "need", "to", "execute", "repaint()", "and", "revalidate()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_0> function collaboration <extra_id_5> revalidate() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> revalidate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "repaint()"}, {"type": "API", "offset": [6], "text": "revalidate()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [4], "text": "repaint()"}, {"type": "API", "offset": [6], "text": "revalidate()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": [["function collaboration", "revalidate()"]]}, {"span": "revalidate()", "label": "API", "asoc": []}]}
{"text": "you need to run repaint() and revalidate()", "tokens": ["you", "need", "to", "run", "repaint()", "and", "revalidate()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_0> function collaboration <extra_id_5> revalidate() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> revalidate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "repaint()"}, {"type": "API", "offset": [6], "text": "revalidate()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [4], "text": "repaint()"}, {"type": "API", "offset": [6], "text": "revalidate()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": [["function collaboration", "revalidate()"]]}, {"span": "revalidate()", "label": "API", "asoc": []}]}
{"text": "you need to enforce repaint() and revalidate()", "tokens": ["you", "need", "to", "enforce", "repaint()", "and", "revalidate()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_0> function collaboration <extra_id_5> revalidate() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> revalidate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "repaint()"}, {"type": "API", "offset": [6], "text": "revalidate()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [4], "text": "repaint()"}, {"type": "API", "offset": [6], "text": "revalidate()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": [["function collaboration", "revalidate()"]]}, {"span": "revalidate()", "label": "API", "asoc": []}]}
{"text": "you need to fire repaint() and revalidate()", "tokens": ["you", "need", "to", "fire", "repaint()", "and", "revalidate()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_0> function collaboration <extra_id_5> revalidate() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> revalidate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "repaint()"}, {"type": "API", "offset": [6], "text": "revalidate()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [4], "text": "repaint()"}, {"type": "API", "offset": [6], "text": "revalidate()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": [["function collaboration", "revalidate()"]]}, {"span": "revalidate()", "label": "API", "asoc": []}]}
{"text": "you need to trigger repaint() and revalidate()", "tokens": ["you", "need", "to", "trigger", "repaint()", "and", "revalidate()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_0> function collaboration <extra_id_5> revalidate() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> revalidate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [4], "text": "repaint()"}, {"type": "API", "offset": [6], "text": "revalidate()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [4], "text": "repaint()"}, {"type": "API", "offset": [6], "text": "revalidate()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": [["function collaboration", "revalidate()"]]}, {"span": "revalidate()", "label": "API", "asoc": []}]}
{"text": "because the first thread has already checked the condition however ,  it will simply invoke wait() after being re-scheduled ,  even though it could make progress", "tokens": ["because", "the", "first", "thread", "has", "already", "checked", "the", "condition", "however", ",", "", "it", "will", "simply", "invoke", "wait()", "after", "being", "re-scheduled", ",", "", "even", "though", "it", "could", "make", "progress", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "because the first thread has already checked the condition however ,  it will simply tell wait() after being re-scheduled ,  even though it could make progress", "tokens": ["because", "the", "first", "thread", "has", "already", "checked", "the", "condition", "however", ",", "", "it", "will", "simply", "tell", "wait()", "after", "being", "re-scheduled", ",", "", "even", "though", "it", "could", "make", "progress", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "because the first thread has already checked the condition however ,  it will simply indicate wait() after being re-scheduled ,  even though it could make progress", "tokens": ["because", "the", "first", "thread", "has", "already", "checked", "the", "condition", "however", ",", "", "it", "will", "simply", "indicate", "wait()", "after", "being", "re-scheduled", ",", "", "even", "though", "it", "could", "make", "progress", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "because the first thread has already checked the condition however ,  it will simply occur wait() after being re-scheduled ,  even though it could make progress", "tokens": ["because", "the", "first", "thread", "has", "already", "checked", "the", "condition", "however", ",", "", "it", "will", "simply", "occur", "wait()", "after", "being", "re-scheduled", ",", "", "even", "though", "it", "could", "make", "progress", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "because the first thread has already checked the condition however ,  it will simply perform wait() after being re-scheduled ,  even though it could make progress", "tokens": ["because", "the", "first", "thread", "has", "already", "checked", "the", "condition", "however", ",", "", "it", "will", "simply", "perform", "wait()", "after", "being", "re-scheduled", ",", "", "even", "though", "it", "could", "make", "progress", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "because the first thread has already checked the condition however ,  it will simply prompt wait() after being re-scheduled ,  even though it could make progress", "tokens": ["because", "the", "first", "thread", "has", "already", "checked", "the", "condition", "however", ",", "", "it", "will", "simply", "prompt", "wait()", "after", "being", "re-scheduled", ",", "", "even", "though", "it", "could", "make", "progress", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "because the first thread has already checked the condition however ,  it will simply notify wait() after being re-scheduled ,  even though it could make progress", "tokens": ["because", "the", "first", "thread", "has", "already", "checked", "the", "condition", "however", ",", "", "it", "will", "simply", "notify", "wait()", "after", "being", "re-scheduled", ",", "", "even", "though", "it", "could", "make", "progress", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "because the first thread has already checked the condition however ,  it will simply execute wait() after being re-scheduled ,  even though it could make progress", "tokens": ["because", "the", "first", "thread", "has", "already", "checked", "the", "condition", "however", ",", "", "it", "will", "simply", "execute", "wait()", "after", "being", "re-scheduled", ",", "", "even", "though", "it", "could", "make", "progress", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "because the first thread has already checked the condition however ,  it will simply run wait() after being re-scheduled ,  even though it could make progress", "tokens": ["because", "the", "first", "thread", "has", "already", "checked", "the", "condition", "however", ",", "", "it", "will", "simply", "run", "wait()", "after", "being", "re-scheduled", ",", "", "even", "though", "it", "could", "make", "progress", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "because the first thread has already checked the condition however ,  it will simply enforce wait() after being re-scheduled ,  even though it could make progress", "tokens": ["because", "the", "first", "thread", "has", "already", "checked", "the", "condition", "however", ",", "", "it", "will", "simply", "enforce", "wait()", "after", "being", "re-scheduled", ",", "", "even", "though", "it", "could", "make", "progress", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "because the first thread has already checked the condition however ,  it will simply fire wait() after being re-scheduled ,  even though it could make progress", "tokens": ["because", "the", "first", "thread", "has", "already", "checked", "the", "condition", "however", ",", "", "it", "will", "simply", "fire", "wait()", "after", "being", "re-scheduled", ",", "", "even", "though", "it", "could", "make", "progress", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "because the first thread has already checked the condition however ,  it will simply trigger wait() after being re-scheduled ,  even though it could make progress", "tokens": ["because", "the", "first", "thread", "has", "already", "checked", "the", "condition", "however", ",", "", "it", "will", "simply", "trigger", "wait()", "after", "being", "re-scheduled", ",", "", "even", "though", "it", "could", "make", "progress", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> wait() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "wait()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "wait()", "label": "API", "asoc": []}]}
{"text": "for the first iteration it's good enough as long as you invoke method setfilter every time user types something in your jtextfield .", "tokens": ["for", "the", "first", "iteration", "it's", "good", "enough", "as", "long", "as", "you", "invoke", "method", "setfilter", "every", "time", "user", "types", "something", "in", "your", "jtextfield", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> setfilter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "setfilter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "setfilter", "label": "API", "asoc": []}]}
{"text": "for the first iteration it's good enough as long as you tell method setfilter every time user types something in your jtextfield .", "tokens": ["for", "the", "first", "iteration", "it's", "good", "enough", "as", "long", "as", "you", "tell", "method", "setfilter", "every", "time", "user", "types", "something", "in", "your", "jtextfield", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> setfilter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "setfilter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "setfilter", "label": "API", "asoc": []}]}
{"text": "for the first iteration it's good enough as long as you indicate method setfilter every time user types something in your jtextfield .", "tokens": ["for", "the", "first", "iteration", "it's", "good", "enough", "as", "long", "as", "you", "indicate", "method", "setfilter", "every", "time", "user", "types", "something", "in", "your", "jtextfield", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> setfilter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "setfilter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "setfilter", "label": "API", "asoc": []}]}
{"text": "for the first iteration it's good enough as long as you occur method setfilter every time user types something in your jtextfield .", "tokens": ["for", "the", "first", "iteration", "it's", "good", "enough", "as", "long", "as", "you", "occur", "method", "setfilter", "every", "time", "user", "types", "something", "in", "your", "jtextfield", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> setfilter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "setfilter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "setfilter", "label": "API", "asoc": []}]}
{"text": "for the first iteration it's good enough as long as you perform method setfilter every time user types something in your jtextfield .", "tokens": ["for", "the", "first", "iteration", "it's", "good", "enough", "as", "long", "as", "you", "perform", "method", "setfilter", "every", "time", "user", "types", "something", "in", "your", "jtextfield", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> setfilter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "setfilter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "setfilter", "label": "API", "asoc": []}]}
{"text": "for the first iteration it's good enough as long as you prompt method setfilter every time user types something in your jtextfield .", "tokens": ["for", "the", "first", "iteration", "it's", "good", "enough", "as", "long", "as", "you", "prompt", "method", "setfilter", "every", "time", "user", "types", "something", "in", "your", "jtextfield", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> setfilter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "setfilter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "setfilter", "label": "API", "asoc": []}]}
{"text": "for the first iteration it's good enough as long as you notify method setfilter every time user types something in your jtextfield .", "tokens": ["for", "the", "first", "iteration", "it's", "good", "enough", "as", "long", "as", "you", "notify", "method", "setfilter", "every", "time", "user", "types", "something", "in", "your", "jtextfield", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> setfilter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "setfilter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "setfilter", "label": "API", "asoc": []}]}
{"text": "for the first iteration it's good enough as long as you execute method setfilter every time user types something in your jtextfield .", "tokens": ["for", "the", "first", "iteration", "it's", "good", "enough", "as", "long", "as", "you", "execute", "method", "setfilter", "every", "time", "user", "types", "something", "in", "your", "jtextfield", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> setfilter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "setfilter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "setfilter", "label": "API", "asoc": []}]}
{"text": "for the first iteration it's good enough as long as you run method setfilter every time user types something in your jtextfield .", "tokens": ["for", "the", "first", "iteration", "it's", "good", "enough", "as", "long", "as", "you", "run", "method", "setfilter", "every", "time", "user", "types", "something", "in", "your", "jtextfield", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> setfilter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "setfilter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "setfilter", "label": "API", "asoc": []}]}
{"text": "for the first iteration it's good enough as long as you enforce method setfilter every time user types something in your jtextfield .", "tokens": ["for", "the", "first", "iteration", "it's", "good", "enough", "as", "long", "as", "you", "enforce", "method", "setfilter", "every", "time", "user", "types", "something", "in", "your", "jtextfield", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> setfilter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "setfilter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "setfilter", "label": "API", "asoc": []}]}
{"text": "for the first iteration it's good enough as long as you fire method setfilter every time user types something in your jtextfield .", "tokens": ["for", "the", "first", "iteration", "it's", "good", "enough", "as", "long", "as", "you", "fire", "method", "setfilter", "every", "time", "user", "types", "something", "in", "your", "jtextfield", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> setfilter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "setfilter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "setfilter", "label": "API", "asoc": []}]}
{"text": "for the first iteration it's good enough as long as you trigger method setfilter every time user types something in your jtextfield .", "tokens": ["for", "the", "first", "iteration", "it's", "good", "enough", "as", "long", "as", "you", "trigger", "method", "setfilter", "every", "time", "user", "types", "something", "in", "your", "jtextfield", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> setfilter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "setfilter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "setfilter", "label": "API", "asoc": []}]}
{"text": "considering object identity \"it is recommended that you create equals() and hashcode() using business key equality", "tokens": ["considering", "object", "identity", "\"it", "is", "recommended", "that", "you", "create", "equals()", "and", "hashcode()", "using", "business", "key", "equality", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_0> function collaboration <extra_id_5> hashcode() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> hashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": [["function collaboration", "hashcode()"]]}, {"span": "hashcode()", "label": "API", "asoc": []}]}
{"text": "considering object identity \"it is recommended that you build equals() and hashcode() using business key equality", "tokens": ["considering", "object", "identity", "\"it", "is", "recommended", "that", "you", "build", "equals()", "and", "hashcode()", "using", "business", "key", "equality", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_0> function collaboration <extra_id_5> hashcode() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> hashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": [["function collaboration", "hashcode()"]]}, {"span": "hashcode()", "label": "API", "asoc": []}]}
{"text": "considering object identity \"it is recommended that you produce equals() and hashcode() using business key equality", "tokens": ["considering", "object", "identity", "\"it", "is", "recommended", "that", "you", "produce", "equals()", "and", "hashcode()", "using", "business", "key", "equality", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_0> function collaboration <extra_id_5> hashcode() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> hashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": [["function collaboration", "hashcode()"]]}, {"span": "hashcode()", "label": "API", "asoc": []}]}
{"text": "considering object identity \"it is recommended that you construct equals() and hashcode() using business key equality", "tokens": ["considering", "object", "identity", "\"it", "is", "recommended", "that", "you", "construct", "equals()", "and", "hashcode()", "using", "business", "key", "equality", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_0> function collaboration <extra_id_5> hashcode() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> hashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": [["function collaboration", "hashcode()"]]}, {"span": "hashcode()", "label": "API", "asoc": []}]}
{"text": "considering object identity \"it is recommended that you generate equals() and hashcode() using business key equality", "tokens": ["considering", "object", "identity", "\"it", "is", "recommended", "that", "you", "generate", "equals()", "and", "hashcode()", "using", "business", "key", "equality", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_0> function collaboration <extra_id_5> hashcode() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> hashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": [["function collaboration", "hashcode()"]]}, {"span": "hashcode()", "label": "API", "asoc": []}]}
{"text": "considering object identity \"it is recommended that you establish equals() and hashcode() using business key equality", "tokens": ["considering", "object", "identity", "\"it", "is", "recommended", "that", "you", "establish", "equals()", "and", "hashcode()", "using", "business", "key", "equality", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_0> function collaboration <extra_id_5> hashcode() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> hashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": [["function collaboration", "hashcode()"]]}, {"span": "hashcode()", "label": "API", "asoc": []}]}
{"text": "considering object identity \"it is recommended that you make equals() and hashcode() using business key equality", "tokens": ["considering", "object", "identity", "\"it", "is", "recommended", "that", "you", "make", "equals()", "and", "hashcode()", "using", "business", "key", "equality", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_0> function collaboration <extra_id_5> hashcode() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> hashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": [["function collaboration", "hashcode()"]]}, {"span": "hashcode()", "label": "API", "asoc": []}]}
{"text": "considering object identity \"it is recommended that you obtain equals() and hashcode() using business key equality", "tokens": ["considering", "object", "identity", "\"it", "is", "recommended", "that", "you", "obtain", "equals()", "and", "hashcode()", "using", "business", "key", "equality", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_0> function collaboration <extra_id_5> hashcode() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> hashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": [["function collaboration", "hashcode()"]]}, {"span": "hashcode()", "label": "API", "asoc": []}]}
{"text": "considering object identity \"it is recommended that you reconstitute equals() and hashcode() using business key equality", "tokens": ["considering", "object", "identity", "\"it", "is", "recommended", "that", "you", "reconstitute", "equals()", "and", "hashcode()", "using", "business", "key", "equality", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_0> function collaboration <extra_id_5> hashcode() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> hashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": [["function collaboration", "hashcode()"]]}, {"span": "hashcode()", "label": "API", "asoc": []}]}
{"text": "considering object identity \"it is recommended that you compose equals() and hashcode() using business key equality", "tokens": ["considering", "object", "identity", "\"it", "is", "recommended", "that", "you", "compose", "equals()", "and", "hashcode()", "using", "business", "key", "equality", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_0> function collaboration <extra_id_5> hashcode() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> hashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": [["function collaboration", "hashcode()"]]}, {"span": "hashcode()", "label": "API", "asoc": []}]}
{"text": "considering object identity \"it is recommended that you instantiate equals() and hashcode() using business key equality", "tokens": ["considering", "object", "identity", "\"it", "is", "recommended", "that", "you", "instantiate", "equals()", "and", "hashcode()", "using", "business", "key", "equality", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_0> function collaboration <extra_id_5> hashcode() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> hashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": [["function collaboration", "hashcode()"]]}, {"span": "hashcode()", "label": "API", "asoc": []}]}
{"text": "considering object identity \"it is recommended that you get equals() and hashcode() using business key equality", "tokens": ["considering", "object", "identity", "\"it", "is", "recommended", "that", "you", "get", "equals()", "and", "hashcode()", "using", "business", "key", "equality", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_0> function collaboration <extra_id_5> hashcode() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> hashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": [["function collaboration", "hashcode()"]]}, {"span": "hashcode()", "label": "API", "asoc": []}]}
{"text": "considering object identity \"it is recommended that you retrieve equals() and hashcode() using business key equality", "tokens": ["considering", "object", "identity", "\"it", "is", "recommended", "that", "you", "retrieve", "equals()", "and", "hashcode()", "using", "business", "key", "equality", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_0> function collaboration <extra_id_5> hashcode() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> hashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": [["function collaboration", "hashcode()"]]}, {"span": "hashcode()", "label": "API", "asoc": []}]}
{"text": "considering object identity \"it is recommended that you return equals() and hashcode() using business key equality", "tokens": ["considering", "object", "identity", "\"it", "is", "recommended", "that", "you", "return", "equals()", "and", "hashcode()", "using", "business", "key", "equality", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_0> function collaboration <extra_id_5> hashcode() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> hashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": [["function collaboration", "hashcode()"]]}, {"span": "hashcode()", "label": "API", "asoc": []}]}
{"text": "considering object identity \"it is recommended that you install equals() and hashcode() using business key equality", "tokens": ["considering", "object", "identity", "\"it", "is", "recommended", "that", "you", "install", "equals()", "and", "hashcode()", "using", "business", "key", "equality", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_0> function collaboration <extra_id_5> hashcode() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> hashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [9], "text": "equals()"}, {"type": "API", "offset": [11], "text": "hashcode()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": [["function collaboration", "hashcode()"]]}, {"span": "hashcode()", "label": "API", "asoc": []}]}
{"text": "considering object identity \"it is recommended that you set up equals() and hashcode() using business key equality", "tokens": ["considering", "object", "identity", "\"it", "is", "recommended", "that", "you", "set", "up", "equals()", "and", "hashcode()", "using", "business", "key", "equality", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> equals() <extra_id_0> function collaboration <extra_id_5> hashcode() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> hashcode() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "equals()"}, {"type": "API", "offset": [12], "text": "hashcode()"}], "relation": [{"type": "function collaboration", "args": [{"type": "API", "offset": [10], "text": "equals()"}, {"type": "API", "offset": [12], "text": "hashcode()"}]}], "event": [], "spot": ["API"], "asoc": ["function collaboration"], "spot_asoc": [{"span": "equals()", "label": "API", "asoc": [["function collaboration", "hashcode()"]]}, {"span": "hashcode()", "label": "API", "asoc": []}]}
{"text": "you should build your own class that is serializable that includes two fields: a byte[] for the file contents ,  and a java.io.file that has everything else you need", "tokens": ["you", "should", "build", "your", "own", "class", "that", "is", "serializable", "that", "includes", "two", "fields:", "a", "byte[]", "for", "the", "file", "contents", ",", "", "and", "a", "java.io.file", "that", "has", "everything", "else", "you", "need", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.io.file <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "java.io.file"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.io.file", "label": "API", "asoc": []}]}
{"text": "you should produce your own class that is serializable that includes two fields: a byte[] for the file contents ,  and a java.io.file that has everything else you need", "tokens": ["you", "should", "produce", "your", "own", "class", "that", "is", "serializable", "that", "includes", "two", "fields:", "a", "byte[]", "for", "the", "file", "contents", ",", "", "and", "a", "java.io.file", "that", "has", "everything", "else", "you", "need", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.io.file <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "java.io.file"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.io.file", "label": "API", "asoc": []}]}
{"text": "you should construct your own class that is serializable that includes two fields: a byte[] for the file contents ,  and a java.io.file that has everything else you need", "tokens": ["you", "should", "construct", "your", "own", "class", "that", "is", "serializable", "that", "includes", "two", "fields:", "a", "byte[]", "for", "the", "file", "contents", ",", "", "and", "a", "java.io.file", "that", "has", "everything", "else", "you", "need", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.io.file <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "java.io.file"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.io.file", "label": "API", "asoc": []}]}
{"text": "you should generate your own class that is serializable that includes two fields: a byte[] for the file contents ,  and a java.io.file that has everything else you need", "tokens": ["you", "should", "generate", "your", "own", "class", "that", "is", "serializable", "that", "includes", "two", "fields:", "a", "byte[]", "for", "the", "file", "contents", ",", "", "and", "a", "java.io.file", "that", "has", "everything", "else", "you", "need", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.io.file <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "java.io.file"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.io.file", "label": "API", "asoc": []}]}
{"text": "you should establish your own class that is serializable that includes two fields: a byte[] for the file contents ,  and a java.io.file that has everything else you need", "tokens": ["you", "should", "establish", "your", "own", "class", "that", "is", "serializable", "that", "includes", "two", "fields:", "a", "byte[]", "for", "the", "file", "contents", ",", "", "and", "a", "java.io.file", "that", "has", "everything", "else", "you", "need", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.io.file <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "java.io.file"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.io.file", "label": "API", "asoc": []}]}
{"text": "you should make your own class that is serializable that includes two fields: a byte[] for the file contents ,  and a java.io.file that has everything else you need", "tokens": ["you", "should", "make", "your", "own", "class", "that", "is", "serializable", "that", "includes", "two", "fields:", "a", "byte[]", "for", "the", "file", "contents", ",", "", "and", "a", "java.io.file", "that", "has", "everything", "else", "you", "need", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.io.file <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "java.io.file"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.io.file", "label": "API", "asoc": []}]}
{"text": "you should obtain your own class that is serializable that includes two fields: a byte[] for the file contents ,  and a java.io.file that has everything else you need", "tokens": ["you", "should", "obtain", "your", "own", "class", "that", "is", "serializable", "that", "includes", "two", "fields:", "a", "byte[]", "for", "the", "file", "contents", ",", "", "and", "a", "java.io.file", "that", "has", "everything", "else", "you", "need", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.io.file <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "java.io.file"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.io.file", "label": "API", "asoc": []}]}
{"text": "you should reconstitute your own class that is serializable that includes two fields: a byte[] for the file contents ,  and a java.io.file that has everything else you need", "tokens": ["you", "should", "reconstitute", "your", "own", "class", "that", "is", "serializable", "that", "includes", "two", "fields:", "a", "byte[]", "for", "the", "file", "contents", ",", "", "and", "a", "java.io.file", "that", "has", "everything", "else", "you", "need", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.io.file <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "java.io.file"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.io.file", "label": "API", "asoc": []}]}
{"text": "you should compose your own class that is serializable that includes two fields: a byte[] for the file contents ,  and a java.io.file that has everything else you need", "tokens": ["you", "should", "compose", "your", "own", "class", "that", "is", "serializable", "that", "includes", "two", "fields:", "a", "byte[]", "for", "the", "file", "contents", ",", "", "and", "a", "java.io.file", "that", "has", "everything", "else", "you", "need", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.io.file <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "java.io.file"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.io.file", "label": "API", "asoc": []}]}
{"text": "you should instantiate your own class that is serializable that includes two fields: a byte[] for the file contents ,  and a java.io.file that has everything else you need", "tokens": ["you", "should", "instantiate", "your", "own", "class", "that", "is", "serializable", "that", "includes", "two", "fields:", "a", "byte[]", "for", "the", "file", "contents", ",", "", "and", "a", "java.io.file", "that", "has", "everything", "else", "you", "need", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.io.file <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "java.io.file"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.io.file", "label": "API", "asoc": []}]}
{"text": "you should implement your own class that is serializable that includes two fields: a byte[] for the file contents ,  and a java.io.file that has everything else you need", "tokens": ["you", "should", "implement", "your", "own", "class", "that", "is", "serializable", "that", "includes", "two", "fields:", "a", "byte[]", "for", "the", "file", "contents", ",", "", "and", "a", "java.io.file", "that", "has", "everything", "else", "you", "need", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.io.file <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "java.io.file"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.io.file", "label": "API", "asoc": []}]}
{"text": "you should get your own class that is serializable that includes two fields: a byte[] for the file contents ,  and a java.io.file that has everything else you need", "tokens": ["you", "should", "get", "your", "own", "class", "that", "is", "serializable", "that", "includes", "two", "fields:", "a", "byte[]", "for", "the", "file", "contents", ",", "", "and", "a", "java.io.file", "that", "has", "everything", "else", "you", "need", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.io.file <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "java.io.file"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.io.file", "label": "API", "asoc": []}]}
{"text": "you should retrieve your own class that is serializable that includes two fields: a byte[] for the file contents ,  and a java.io.file that has everything else you need", "tokens": ["you", "should", "retrieve", "your", "own", "class", "that", "is", "serializable", "that", "includes", "two", "fields:", "a", "byte[]", "for", "the", "file", "contents", ",", "", "and", "a", "java.io.file", "that", "has", "everything", "else", "you", "need", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.io.file <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "java.io.file"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.io.file", "label": "API", "asoc": []}]}
{"text": "you should return your own class that is serializable that includes two fields: a byte[] for the file contents ,  and a java.io.file that has everything else you need", "tokens": ["you", "should", "return", "your", "own", "class", "that", "is", "serializable", "that", "includes", "two", "fields:", "a", "byte[]", "for", "the", "file", "contents", ",", "", "and", "a", "java.io.file", "that", "has", "everything", "else", "you", "need", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.io.file <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "java.io.file"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.io.file", "label": "API", "asoc": []}]}
{"text": "you should install your own class that is serializable that includes two fields: a byte[] for the file contents ,  and a java.io.file that has everything else you need", "tokens": ["you", "should", "install", "your", "own", "class", "that", "is", "serializable", "that", "includes", "two", "fields:", "a", "byte[]", "for", "the", "file", "contents", ",", "", "and", "a", "java.io.file", "that", "has", "everything", "else", "you", "need", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.io.file <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "java.io.file"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.io.file", "label": "API", "asoc": []}]}
{"text": "you should set up your own class that is serializable that includes two fields: a byte[] for the file contents ,  and a java.io.file that has everything else you need", "tokens": ["you", "should", "set", "up", "your", "own", "class", "that", "is", "serializable", "that", "includes", "two", "fields:", "a", "byte[]", "for", "the", "file", "contents", ",", "", "and", "a", "java.io.file", "that", "has", "everything", "else", "you", "need", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> java.io.file <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [24], "text": "java.io.file"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "java.io.file", "label": "API", "asoc": []}]}
{"text": "when you invoke bufferedimage.getsubimage() ,  then the image on which you invoke this method will become \"unmanaged\"", "tokens": ["when", "you", "invoke", "bufferedimage.getsubimage()", ",", "", "then", "the", "image", "on", "which", "you", "invoke", "this", "method", "will", "become", "\"unmanaged\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> bufferedimage.getsubimage() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "bufferedimage.getsubimage()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "bufferedimage.getsubimage()", "label": "API", "asoc": []}]}
{"text": "when you tell bufferedimage.getsubimage() ,  then the image on which you tell this method will become \"unmanaged\"", "tokens": ["when", "you", "tell", "bufferedimage.getsubimage()", ",", "", "then", "the", "image", "on", "which", "you", "tell", "this", "method", "will", "become", "\"unmanaged\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> bufferedimage.getsubimage() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "bufferedimage.getsubimage()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "bufferedimage.getsubimage()", "label": "API", "asoc": []}]}
{"text": "when you indicate bufferedimage.getsubimage() ,  then the image on which you indicate this method will become \"unmanaged\"", "tokens": ["when", "you", "indicate", "bufferedimage.getsubimage()", ",", "", "then", "the", "image", "on", "which", "you", "indicate", "this", "method", "will", "become", "\"unmanaged\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> bufferedimage.getsubimage() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "bufferedimage.getsubimage()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "bufferedimage.getsubimage()", "label": "API", "asoc": []}]}
{"text": "when you occur bufferedimage.getsubimage() ,  then the image on which you occur this method will become \"unmanaged\"", "tokens": ["when", "you", "occur", "bufferedimage.getsubimage()", ",", "", "then", "the", "image", "on", "which", "you", "occur", "this", "method", "will", "become", "\"unmanaged\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> bufferedimage.getsubimage() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "bufferedimage.getsubimage()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "bufferedimage.getsubimage()", "label": "API", "asoc": []}]}
{"text": "when you perform bufferedimage.getsubimage() ,  then the image on which you perform this method will become \"unmanaged\"", "tokens": ["when", "you", "perform", "bufferedimage.getsubimage()", ",", "", "then", "the", "image", "on", "which", "you", "perform", "this", "method", "will", "become", "\"unmanaged\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> bufferedimage.getsubimage() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "bufferedimage.getsubimage()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "bufferedimage.getsubimage()", "label": "API", "asoc": []}]}
{"text": "when you prompt bufferedimage.getsubimage() ,  then the image on which you prompt this method will become \"unmanaged\"", "tokens": ["when", "you", "prompt", "bufferedimage.getsubimage()", ",", "", "then", "the", "image", "on", "which", "you", "prompt", "this", "method", "will", "become", "\"unmanaged\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> bufferedimage.getsubimage() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "bufferedimage.getsubimage()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "bufferedimage.getsubimage()", "label": "API", "asoc": []}]}
{"text": "when you notify bufferedimage.getsubimage() ,  then the image on which you notify this method will become \"unmanaged\"", "tokens": ["when", "you", "notify", "bufferedimage.getsubimage()", ",", "", "then", "the", "image", "on", "which", "you", "notify", "this", "method", "will", "become", "\"unmanaged\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> bufferedimage.getsubimage() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "bufferedimage.getsubimage()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "bufferedimage.getsubimage()", "label": "API", "asoc": []}]}
{"text": "when you execute bufferedimage.getsubimage() ,  then the image on which you execute this method will become \"unmanaged\"", "tokens": ["when", "you", "execute", "bufferedimage.getsubimage()", ",", "", "then", "the", "image", "on", "which", "you", "execute", "this", "method", "will", "become", "\"unmanaged\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> bufferedimage.getsubimage() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "bufferedimage.getsubimage()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "bufferedimage.getsubimage()", "label": "API", "asoc": []}]}
{"text": "when you run bufferedimage.getsubimage() ,  then the image on which you run this method will become \"unmanaged\"", "tokens": ["when", "you", "run", "bufferedimage.getsubimage()", ",", "", "then", "the", "image", "on", "which", "you", "run", "this", "method", "will", "become", "\"unmanaged\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> bufferedimage.getsubimage() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "bufferedimage.getsubimage()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "bufferedimage.getsubimage()", "label": "API", "asoc": []}]}
{"text": "when you enforce bufferedimage.getsubimage() ,  then the image on which you enforce this method will become \"unmanaged\"", "tokens": ["when", "you", "enforce", "bufferedimage.getsubimage()", ",", "", "then", "the", "image", "on", "which", "you", "enforce", "this", "method", "will", "become", "\"unmanaged\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> bufferedimage.getsubimage() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "bufferedimage.getsubimage()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "bufferedimage.getsubimage()", "label": "API", "asoc": []}]}
{"text": "when you fire bufferedimage.getsubimage() ,  then the image on which you fire this method will become \"unmanaged\"", "tokens": ["when", "you", "fire", "bufferedimage.getsubimage()", ",", "", "then", "the", "image", "on", "which", "you", "fire", "this", "method", "will", "become", "\"unmanaged\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> bufferedimage.getsubimage() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "bufferedimage.getsubimage()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "bufferedimage.getsubimage()", "label": "API", "asoc": []}]}
{"text": "when you trigger bufferedimage.getsubimage() ,  then the image on which you trigger this method will become \"unmanaged\"", "tokens": ["when", "you", "trigger", "bufferedimage.getsubimage()", ",", "", "then", "the", "image", "on", "which", "you", "trigger", "this", "method", "will", "become", "\"unmanaged\"", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> bufferedimage.getsubimage() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "bufferedimage.getsubimage()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "bufferedimage.getsubimage()", "label": "API", "asoc": []}]}
{"text": "e.g. ,  instead of calling files.newdirectorystream(path) just invoke files.list(path)", "tokens": ["e.g.", ",", "", "instead", "of", "calling", "files.newdirectorystream(path)", "just", "invoke", "files.list(path)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> files.newdirectorystream(path) <extra_id_0> function replace <extra_id_5> files.list(path) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> files.list(path) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "files.newdirectorystream(path)"}, {"type": "API", "offset": [9], "text": "files.list(path)"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [6], "text": "files.newdirectorystream(path)"}, {"type": "API", "offset": [9], "text": "files.list(path)"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "files.newdirectorystream(path)", "label": "API", "asoc": [["function replace", "files.list(path)"]]}, {"span": "files.list(path)", "label": "API", "asoc": []}]}
{"text": "e.g. ,  instead of calling files.newdirectorystream(path) just tell files.list(path)", "tokens": ["e.g.", ",", "", "instead", "of", "calling", "files.newdirectorystream(path)", "just", "tell", "files.list(path)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> files.newdirectorystream(path) <extra_id_0> function replace <extra_id_5> files.list(path) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> files.list(path) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "files.newdirectorystream(path)"}, {"type": "API", "offset": [9], "text": "files.list(path)"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [6], "text": "files.newdirectorystream(path)"}, {"type": "API", "offset": [9], "text": "files.list(path)"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "files.newdirectorystream(path)", "label": "API", "asoc": [["function replace", "files.list(path)"]]}, {"span": "files.list(path)", "label": "API", "asoc": []}]}
{"text": "e.g. ,  instead of calling files.newdirectorystream(path) just indicate files.list(path)", "tokens": ["e.g.", ",", "", "instead", "of", "calling", "files.newdirectorystream(path)", "just", "indicate", "files.list(path)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> files.newdirectorystream(path) <extra_id_0> function replace <extra_id_5> files.list(path) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> files.list(path) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "files.newdirectorystream(path)"}, {"type": "API", "offset": [9], "text": "files.list(path)"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [6], "text": "files.newdirectorystream(path)"}, {"type": "API", "offset": [9], "text": "files.list(path)"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "files.newdirectorystream(path)", "label": "API", "asoc": [["function replace", "files.list(path)"]]}, {"span": "files.list(path)", "label": "API", "asoc": []}]}
{"text": "e.g. ,  instead of calling files.newdirectorystream(path) just occur files.list(path)", "tokens": ["e.g.", ",", "", "instead", "of", "calling", "files.newdirectorystream(path)", "just", "occur", "files.list(path)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> files.newdirectorystream(path) <extra_id_0> function replace <extra_id_5> files.list(path) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> files.list(path) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "files.newdirectorystream(path)"}, {"type": "API", "offset": [9], "text": "files.list(path)"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [6], "text": "files.newdirectorystream(path)"}, {"type": "API", "offset": [9], "text": "files.list(path)"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "files.newdirectorystream(path)", "label": "API", "asoc": [["function replace", "files.list(path)"]]}, {"span": "files.list(path)", "label": "API", "asoc": []}]}
{"text": "e.g. ,  instead of calling files.newdirectorystream(path) just perform files.list(path)", "tokens": ["e.g.", ",", "", "instead", "of", "calling", "files.newdirectorystream(path)", "just", "perform", "files.list(path)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> files.newdirectorystream(path) <extra_id_0> function replace <extra_id_5> files.list(path) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> files.list(path) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "files.newdirectorystream(path)"}, {"type": "API", "offset": [9], "text": "files.list(path)"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [6], "text": "files.newdirectorystream(path)"}, {"type": "API", "offset": [9], "text": "files.list(path)"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "files.newdirectorystream(path)", "label": "API", "asoc": [["function replace", "files.list(path)"]]}, {"span": "files.list(path)", "label": "API", "asoc": []}]}
{"text": "e.g. ,  instead of calling files.newdirectorystream(path) just prompt files.list(path)", "tokens": ["e.g.", ",", "", "instead", "of", "calling", "files.newdirectorystream(path)", "just", "prompt", "files.list(path)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> files.newdirectorystream(path) <extra_id_0> function replace <extra_id_5> files.list(path) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> files.list(path) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "files.newdirectorystream(path)"}, {"type": "API", "offset": [9], "text": "files.list(path)"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [6], "text": "files.newdirectorystream(path)"}, {"type": "API", "offset": [9], "text": "files.list(path)"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "files.newdirectorystream(path)", "label": "API", "asoc": [["function replace", "files.list(path)"]]}, {"span": "files.list(path)", "label": "API", "asoc": []}]}
{"text": "e.g. ,  instead of calling files.newdirectorystream(path) just notify files.list(path)", "tokens": ["e.g.", ",", "", "instead", "of", "calling", "files.newdirectorystream(path)", "just", "notify", "files.list(path)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> files.newdirectorystream(path) <extra_id_0> function replace <extra_id_5> files.list(path) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> files.list(path) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "files.newdirectorystream(path)"}, {"type": "API", "offset": [9], "text": "files.list(path)"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [6], "text": "files.newdirectorystream(path)"}, {"type": "API", "offset": [9], "text": "files.list(path)"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "files.newdirectorystream(path)", "label": "API", "asoc": [["function replace", "files.list(path)"]]}, {"span": "files.list(path)", "label": "API", "asoc": []}]}
{"text": "e.g. ,  instead of calling files.newdirectorystream(path) just execute files.list(path)", "tokens": ["e.g.", ",", "", "instead", "of", "calling", "files.newdirectorystream(path)", "just", "execute", "files.list(path)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> files.newdirectorystream(path) <extra_id_0> function replace <extra_id_5> files.list(path) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> files.list(path) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "files.newdirectorystream(path)"}, {"type": "API", "offset": [9], "text": "files.list(path)"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [6], "text": "files.newdirectorystream(path)"}, {"type": "API", "offset": [9], "text": "files.list(path)"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "files.newdirectorystream(path)", "label": "API", "asoc": [["function replace", "files.list(path)"]]}, {"span": "files.list(path)", "label": "API", "asoc": []}]}
{"text": "e.g. ,  instead of calling files.newdirectorystream(path) just run files.list(path)", "tokens": ["e.g.", ",", "", "instead", "of", "calling", "files.newdirectorystream(path)", "just", "run", "files.list(path)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> files.newdirectorystream(path) <extra_id_0> function replace <extra_id_5> files.list(path) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> files.list(path) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "files.newdirectorystream(path)"}, {"type": "API", "offset": [9], "text": "files.list(path)"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [6], "text": "files.newdirectorystream(path)"}, {"type": "API", "offset": [9], "text": "files.list(path)"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "files.newdirectorystream(path)", "label": "API", "asoc": [["function replace", "files.list(path)"]]}, {"span": "files.list(path)", "label": "API", "asoc": []}]}
{"text": "e.g. ,  instead of calling files.newdirectorystream(path) just enforce files.list(path)", "tokens": ["e.g.", ",", "", "instead", "of", "calling", "files.newdirectorystream(path)", "just", "enforce", "files.list(path)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> files.newdirectorystream(path) <extra_id_0> function replace <extra_id_5> files.list(path) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> files.list(path) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "files.newdirectorystream(path)"}, {"type": "API", "offset": [9], "text": "files.list(path)"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [6], "text": "files.newdirectorystream(path)"}, {"type": "API", "offset": [9], "text": "files.list(path)"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "files.newdirectorystream(path)", "label": "API", "asoc": [["function replace", "files.list(path)"]]}, {"span": "files.list(path)", "label": "API", "asoc": []}]}
{"text": "e.g. ,  instead of calling files.newdirectorystream(path) just fire files.list(path)", "tokens": ["e.g.", ",", "", "instead", "of", "calling", "files.newdirectorystream(path)", "just", "fire", "files.list(path)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> files.newdirectorystream(path) <extra_id_0> function replace <extra_id_5> files.list(path) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> files.list(path) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "files.newdirectorystream(path)"}, {"type": "API", "offset": [9], "text": "files.list(path)"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [6], "text": "files.newdirectorystream(path)"}, {"type": "API", "offset": [9], "text": "files.list(path)"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "files.newdirectorystream(path)", "label": "API", "asoc": [["function replace", "files.list(path)"]]}, {"span": "files.list(path)", "label": "API", "asoc": []}]}
{"text": "e.g. ,  instead of calling files.newdirectorystream(path) just trigger files.list(path)", "tokens": ["e.g.", ",", "", "instead", "of", "calling", "files.newdirectorystream(path)", "just", "trigger", "files.list(path)", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> files.newdirectorystream(path) <extra_id_0> function replace <extra_id_5> files.list(path) <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> files.list(path) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "files.newdirectorystream(path)"}, {"type": "API", "offset": [9], "text": "files.list(path)"}], "relation": [{"type": "function replace", "args": [{"type": "API", "offset": [6], "text": "files.newdirectorystream(path)"}, {"type": "API", "offset": [9], "text": "files.list(path)"}]}], "event": [], "spot": ["API"], "asoc": ["function replace"], "spot_asoc": [{"span": "files.newdirectorystream(path)", "label": "API", "asoc": [["function replace", "files.list(path)"]]}, {"span": "files.list(path)", "label": "API", "asoc": []}]}
{"text": "the solution is to invoke pipedwriter.flush() always after writing something to the pipe", "tokens": ["the", "solution", "is", "to", "invoke", "pipedwriter.flush()", "always", "after", "writing", "something", "to", "the", "pipe", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pipedwriter.flush() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "pipedwriter.flush()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pipedwriter.flush()", "label": "API", "asoc": []}]}
{"text": "the solution is to tell pipedwriter.flush() always after writing something to the pipe", "tokens": ["the", "solution", "is", "to", "tell", "pipedwriter.flush()", "always", "after", "writing", "something", "to", "the", "pipe", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pipedwriter.flush() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "pipedwriter.flush()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pipedwriter.flush()", "label": "API", "asoc": []}]}
{"text": "the solution is to indicate pipedwriter.flush() always after writing something to the pipe", "tokens": ["the", "solution", "is", "to", "indicate", "pipedwriter.flush()", "always", "after", "writing", "something", "to", "the", "pipe", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pipedwriter.flush() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "pipedwriter.flush()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pipedwriter.flush()", "label": "API", "asoc": []}]}
{"text": "the solution is to occur pipedwriter.flush() always after writing something to the pipe", "tokens": ["the", "solution", "is", "to", "occur", "pipedwriter.flush()", "always", "after", "writing", "something", "to", "the", "pipe", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pipedwriter.flush() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "pipedwriter.flush()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pipedwriter.flush()", "label": "API", "asoc": []}]}
{"text": "the solution is to perform pipedwriter.flush() always after writing something to the pipe", "tokens": ["the", "solution", "is", "to", "perform", "pipedwriter.flush()", "always", "after", "writing", "something", "to", "the", "pipe", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pipedwriter.flush() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "pipedwriter.flush()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pipedwriter.flush()", "label": "API", "asoc": []}]}
{"text": "the solution is to prompt pipedwriter.flush() always after writing something to the pipe", "tokens": ["the", "solution", "is", "to", "prompt", "pipedwriter.flush()", "always", "after", "writing", "something", "to", "the", "pipe", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pipedwriter.flush() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "pipedwriter.flush()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pipedwriter.flush()", "label": "API", "asoc": []}]}
{"text": "the solution is to notify pipedwriter.flush() always after writing something to the pipe", "tokens": ["the", "solution", "is", "to", "notify", "pipedwriter.flush()", "always", "after", "writing", "something", "to", "the", "pipe", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pipedwriter.flush() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "pipedwriter.flush()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pipedwriter.flush()", "label": "API", "asoc": []}]}
{"text": "the solution is to execute pipedwriter.flush() always after writing something to the pipe", "tokens": ["the", "solution", "is", "to", "execute", "pipedwriter.flush()", "always", "after", "writing", "something", "to", "the", "pipe", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pipedwriter.flush() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "pipedwriter.flush()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pipedwriter.flush()", "label": "API", "asoc": []}]}
{"text": "the solution is to run pipedwriter.flush() always after writing something to the pipe", "tokens": ["the", "solution", "is", "to", "run", "pipedwriter.flush()", "always", "after", "writing", "something", "to", "the", "pipe", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pipedwriter.flush() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "pipedwriter.flush()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pipedwriter.flush()", "label": "API", "asoc": []}]}
{"text": "the solution is to enforce pipedwriter.flush() always after writing something to the pipe", "tokens": ["the", "solution", "is", "to", "enforce", "pipedwriter.flush()", "always", "after", "writing", "something", "to", "the", "pipe", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pipedwriter.flush() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "pipedwriter.flush()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pipedwriter.flush()", "label": "API", "asoc": []}]}
{"text": "the solution is to fire pipedwriter.flush() always after writing something to the pipe", "tokens": ["the", "solution", "is", "to", "fire", "pipedwriter.flush()", "always", "after", "writing", "something", "to", "the", "pipe", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pipedwriter.flush() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "pipedwriter.flush()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pipedwriter.flush()", "label": "API", "asoc": []}]}
{"text": "the solution is to trigger pipedwriter.flush() always after writing something to the pipe", "tokens": ["the", "solution", "is", "to", "trigger", "pipedwriter.flush()", "always", "after", "writing", "something", "to", "the", "pipe", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> pipedwriter.flush() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [5], "text": "pipedwriter.flush()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "pipedwriter.flush()", "label": "API", "asoc": []}]}
{"text": "available() will always create 0 for sslsocket", "tokens": ["available()", "will", "always", "create", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always build 0 for sslsocket", "tokens": ["available()", "will", "always", "build", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always produce 0 for sslsocket", "tokens": ["available()", "will", "always", "produce", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always construct 0 for sslsocket", "tokens": ["available()", "will", "always", "construct", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always generate 0 for sslsocket", "tokens": ["available()", "will", "always", "generate", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always establish 0 for sslsocket", "tokens": ["available()", "will", "always", "establish", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always make 0 for sslsocket", "tokens": ["available()", "will", "always", "make", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always obtain 0 for sslsocket", "tokens": ["available()", "will", "always", "obtain", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always reconstitute 0 for sslsocket", "tokens": ["available()", "will", "always", "reconstitute", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always compose 0 for sslsocket", "tokens": ["available()", "will", "always", "compose", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always instantiate 0 for sslsocket", "tokens": ["available()", "will", "always", "instantiate", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always implement 0 for sslsocket", "tokens": ["available()", "will", "always", "implement", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always get 0 for sslsocket", "tokens": ["available()", "will", "always", "get", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always retrieve 0 for sslsocket", "tokens": ["available()", "will", "always", "retrieve", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always install 0 for sslsocket", "tokens": ["available()", "will", "always", "install", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always set up 0 for sslsocket", "tokens": ["available()", "will", "always", "set", "up", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always format 0 for sslsocket", "tokens": ["available()", "will", "always", "format", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always convert 0 for sslsocket", "tokens": ["available()", "will", "always", "convert", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always change 0 for sslsocket", "tokens": ["available()", "will", "always", "change", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always transfer 0 for sslsocket", "tokens": ["available()", "will", "always", "transfer", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always map 0 for sslsocket", "tokens": ["available()", "will", "always", "map", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always turn 0 for sslsocket", "tokens": ["available()", "will", "always", "turn", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always transform 0 for sslsocket", "tokens": ["available()", "will", "always", "transform", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always reconvert 0 for sslsocket", "tokens": ["available()", "will", "always", "reconvert", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always move 0 for sslsocket", "tokens": ["available()", "will", "always", "move", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always adapt 0 for sslsocket", "tokens": ["available()", "will", "always", "adapt", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always translate 0 for sslsocket", "tokens": ["available()", "will", "always", "translate", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always force 0 for sslsocket", "tokens": ["available()", "will", "always", "force", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always cast 0 for sslsocket", "tokens": ["available()", "will", "always", "cast", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always compute 0 for sslsocket", "tokens": ["available()", "will", "always", "compute", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always calculate 0 for sslsocket", "tokens": ["available()", "will", "always", "calculate", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always determine 0 for sslsocket", "tokens": ["available()", "will", "always", "determine", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always evaluate 0 for sslsocket", "tokens": ["available()", "will", "always", "evaluate", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always solve 0 for sslsocket", "tokens": ["available()", "will", "always", "solve", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always scale 0 for sslsocket", "tokens": ["available()", "will", "always", "scale", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always measure 0 for sslsocket", "tokens": ["available()", "will", "always", "measure", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always recalculate 0 for sslsocket", "tokens": ["available()", "will", "always", "recalculate", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always multiply 0 for sslsocket", "tokens": ["available()", "will", "always", "multiply", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always count 0 for sslsocket", "tokens": ["available()", "will", "always", "count", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always figure 0 for sslsocket", "tokens": ["available()", "will", "always", "figure", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always subtract 0 for sslsocket", "tokens": ["available()", "will", "always", "subtract", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always increase 0 for sslsocket", "tokens": ["available()", "will", "always", "increase", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always estimate 0 for sslsocket", "tokens": ["available()", "will", "always", "estimate", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always increment 0 for sslsocket", "tokens": ["available()", "will", "always", "increment", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always test 0 for sslsocket", "tokens": ["available()", "will", "always", "test", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always tell 0 for sslsocket", "tokens": ["available()", "will", "always", "tell", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always check 0 for sslsocket", "tokens": ["available()", "will", "always", "check", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always ascertain 0 for sslsocket", "tokens": ["available()", "will", "always", "ascertain", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always control 0 for sslsocket", "tokens": ["available()", "will", "always", "control", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always indicate 0 for sslsocket", "tokens": ["available()", "will", "always", "indicate", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always query 0 for sslsocket", "tokens": ["available()", "will", "always", "query", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always report 0 for sslsocket", "tokens": ["available()", "will", "always", "report", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always validate 0 for sslsocket", "tokens": ["available()", "will", "always", "validate", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always invalidate 0 for sslsocket", "tokens": ["available()", "will", "always", "invalidate", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always verify 0 for sslsocket", "tokens": ["available()", "will", "always", "verify", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always find 0 for sslsocket", "tokens": ["available()", "will", "always", "find", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always identify 0 for sslsocket", "tokens": ["available()", "will", "always", "identify", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always track 0 for sslsocket", "tokens": ["available()", "will", "always", "track", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always detect 0 for sslsocket", "tokens": ["available()", "will", "always", "detect", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always decide 0 for sslsocket", "tokens": ["available()", "will", "always", "decide", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "available() will always compare 0 for sslsocket", "tokens": ["available()", "will", "always", "compare", "0", "for", "sslsocket", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> available() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [0], "text": "available()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "available()", "label": "API", "asoc": []}]}
{"text": "you only have one image in your relation per parseobject in your \"notica\" class as you invoke getfirst()", "tokens": ["you", "only", "have", "one", "image", "in", "your", "relation", "per", "parseobject", "in", "your", "\"notica\"", "class", "as", "you", "invoke", "getfirst()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getfirst() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "getfirst()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getfirst()", "label": "API", "asoc": []}]}
{"text": "you only have one image in your relation per parseobject in your \"notica\" class as you tell getfirst()", "tokens": ["you", "only", "have", "one", "image", "in", "your", "relation", "per", "parseobject", "in", "your", "\"notica\"", "class", "as", "you", "tell", "getfirst()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getfirst() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "getfirst()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getfirst()", "label": "API", "asoc": []}]}
{"text": "you only have one image in your relation per parseobject in your \"notica\" class as you indicate getfirst()", "tokens": ["you", "only", "have", "one", "image", "in", "your", "relation", "per", "parseobject", "in", "your", "\"notica\"", "class", "as", "you", "indicate", "getfirst()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getfirst() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "getfirst()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getfirst()", "label": "API", "asoc": []}]}
{"text": "you only have one image in your relation per parseobject in your \"notica\" class as you occur getfirst()", "tokens": ["you", "only", "have", "one", "image", "in", "your", "relation", "per", "parseobject", "in", "your", "\"notica\"", "class", "as", "you", "occur", "getfirst()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getfirst() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "getfirst()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getfirst()", "label": "API", "asoc": []}]}
{"text": "you only have one image in your relation per parseobject in your \"notica\" class as you perform getfirst()", "tokens": ["you", "only", "have", "one", "image", "in", "your", "relation", "per", "parseobject", "in", "your", "\"notica\"", "class", "as", "you", "perform", "getfirst()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getfirst() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "getfirst()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getfirst()", "label": "API", "asoc": []}]}
{"text": "you only have one image in your relation per parseobject in your \"notica\" class as you prompt getfirst()", "tokens": ["you", "only", "have", "one", "image", "in", "your", "relation", "per", "parseobject", "in", "your", "\"notica\"", "class", "as", "you", "prompt", "getfirst()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getfirst() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "getfirst()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getfirst()", "label": "API", "asoc": []}]}
{"text": "you only have one image in your relation per parseobject in your \"notica\" class as you notify getfirst()", "tokens": ["you", "only", "have", "one", "image", "in", "your", "relation", "per", "parseobject", "in", "your", "\"notica\"", "class", "as", "you", "notify", "getfirst()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getfirst() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "getfirst()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getfirst()", "label": "API", "asoc": []}]}
{"text": "you only have one image in your relation per parseobject in your \"notica\" class as you execute getfirst()", "tokens": ["you", "only", "have", "one", "image", "in", "your", "relation", "per", "parseobject", "in", "your", "\"notica\"", "class", "as", "you", "execute", "getfirst()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getfirst() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "getfirst()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getfirst()", "label": "API", "asoc": []}]}
{"text": "you only have one image in your relation per parseobject in your \"notica\" class as you run getfirst()", "tokens": ["you", "only", "have", "one", "image", "in", "your", "relation", "per", "parseobject", "in", "your", "\"notica\"", "class", "as", "you", "run", "getfirst()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getfirst() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "getfirst()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getfirst()", "label": "API", "asoc": []}]}
{"text": "you only have one image in your relation per parseobject in your \"notica\" class as you enforce getfirst()", "tokens": ["you", "only", "have", "one", "image", "in", "your", "relation", "per", "parseobject", "in", "your", "\"notica\"", "class", "as", "you", "enforce", "getfirst()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getfirst() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "getfirst()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getfirst()", "label": "API", "asoc": []}]}
{"text": "you only have one image in your relation per parseobject in your \"notica\" class as you fire getfirst()", "tokens": ["you", "only", "have", "one", "image", "in", "your", "relation", "per", "parseobject", "in", "your", "\"notica\"", "class", "as", "you", "fire", "getfirst()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getfirst() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "getfirst()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getfirst()", "label": "API", "asoc": []}]}
{"text": "you only have one image in your relation per parseobject in your \"notica\" class as you trigger getfirst()", "tokens": ["you", "only", "have", "one", "image", "in", "your", "relation", "per", "parseobject", "in", "your", "\"notica\"", "class", "as", "you", "trigger", "getfirst()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getfirst() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [17], "text": "getfirst()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getfirst()", "label": "API", "asoc": []}]}
{"text": "code example on how to store values()", "tokens": ["code", "example", "on", "how", "to", "store", "values()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> values() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "values()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "values()", "label": "API", "asoc": []}]}
{"text": "code example on how to save values()", "tokens": ["code", "example", "on", "how", "to", "save", "values()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> values() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "values()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "values()", "label": "API", "asoc": []}]}
{"text": "code example on how to dump values()", "tokens": ["code", "example", "on", "how", "to", "dump", "values()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> values() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "values()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "values()", "label": "API", "asoc": []}]}
{"text": "code example on how to retain values()", "tokens": ["code", "example", "on", "how", "to", "retain", "values()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> values() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "values()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "values()", "label": "API", "asoc": []}]}
{"text": "code example on how to stash values()", "tokens": ["code", "example", "on", "how", "to", "stash", "values()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> values() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "values()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "values()", "label": "API", "asoc": []}]}
{"text": "code example on how to serialize values()", "tokens": ["code", "example", "on", "how", "to", "serialize", "values()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> values() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "values()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "values()", "label": "API", "asoc": []}]}
{"text": "code example on how to deserialize values()", "tokens": ["code", "example", "on", "how", "to", "deserialize", "values()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> values() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "values()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "values()", "label": "API", "asoc": []}]}
{"text": "code example on how to persist values()", "tokens": ["code", "example", "on", "how", "to", "persist", "values()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> values() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [6], "text": "values()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "values()", "label": "API", "asoc": []}]}
{"text": "you can invoke thread.getstate() on and check if the state is timed_waiting", "tokens": ["you", "can", "invoke", "thread.getstate()", "on", "and", "check", "if", "the", "state", "is", "timed_waiting", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.getstate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "thread.getstate()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.getstate()", "label": "API", "asoc": []}]}
{"text": "you can tell thread.getstate() on and check if the state is timed_waiting", "tokens": ["you", "can", "tell", "thread.getstate()", "on", "and", "check", "if", "the", "state", "is", "timed_waiting", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.getstate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "thread.getstate()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.getstate()", "label": "API", "asoc": []}]}
{"text": "you can indicate thread.getstate() on and check if the state is timed_waiting", "tokens": ["you", "can", "indicate", "thread.getstate()", "on", "and", "check", "if", "the", "state", "is", "timed_waiting", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.getstate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "thread.getstate()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.getstate()", "label": "API", "asoc": []}]}
{"text": "you can occur thread.getstate() on and check if the state is timed_waiting", "tokens": ["you", "can", "occur", "thread.getstate()", "on", "and", "check", "if", "the", "state", "is", "timed_waiting", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.getstate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "thread.getstate()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.getstate()", "label": "API", "asoc": []}]}
{"text": "you can perform thread.getstate() on and check if the state is timed_waiting", "tokens": ["you", "can", "perform", "thread.getstate()", "on", "and", "check", "if", "the", "state", "is", "timed_waiting", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.getstate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "thread.getstate()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.getstate()", "label": "API", "asoc": []}]}
{"text": "you can prompt thread.getstate() on and check if the state is timed_waiting", "tokens": ["you", "can", "prompt", "thread.getstate()", "on", "and", "check", "if", "the", "state", "is", "timed_waiting", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.getstate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "thread.getstate()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.getstate()", "label": "API", "asoc": []}]}
{"text": "you can notify thread.getstate() on and check if the state is timed_waiting", "tokens": ["you", "can", "notify", "thread.getstate()", "on", "and", "check", "if", "the", "state", "is", "timed_waiting", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.getstate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "thread.getstate()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.getstate()", "label": "API", "asoc": []}]}
{"text": "you can execute thread.getstate() on and check if the state is timed_waiting", "tokens": ["you", "can", "execute", "thread.getstate()", "on", "and", "check", "if", "the", "state", "is", "timed_waiting", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.getstate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "thread.getstate()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.getstate()", "label": "API", "asoc": []}]}
{"text": "you can run thread.getstate() on and check if the state is timed_waiting", "tokens": ["you", "can", "run", "thread.getstate()", "on", "and", "check", "if", "the", "state", "is", "timed_waiting", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.getstate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "thread.getstate()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.getstate()", "label": "API", "asoc": []}]}
{"text": "you can enforce thread.getstate() on and check if the state is timed_waiting", "tokens": ["you", "can", "enforce", "thread.getstate()", "on", "and", "check", "if", "the", "state", "is", "timed_waiting", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.getstate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "thread.getstate()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.getstate()", "label": "API", "asoc": []}]}
{"text": "you can fire thread.getstate() on and check if the state is timed_waiting", "tokens": ["you", "can", "fire", "thread.getstate()", "on", "and", "check", "if", "the", "state", "is", "timed_waiting", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.getstate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "thread.getstate()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.getstate()", "label": "API", "asoc": []}]}
{"text": "you can trigger thread.getstate() on and check if the state is timed_waiting", "tokens": ["you", "can", "trigger", "thread.getstate()", "on", "and", "check", "if", "the", "state", "is", "timed_waiting", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.getstate() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [3], "text": "thread.getstate()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.getstate()", "label": "API", "asoc": []}]}
{"text": "before attempting to write to a file ,  you can test if the file is writable by your java application using file.canwrite()", "tokens": ["before", "attempting", "to", "write", "to", "a", "file", ",", "", "you", "can", "test", "if", "the", "file", "is", "writable", "by", "your", "java", "application", "using", "file.canwrite()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.canwrite() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "file.canwrite()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.canwrite()", "label": "API", "asoc": []}]}
{"text": "before attempting to write to a file ,  you can tell if the file is writable by your java application using file.canwrite()", "tokens": ["before", "attempting", "to", "write", "to", "a", "file", ",", "", "you", "can", "tell", "if", "the", "file", "is", "writable", "by", "your", "java", "application", "using", "file.canwrite()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.canwrite() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "file.canwrite()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.canwrite()", "label": "API", "asoc": []}]}
{"text": "before attempting to write to a file ,  you can determine if the file is writable by your java application using file.canwrite()", "tokens": ["before", "attempting", "to", "write", "to", "a", "file", ",", "", "you", "can", "determine", "if", "the", "file", "is", "writable", "by", "your", "java", "application", "using", "file.canwrite()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.canwrite() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "file.canwrite()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.canwrite()", "label": "API", "asoc": []}]}
{"text": "before attempting to write to a file ,  you can retrieve if the file is writable by your java application using file.canwrite()", "tokens": ["before", "attempting", "to", "write", "to", "a", "file", ",", "", "you", "can", "retrieve", "if", "the", "file", "is", "writable", "by", "your", "java", "application", "using", "file.canwrite()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.canwrite() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "file.canwrite()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.canwrite()", "label": "API", "asoc": []}]}
{"text": "before attempting to write to a file ,  you can ascertain if the file is writable by your java application using file.canwrite()", "tokens": ["before", "attempting", "to", "write", "to", "a", "file", ",", "", "you", "can", "ascertain", "if", "the", "file", "is", "writable", "by", "your", "java", "application", "using", "file.canwrite()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.canwrite() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "file.canwrite()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.canwrite()", "label": "API", "asoc": []}]}
{"text": "before attempting to write to a file ,  you can return if the file is writable by your java application using file.canwrite()", "tokens": ["before", "attempting", "to", "write", "to", "a", "file", ",", "", "you", "can", "return", "if", "the", "file", "is", "writable", "by", "your", "java", "application", "using", "file.canwrite()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.canwrite() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "file.canwrite()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.canwrite()", "label": "API", "asoc": []}]}
{"text": "before attempting to write to a file ,  you can control if the file is writable by your java application using file.canwrite()", "tokens": ["before", "attempting", "to", "write", "to", "a", "file", ",", "", "you", "can", "control", "if", "the", "file", "is", "writable", "by", "your", "java", "application", "using", "file.canwrite()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.canwrite() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "file.canwrite()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.canwrite()", "label": "API", "asoc": []}]}
{"text": "before attempting to write to a file ,  you can indicate if the file is writable by your java application using file.canwrite()", "tokens": ["before", "attempting", "to", "write", "to", "a", "file", ",", "", "you", "can", "indicate", "if", "the", "file", "is", "writable", "by", "your", "java", "application", "using", "file.canwrite()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.canwrite() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "file.canwrite()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.canwrite()", "label": "API", "asoc": []}]}
{"text": "before attempting to write to a file ,  you can query if the file is writable by your java application using file.canwrite()", "tokens": ["before", "attempting", "to", "write", "to", "a", "file", ",", "", "you", "can", "query", "if", "the", "file", "is", "writable", "by", "your", "java", "application", "using", "file.canwrite()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.canwrite() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "file.canwrite()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.canwrite()", "label": "API", "asoc": []}]}
{"text": "before attempting to write to a file ,  you can report if the file is writable by your java application using file.canwrite()", "tokens": ["before", "attempting", "to", "write", "to", "a", "file", ",", "", "you", "can", "report", "if", "the", "file", "is", "writable", "by", "your", "java", "application", "using", "file.canwrite()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.canwrite() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "file.canwrite()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.canwrite()", "label": "API", "asoc": []}]}
{"text": "before attempting to write to a file ,  you can validate if the file is writable by your java application using file.canwrite()", "tokens": ["before", "attempting", "to", "write", "to", "a", "file", ",", "", "you", "can", "validate", "if", "the", "file", "is", "writable", "by", "your", "java", "application", "using", "file.canwrite()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.canwrite() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "file.canwrite()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.canwrite()", "label": "API", "asoc": []}]}
{"text": "before attempting to write to a file ,  you can get if the file is writable by your java application using file.canwrite()", "tokens": ["before", "attempting", "to", "write", "to", "a", "file", ",", "", "you", "can", "get", "if", "the", "file", "is", "writable", "by", "your", "java", "application", "using", "file.canwrite()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.canwrite() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "file.canwrite()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.canwrite()", "label": "API", "asoc": []}]}
{"text": "before attempting to write to a file ,  you can invalidate if the file is writable by your java application using file.canwrite()", "tokens": ["before", "attempting", "to", "write", "to", "a", "file", ",", "", "you", "can", "invalidate", "if", "the", "file", "is", "writable", "by", "your", "java", "application", "using", "file.canwrite()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.canwrite() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "file.canwrite()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.canwrite()", "label": "API", "asoc": []}]}
{"text": "before attempting to write to a file ,  you can verify if the file is writable by your java application using file.canwrite()", "tokens": ["before", "attempting", "to", "write", "to", "a", "file", ",", "", "you", "can", "verify", "if", "the", "file", "is", "writable", "by", "your", "java", "application", "using", "file.canwrite()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.canwrite() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "file.canwrite()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.canwrite()", "label": "API", "asoc": []}]}
{"text": "before attempting to write to a file ,  you can find if the file is writable by your java application using file.canwrite()", "tokens": ["before", "attempting", "to", "write", "to", "a", "file", ",", "", "you", "can", "find", "if", "the", "file", "is", "writable", "by", "your", "java", "application", "using", "file.canwrite()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.canwrite() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "file.canwrite()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.canwrite()", "label": "API", "asoc": []}]}
{"text": "before attempting to write to a file ,  you can identify if the file is writable by your java application using file.canwrite()", "tokens": ["before", "attempting", "to", "write", "to", "a", "file", ",", "", "you", "can", "identify", "if", "the", "file", "is", "writable", "by", "your", "java", "application", "using", "file.canwrite()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.canwrite() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "file.canwrite()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.canwrite()", "label": "API", "asoc": []}]}
{"text": "before attempting to write to a file ,  you can track if the file is writable by your java application using file.canwrite()", "tokens": ["before", "attempting", "to", "write", "to", "a", "file", ",", "", "you", "can", "track", "if", "the", "file", "is", "writable", "by", "your", "java", "application", "using", "file.canwrite()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.canwrite() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "file.canwrite()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.canwrite()", "label": "API", "asoc": []}]}
{"text": "before attempting to write to a file ,  you can detect if the file is writable by your java application using file.canwrite()", "tokens": ["before", "attempting", "to", "write", "to", "a", "file", ",", "", "you", "can", "detect", "if", "the", "file", "is", "writable", "by", "your", "java", "application", "using", "file.canwrite()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.canwrite() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "file.canwrite()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.canwrite()", "label": "API", "asoc": []}]}
{"text": "before attempting to write to a file ,  you can decide if the file is writable by your java application using file.canwrite()", "tokens": ["before", "attempting", "to", "write", "to", "a", "file", ",", "", "you", "can", "decide", "if", "the", "file", "is", "writable", "by", "your", "java", "application", "using", "file.canwrite()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.canwrite() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [22], "text": "file.canwrite()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.canwrite()", "label": "API", "asoc": []}]}
{"text": "if you choose to sort the array programmatically at run time ,  make sure you use the appropriate (sorted) index when sort getstring() etc", "tokens": ["if", "you", "choose", "to", "sort", "the", "array", "programmatically", "at", "run", "time", ",", "", "make", "sure", "you", "use", "the", "appropriate", "(sorted)", "index", "when", "sort", "getstring()", "etc", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> getstring() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [23], "text": "getstring()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "getstring()", "label": "API", "asoc": []}]}
{"text": "invoke next() to advance to the first item first ,  then invoke remove() .", "tokens": ["invoke", "next()", "to", "advance", "to", "the", "first", "item", "first", ",", "", "then", "invoke", "remove()", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_0> logic constraint <extra_id_5> remove() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "next()"}, {"type": "API", "offset": [13], "text": "remove()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [1], "text": "next()"}, {"type": "API", "offset": [13], "text": "remove()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "next()", "label": "API", "asoc": [["logic constraint", "remove()"]]}, {"span": "remove()", "label": "API", "asoc": []}]}
{"text": "tell next() to advance to the first item first ,  then tell remove() .", "tokens": ["tell", "next()", "to", "advance", "to", "the", "first", "item", "first", ",", "", "then", "tell", "remove()", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_0> logic constraint <extra_id_5> remove() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "next()"}, {"type": "API", "offset": [13], "text": "remove()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [1], "text": "next()"}, {"type": "API", "offset": [13], "text": "remove()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "next()", "label": "API", "asoc": [["logic constraint", "remove()"]]}, {"span": "remove()", "label": "API", "asoc": []}]}
{"text": "indicate next() to advance to the first item first ,  then indicate remove() .", "tokens": ["indicate", "next()", "to", "advance", "to", "the", "first", "item", "first", ",", "", "then", "indicate", "remove()", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_0> logic constraint <extra_id_5> remove() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "next()"}, {"type": "API", "offset": [13], "text": "remove()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [1], "text": "next()"}, {"type": "API", "offset": [13], "text": "remove()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "next()", "label": "API", "asoc": [["logic constraint", "remove()"]]}, {"span": "remove()", "label": "API", "asoc": []}]}
{"text": "occur next() to advance to the first item first ,  then occur remove() .", "tokens": ["occur", "next()", "to", "advance", "to", "the", "first", "item", "first", ",", "", "then", "occur", "remove()", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_0> logic constraint <extra_id_5> remove() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "next()"}, {"type": "API", "offset": [13], "text": "remove()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [1], "text": "next()"}, {"type": "API", "offset": [13], "text": "remove()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "next()", "label": "API", "asoc": [["logic constraint", "remove()"]]}, {"span": "remove()", "label": "API", "asoc": []}]}
{"text": "perform next() to advance to the first item first ,  then perform remove() .", "tokens": ["perform", "next()", "to", "advance", "to", "the", "first", "item", "first", ",", "", "then", "perform", "remove()", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_0> logic constraint <extra_id_5> remove() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "next()"}, {"type": "API", "offset": [13], "text": "remove()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [1], "text": "next()"}, {"type": "API", "offset": [13], "text": "remove()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "next()", "label": "API", "asoc": [["logic constraint", "remove()"]]}, {"span": "remove()", "label": "API", "asoc": []}]}
{"text": "prompt next() to advance to the first item first ,  then prompt remove() .", "tokens": ["prompt", "next()", "to", "advance", "to", "the", "first", "item", "first", ",", "", "then", "prompt", "remove()", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_0> logic constraint <extra_id_5> remove() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "next()"}, {"type": "API", "offset": [13], "text": "remove()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [1], "text": "next()"}, {"type": "API", "offset": [13], "text": "remove()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "next()", "label": "API", "asoc": [["logic constraint", "remove()"]]}, {"span": "remove()", "label": "API", "asoc": []}]}
{"text": "notify next() to advance to the first item first ,  then notify remove() .", "tokens": ["notify", "next()", "to", "advance", "to", "the", "first", "item", "first", ",", "", "then", "notify", "remove()", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_0> logic constraint <extra_id_5> remove() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "next()"}, {"type": "API", "offset": [13], "text": "remove()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [1], "text": "next()"}, {"type": "API", "offset": [13], "text": "remove()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "next()", "label": "API", "asoc": [["logic constraint", "remove()"]]}, {"span": "remove()", "label": "API", "asoc": []}]}
{"text": "execute next() to advance to the first item first ,  then execute remove() .", "tokens": ["execute", "next()", "to", "advance", "to", "the", "first", "item", "first", ",", "", "then", "execute", "remove()", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_0> logic constraint <extra_id_5> remove() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "next()"}, {"type": "API", "offset": [13], "text": "remove()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [1], "text": "next()"}, {"type": "API", "offset": [13], "text": "remove()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "next()", "label": "API", "asoc": [["logic constraint", "remove()"]]}, {"span": "remove()", "label": "API", "asoc": []}]}
{"text": "run next() to advance to the first item first ,  then run remove() .", "tokens": ["run", "next()", "to", "advance", "to", "the", "first", "item", "first", ",", "", "then", "run", "remove()", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_0> logic constraint <extra_id_5> remove() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "next()"}, {"type": "API", "offset": [13], "text": "remove()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [1], "text": "next()"}, {"type": "API", "offset": [13], "text": "remove()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "next()", "label": "API", "asoc": [["logic constraint", "remove()"]]}, {"span": "remove()", "label": "API", "asoc": []}]}
{"text": "enforce next() to advance to the first item first ,  then enforce remove() .", "tokens": ["enforce", "next()", "to", "advance", "to", "the", "first", "item", "first", ",", "", "then", "enforce", "remove()", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_0> logic constraint <extra_id_5> remove() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "next()"}, {"type": "API", "offset": [13], "text": "remove()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [1], "text": "next()"}, {"type": "API", "offset": [13], "text": "remove()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "next()", "label": "API", "asoc": [["logic constraint", "remove()"]]}, {"span": "remove()", "label": "API", "asoc": []}]}
{"text": "fire next() to advance to the first item first ,  then fire remove() .", "tokens": ["fire", "next()", "to", "advance", "to", "the", "first", "item", "first", ",", "", "then", "fire", "remove()", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_0> logic constraint <extra_id_5> remove() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "next()"}, {"type": "API", "offset": [13], "text": "remove()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [1], "text": "next()"}, {"type": "API", "offset": [13], "text": "remove()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "next()", "label": "API", "asoc": [["logic constraint", "remove()"]]}, {"span": "remove()", "label": "API", "asoc": []}]}
{"text": "trigger next() to advance to the first item first ,  then trigger remove() .", "tokens": ["trigger", "next()", "to", "advance", "to", "the", "first", "item", "first", ",", "", "then", "trigger", "remove()", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> next() <extra_id_0> logic constraint <extra_id_5> remove() <extra_id_1> <extra_id_1> <extra_id_0> API <extra_id_5> remove() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [1], "text": "next()"}, {"type": "API", "offset": [13], "text": "remove()"}], "relation": [{"type": "logic constraint", "args": [{"type": "API", "offset": [1], "text": "next()"}, {"type": "API", "offset": [13], "text": "remove()"}]}], "event": [], "spot": ["API"], "asoc": ["logic constraint"], "spot_asoc": [{"span": "next()", "label": "API", "asoc": [["logic constraint", "remove()"]]}, {"span": "remove()", "label": "API", "asoc": []}]}
{"text": "one way is to automatically add logging to all places which invoke thread.sleep using a java agent", "tokens": ["one", "way", "is", "to", "automatically", "add", "logging", "to", "all", "places", "which", "invoke", "thread.sleep", "using", "a", "java", "agent", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "thread.sleep"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep", "label": "API", "asoc": []}]}
{"text": "one way is to automatically add logging to all places which tell thread.sleep using a java agent", "tokens": ["one", "way", "is", "to", "automatically", "add", "logging", "to", "all", "places", "which", "tell", "thread.sleep", "using", "a", "java", "agent", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "thread.sleep"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep", "label": "API", "asoc": []}]}
{"text": "one way is to automatically add logging to all places which indicate thread.sleep using a java agent", "tokens": ["one", "way", "is", "to", "automatically", "add", "logging", "to", "all", "places", "which", "indicate", "thread.sleep", "using", "a", "java", "agent", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "thread.sleep"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep", "label": "API", "asoc": []}]}
{"text": "one way is to automatically add logging to all places which occur thread.sleep using a java agent", "tokens": ["one", "way", "is", "to", "automatically", "add", "logging", "to", "all", "places", "which", "occur", "thread.sleep", "using", "a", "java", "agent", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "thread.sleep"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep", "label": "API", "asoc": []}]}
{"text": "one way is to automatically add logging to all places which perform thread.sleep using a java agent", "tokens": ["one", "way", "is", "to", "automatically", "add", "logging", "to", "all", "places", "which", "perform", "thread.sleep", "using", "a", "java", "agent", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "thread.sleep"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep", "label": "API", "asoc": []}]}
{"text": "one way is to automatically add logging to all places which prompt thread.sleep using a java agent", "tokens": ["one", "way", "is", "to", "automatically", "add", "logging", "to", "all", "places", "which", "prompt", "thread.sleep", "using", "a", "java", "agent", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "thread.sleep"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep", "label": "API", "asoc": []}]}
{"text": "one way is to automatically add logging to all places which notify thread.sleep using a java agent", "tokens": ["one", "way", "is", "to", "automatically", "add", "logging", "to", "all", "places", "which", "notify", "thread.sleep", "using", "a", "java", "agent", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "thread.sleep"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep", "label": "API", "asoc": []}]}
{"text": "one way is to automatically add logging to all places which execute thread.sleep using a java agent", "tokens": ["one", "way", "is", "to", "automatically", "add", "logging", "to", "all", "places", "which", "execute", "thread.sleep", "using", "a", "java", "agent", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "thread.sleep"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep", "label": "API", "asoc": []}]}
{"text": "one way is to automatically add logging to all places which run thread.sleep using a java agent", "tokens": ["one", "way", "is", "to", "automatically", "add", "logging", "to", "all", "places", "which", "run", "thread.sleep", "using", "a", "java", "agent", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "thread.sleep"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep", "label": "API", "asoc": []}]}
{"text": "one way is to automatically add logging to all places which enforce thread.sleep using a java agent", "tokens": ["one", "way", "is", "to", "automatically", "add", "logging", "to", "all", "places", "which", "enforce", "thread.sleep", "using", "a", "java", "agent", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "thread.sleep"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep", "label": "API", "asoc": []}]}
{"text": "one way is to automatically add logging to all places which fire thread.sleep using a java agent", "tokens": ["one", "way", "is", "to", "automatically", "add", "logging", "to", "all", "places", "which", "fire", "thread.sleep", "using", "a", "java", "agent", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "thread.sleep"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep", "label": "API", "asoc": []}]}
{"text": "one way is to automatically add logging to all places which trigger thread.sleep using a java agent", "tokens": ["one", "way", "is", "to", "automatically", "add", "logging", "to", "all", "places", "which", "trigger", "thread.sleep", "using", "a", "java", "agent", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> thread.sleep <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [12], "text": "thread.sleep"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "thread.sleep", "label": "API", "asoc": []}]}
{"text": "step3: visit the list ,  write a conditions with a use the file.getname() method to compare and the name and your input .", "tokens": ["step3:", "visit", "the", "list", ",", "", "write", "a", "conditions", "with", "a", "use", "the", "file.getname()", "method", "to", "compare", "and", "the", "name", "and", "your", "input", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.getname() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "file.getname()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.getname()", "label": "API", "asoc": []}]}
{"text": "step3: rescan the list ,  write a conditions with a use the file.getname() method to compare and the name and your input .", "tokens": ["step3:", "rescan", "the", "list", ",", "", "write", "a", "conditions", "with", "a", "use", "the", "file.getname()", "method", "to", "compare", "and", "the", "name", "and", "your", "input", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.getname() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "file.getname()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.getname()", "label": "API", "asoc": []}]}
{"text": "step3: scan the list ,  write a conditions with a use the file.getname() method to compare and the name and your input .", "tokens": ["step3:", "scan", "the", "list", ",", "", "write", "a", "conditions", "with", "a", "use", "the", "file.getname()", "method", "to", "compare", "and", "the", "name", "and", "your", "input", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.getname() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "file.getname()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.getname()", "label": "API", "asoc": []}]}
{"text": "step3: walk the list ,  write a conditions with a use the file.getname() method to compare and the name and your input .", "tokens": ["step3:", "walk", "the", "list", ",", "", "write", "a", "conditions", "with", "a", "use", "the", "file.getname()", "method", "to", "compare", "and", "the", "name", "and", "your", "input", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.getname() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "file.getname()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.getname()", "label": "API", "asoc": []}]}
{"text": "step3: access the list ,  write a conditions with a use the file.getname() method to compare and the name and your input .", "tokens": ["step3:", "access", "the", "list", ",", "", "write", "a", "conditions", "with", "a", "use", "the", "file.getname()", "method", "to", "compare", "and", "the", "name", "and", "your", "input", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> file.getname() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "file.getname()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "file.getname()", "label": "API", "asoc": []}]}
{"text": "you'll need to open a file for writing ,  and open the filewriter to it ,  along with the document node .", "tokens": ["you'll", "need", "to", "open", "a", "file", "for", "writing", ",", "", "and", "open", "the", "filewriter", "to", "it", ",", "", "along", "with", "the", "document", "node", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> filewriter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "filewriter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "filewriter", "label": "API", "asoc": []}]}
{"text": "you'll need to open a file for writing ,  and turn on the filewriter to it ,  along with the document node .", "tokens": ["you'll", "need", "to", "open", "a", "file", "for", "writing", ",", "", "and", "turn", "on", "the", "filewriter", "to", "it", ",", "", "along", "with", "the", "document", "node", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> filewriter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [14], "text": "filewriter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "filewriter", "label": "API", "asoc": []}]}
{"text": "you'll need to open a file for writing ,  and send the filewriter to it ,  along with the document node .", "tokens": ["you'll", "need", "to", "open", "a", "file", "for", "writing", ",", "", "and", "send", "the", "filewriter", "to", "it", ",", "", "along", "with", "the", "document", "node", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> filewriter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "filewriter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "filewriter", "label": "API", "asoc": []}]}
{"text": "you'll need to open a file for writing ,  and give the filewriter to it ,  along with the document node .", "tokens": ["you'll", "need", "to", "open", "a", "file", "for", "writing", ",", "", "and", "give", "the", "filewriter", "to", "it", ",", "", "along", "with", "the", "document", "node", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> filewriter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "filewriter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "filewriter", "label": "API", "asoc": []}]}
{"text": "you'll need to open a file for writing ,  and dispatch the filewriter to it ,  along with the document node .", "tokens": ["you'll", "need", "to", "open", "a", "file", "for", "writing", ",", "", "and", "dispatch", "the", "filewriter", "to", "it", ",", "", "along", "with", "the", "document", "node", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> filewriter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "filewriter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "filewriter", "label": "API", "asoc": []}]}
{"text": "you'll need to open a file for writing ,  and post the filewriter to it ,  along with the document node .", "tokens": ["you'll", "need", "to", "open", "a", "file", "for", "writing", ",", "", "and", "post", "the", "filewriter", "to", "it", ",", "", "along", "with", "the", "document", "node", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> filewriter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "filewriter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "filewriter", "label": "API", "asoc": []}]}
{"text": "you'll need to open a file for writing ,  and issue the filewriter to it ,  along with the document node .", "tokens": ["you'll", "need", "to", "open", "a", "file", "for", "writing", ",", "", "and", "issue", "the", "filewriter", "to", "it", ",", "", "along", "with", "the", "document", "node", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> filewriter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "filewriter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "filewriter", "label": "API", "asoc": []}]}
{"text": "you'll need to open a file for writing ,  and propagate the filewriter to it ,  along with the document node .", "tokens": ["you'll", "need", "to", "open", "a", "file", "for", "writing", ",", "", "and", "propagate", "the", "filewriter", "to", "it", ",", "", "along", "with", "the", "document", "node", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> filewriter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "filewriter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "filewriter", "label": "API", "asoc": []}]}
{"text": "you'll need to open a file for writing ,  and forward the filewriter to it ,  along with the document node .", "tokens": ["you'll", "need", "to", "open", "a", "file", "for", "writing", ",", "", "and", "forward", "the", "filewriter", "to", "it", ",", "", "along", "with", "the", "document", "node", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> filewriter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "filewriter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "filewriter", "label": "API", "asoc": []}]}
{"text": "you'll need to open a file for writing ,  and broadcast the filewriter to it ,  along with the document node .", "tokens": ["you'll", "need", "to", "open", "a", "file", "for", "writing", ",", "", "and", "broadcast", "the", "filewriter", "to", "it", ",", "", "along", "with", "the", "document", "node", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> filewriter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "filewriter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "filewriter", "label": "API", "asoc": []}]}
{"text": "you'll need to open a file for writing ,  and transmit the filewriter to it ,  along with the document node .", "tokens": ["you'll", "need", "to", "open", "a", "file", "for", "writing", ",", "", "and", "transmit", "the", "filewriter", "to", "it", ",", "", "along", "with", "the", "document", "node", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> filewriter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "filewriter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "filewriter", "label": "API", "asoc": []}]}
{"text": "you'll need to open a file for writing ,  and emit the filewriter to it ,  along with the document node .", "tokens": ["you'll", "need", "to", "open", "a", "file", "for", "writing", ",", "", "and", "emit", "the", "filewriter", "to", "it", ",", "", "along", "with", "the", "document", "node", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> filewriter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "filewriter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "filewriter", "label": "API", "asoc": []}]}
{"text": "you'll need to open a file for writing ,  and notify the filewriter to it ,  along with the document node .", "tokens": ["you'll", "need", "to", "open", "a", "file", "for", "writing", ",", "", "and", "notify", "the", "filewriter", "to", "it", ",", "", "along", "with", "the", "document", "node", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> filewriter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "filewriter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "filewriter", "label": "API", "asoc": []}]}
{"text": "you'll need to open a file for writing ,  and signal the filewriter to it ,  along with the document node .", "tokens": ["you'll", "need", "to", "open", "a", "file", "for", "writing", ",", "", "and", "signal", "the", "filewriter", "to", "it", ",", "", "along", "with", "the", "document", "node", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> filewriter <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "filewriter"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "filewriter", "label": "API", "asoc": []}]}
{"text": "how to ensure that my tasks are responsive to interruption when i call future.cancel() ?  call future.cancel(...) will stop the task it has not been run yet", "tokens": ["how", "to", "ensure", "that", "my", "tasks", "are", "responsive", "to", "interruption", "when", "i", "call", "future.cancel()", "?", "", "call", "future.cancel(...)", "will", "stop", "the", "task", "it", "has", "not", "been", "run", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> future.cancel() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "future.cancel()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "future.cancel()", "label": "API", "asoc": []}]}
{"text": "how to ensure that my tasks are responsive to interruption when i call future.cancel() ?  invoke future.cancel(...) will stop the task it has not been run yet", "tokens": ["how", "to", "ensure", "that", "my", "tasks", "are", "responsive", "to", "interruption", "when", "i", "call", "future.cancel()", "?", "", "invoke", "future.cancel(...)", "will", "stop", "the", "task", "it", "has", "not", "been", "run", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> future.cancel() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "future.cancel()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "future.cancel()", "label": "API", "asoc": []}]}
{"text": "how to ensure that my tasks are responsive to interruption when i call future.cancel() ?  tell future.cancel(...) will stop the task it has not been run yet", "tokens": ["how", "to", "ensure", "that", "my", "tasks", "are", "responsive", "to", "interruption", "when", "i", "call", "future.cancel()", "?", "", "tell", "future.cancel(...)", "will", "stop", "the", "task", "it", "has", "not", "been", "run", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> future.cancel() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "future.cancel()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "future.cancel()", "label": "API", "asoc": []}]}
{"text": "how to ensure that my tasks are responsive to interruption when i call future.cancel() ?  indicate future.cancel(...) will stop the task it has not been run yet", "tokens": ["how", "to", "ensure", "that", "my", "tasks", "are", "responsive", "to", "interruption", "when", "i", "call", "future.cancel()", "?", "", "indicate", "future.cancel(...)", "will", "stop", "the", "task", "it", "has", "not", "been", "run", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> future.cancel() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "future.cancel()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "future.cancel()", "label": "API", "asoc": []}]}
{"text": "how to ensure that my tasks are responsive to interruption when i call future.cancel() ?  occur future.cancel(...) will stop the task it has not been run yet", "tokens": ["how", "to", "ensure", "that", "my", "tasks", "are", "responsive", "to", "interruption", "when", "i", "call", "future.cancel()", "?", "", "occur", "future.cancel(...)", "will", "stop", "the", "task", "it", "has", "not", "been", "run", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> future.cancel() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "future.cancel()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "future.cancel()", "label": "API", "asoc": []}]}
{"text": "how to ensure that my tasks are responsive to interruption when i call future.cancel() ?  perform future.cancel(...) will stop the task it has not been run yet", "tokens": ["how", "to", "ensure", "that", "my", "tasks", "are", "responsive", "to", "interruption", "when", "i", "call", "future.cancel()", "?", "", "perform", "future.cancel(...)", "will", "stop", "the", "task", "it", "has", "not", "been", "run", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> future.cancel() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "future.cancel()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "future.cancel()", "label": "API", "asoc": []}]}
{"text": "how to ensure that my tasks are responsive to interruption when i call future.cancel() ?  prompt future.cancel(...) will stop the task it has not been run yet", "tokens": ["how", "to", "ensure", "that", "my", "tasks", "are", "responsive", "to", "interruption", "when", "i", "call", "future.cancel()", "?", "", "prompt", "future.cancel(...)", "will", "stop", "the", "task", "it", "has", "not", "been", "run", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> future.cancel() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "future.cancel()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "future.cancel()", "label": "API", "asoc": []}]}
{"text": "how to ensure that my tasks are responsive to interruption when i call future.cancel() ?  notify future.cancel(...) will stop the task it has not been run yet", "tokens": ["how", "to", "ensure", "that", "my", "tasks", "are", "responsive", "to", "interruption", "when", "i", "call", "future.cancel()", "?", "", "notify", "future.cancel(...)", "will", "stop", "the", "task", "it", "has", "not", "been", "run", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> future.cancel() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "future.cancel()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "future.cancel()", "label": "API", "asoc": []}]}
{"text": "how to ensure that my tasks are responsive to interruption when i call future.cancel() ?  execute future.cancel(...) will stop the task it has not been run yet", "tokens": ["how", "to", "ensure", "that", "my", "tasks", "are", "responsive", "to", "interruption", "when", "i", "call", "future.cancel()", "?", "", "execute", "future.cancel(...)", "will", "stop", "the", "task", "it", "has", "not", "been", "run", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> future.cancel() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "future.cancel()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "future.cancel()", "label": "API", "asoc": []}]}
{"text": "how to ensure that my tasks are responsive to interruption when i call future.cancel() ?  run future.cancel(...) will stop the task it has not been run yet", "tokens": ["how", "to", "ensure", "that", "my", "tasks", "are", "responsive", "to", "interruption", "when", "i", "call", "future.cancel()", "?", "", "run", "future.cancel(...)", "will", "stop", "the", "task", "it", "has", "not", "been", "run", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> future.cancel() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "future.cancel()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "future.cancel()", "label": "API", "asoc": []}]}
{"text": "how to ensure that my tasks are responsive to interruption when i call future.cancel() ?  enforce future.cancel(...) will stop the task it has not been run yet", "tokens": ["how", "to", "ensure", "that", "my", "tasks", "are", "responsive", "to", "interruption", "when", "i", "call", "future.cancel()", "?", "", "enforce", "future.cancel(...)", "will", "stop", "the", "task", "it", "has", "not", "been", "run", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> future.cancel() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "future.cancel()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "future.cancel()", "label": "API", "asoc": []}]}
{"text": "how to ensure that my tasks are responsive to interruption when i call future.cancel() ?  fire future.cancel(...) will stop the task it has not been run yet", "tokens": ["how", "to", "ensure", "that", "my", "tasks", "are", "responsive", "to", "interruption", "when", "i", "call", "future.cancel()", "?", "", "fire", "future.cancel(...)", "will", "stop", "the", "task", "it", "has", "not", "been", "run", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> future.cancel() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "future.cancel()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "future.cancel()", "label": "API", "asoc": []}]}
{"text": "how to ensure that my tasks are responsive to interruption when i call future.cancel() ?  trigger future.cancel(...) will stop the task it has not been run yet", "tokens": ["how", "to", "ensure", "that", "my", "tasks", "are", "responsive", "to", "interruption", "when", "i", "call", "future.cancel()", "?", "", "trigger", "future.cancel(...)", "will", "stop", "the", "task", "it", "has", "not", "been", "run", "yet", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> future.cancel() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [13], "text": "future.cancel()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "future.cancel()", "label": "API", "asoc": []}]}
{"text": "compute your run time to about a minute ,  (n=100000000) or put some heavy computations in the compute()", "tokens": ["compute", "your", "run", "time", "to", "about", "a", "minute", ",", "", "(n=100000000)", "or", "put", "some", "heavy", "computations", "in", "the", "compute()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> compute() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "compute()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "compute()", "label": "API", "asoc": []}]}
{"text": "calculate your run time to about a minute ,  (n=100000000) or put some heavy computations in the compute()", "tokens": ["calculate", "your", "run", "time", "to", "about", "a", "minute", ",", "", "(n=100000000)", "or", "put", "some", "heavy", "computations", "in", "the", "compute()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> compute() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "compute()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "compute()", "label": "API", "asoc": []}]}
{"text": "determine your run time to about a minute ,  (n=100000000) or put some heavy computations in the compute()", "tokens": ["determine", "your", "run", "time", "to", "about", "a", "minute", ",", "", "(n=100000000)", "or", "put", "some", "heavy", "computations", "in", "the", "compute()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> compute() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "compute()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "compute()", "label": "API", "asoc": []}]}
{"text": "evaluate your run time to about a minute ,  (n=100000000) or put some heavy computations in the compute()", "tokens": ["evaluate", "your", "run", "time", "to", "about", "a", "minute", ",", "", "(n=100000000)", "or", "put", "some", "heavy", "computations", "in", "the", "compute()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> compute() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "compute()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "compute()", "label": "API", "asoc": []}]}
{"text": "solve your run time to about a minute ,  (n=100000000) or put some heavy computations in the compute()", "tokens": ["solve", "your", "run", "time", "to", "about", "a", "minute", ",", "", "(n=100000000)", "or", "put", "some", "heavy", "computations", "in", "the", "compute()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> compute() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "compute()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "compute()", "label": "API", "asoc": []}]}
{"text": "scale your run time to about a minute ,  (n=100000000) or put some heavy computations in the compute()", "tokens": ["scale", "your", "run", "time", "to", "about", "a", "minute", ",", "", "(n=100000000)", "or", "put", "some", "heavy", "computations", "in", "the", "compute()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> compute() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "compute()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "compute()", "label": "API", "asoc": []}]}
{"text": "measure your run time to about a minute ,  (n=100000000) or put some heavy computations in the compute()", "tokens": ["measure", "your", "run", "time", "to", "about", "a", "minute", ",", "", "(n=100000000)", "or", "put", "some", "heavy", "computations", "in", "the", "compute()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> compute() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "compute()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "compute()", "label": "API", "asoc": []}]}
{"text": "recalculate your run time to about a minute ,  (n=100000000) or put some heavy computations in the compute()", "tokens": ["recalculate", "your", "run", "time", "to", "about", "a", "minute", ",", "", "(n=100000000)", "or", "put", "some", "heavy", "computations", "in", "the", "compute()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> compute() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "compute()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "compute()", "label": "API", "asoc": []}]}
{"text": "multiply your run time to about a minute ,  (n=100000000) or put some heavy computations in the compute()", "tokens": ["multiply", "your", "run", "time", "to", "about", "a", "minute", ",", "", "(n=100000000)", "or", "put", "some", "heavy", "computations", "in", "the", "compute()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> compute() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "compute()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "compute()", "label": "API", "asoc": []}]}
{"text": "count your run time to about a minute ,  (n=100000000) or put some heavy computations in the compute()", "tokens": ["count", "your", "run", "time", "to", "about", "a", "minute", ",", "", "(n=100000000)", "or", "put", "some", "heavy", "computations", "in", "the", "compute()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> compute() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "compute()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "compute()", "label": "API", "asoc": []}]}
{"text": "figure your run time to about a minute ,  (n=100000000) or put some heavy computations in the compute()", "tokens": ["figure", "your", "run", "time", "to", "about", "a", "minute", ",", "", "(n=100000000)", "or", "put", "some", "heavy", "computations", "in", "the", "compute()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> compute() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "compute()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "compute()", "label": "API", "asoc": []}]}
{"text": "subtract your run time to about a minute ,  (n=100000000) or put some heavy computations in the compute()", "tokens": ["subtract", "your", "run", "time", "to", "about", "a", "minute", ",", "", "(n=100000000)", "or", "put", "some", "heavy", "computations", "in", "the", "compute()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> compute() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "compute()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "compute()", "label": "API", "asoc": []}]}
{"text": "estimate your run time to about a minute ,  (n=100000000) or put some heavy computations in the compute()", "tokens": ["estimate", "your", "run", "time", "to", "about", "a", "minute", ",", "", "(n=100000000)", "or", "put", "some", "heavy", "computations", "in", "the", "compute()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> compute() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "compute()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "compute()", "label": "API", "asoc": []}]}
{"text": "return your run time to about a minute ,  (n=100000000) or put some heavy computations in the compute()", "tokens": ["return", "your", "run", "time", "to", "about", "a", "minute", ",", "", "(n=100000000)", "or", "put", "some", "heavy", "computations", "in", "the", "compute()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> compute() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "compute()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "compute()", "label": "API", "asoc": []}]}
{"text": "increment your run time to about a minute ,  (n=100000000) or put some heavy computations in the compute()", "tokens": ["increment", "your", "run", "time", "to", "about", "a", "minute", ",", "", "(n=100000000)", "or", "put", "some", "heavy", "computations", "in", "the", "compute()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> compute() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [18], "text": "compute()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "compute()", "label": "API", "asoc": []}]}
{"text": "you build a mypanel object and invoke callfilling() on it to set the values in the tablemodel", "tokens": ["you", "build", "a", "mypanel", "object", "and", "invoke", "callfilling()", "on", "it", "to", "set", "the", "values", "in", "the", "tablemodel", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> callfilling() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "callfilling()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "callfilling()", "label": "API", "asoc": []}]}
{"text": "you produce a mypanel object and invoke callfilling() on it to set the values in the tablemodel", "tokens": ["you", "produce", "a", "mypanel", "object", "and", "invoke", "callfilling()", "on", "it", "to", "set", "the", "values", "in", "the", "tablemodel", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> callfilling() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "callfilling()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "callfilling()", "label": "API", "asoc": []}]}
{"text": "you construct a mypanel object and invoke callfilling() on it to set the values in the tablemodel", "tokens": ["you", "construct", "a", "mypanel", "object", "and", "invoke", "callfilling()", "on", "it", "to", "set", "the", "values", "in", "the", "tablemodel", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> callfilling() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "callfilling()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "callfilling()", "label": "API", "asoc": []}]}
{"text": "you generate a mypanel object and invoke callfilling() on it to set the values in the tablemodel", "tokens": ["you", "generate", "a", "mypanel", "object", "and", "invoke", "callfilling()", "on", "it", "to", "set", "the", "values", "in", "the", "tablemodel", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> callfilling() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "callfilling()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "callfilling()", "label": "API", "asoc": []}]}
{"text": "you establish a mypanel object and invoke callfilling() on it to set the values in the tablemodel", "tokens": ["you", "establish", "a", "mypanel", "object", "and", "invoke", "callfilling()", "on", "it", "to", "set", "the", "values", "in", "the", "tablemodel", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> callfilling() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "callfilling()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "callfilling()", "label": "API", "asoc": []}]}
{"text": "you make a mypanel object and invoke callfilling() on it to set the values in the tablemodel", "tokens": ["you", "make", "a", "mypanel", "object", "and", "invoke", "callfilling()", "on", "it", "to", "set", "the", "values", "in", "the", "tablemodel", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> callfilling() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "callfilling()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "callfilling()", "label": "API", "asoc": []}]}
{"text": "you obtain a mypanel object and invoke callfilling() on it to set the values in the tablemodel", "tokens": ["you", "obtain", "a", "mypanel", "object", "and", "invoke", "callfilling()", "on", "it", "to", "set", "the", "values", "in", "the", "tablemodel", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> callfilling() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "callfilling()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "callfilling()", "label": "API", "asoc": []}]}
{"text": "you reconstitute a mypanel object and invoke callfilling() on it to set the values in the tablemodel", "tokens": ["you", "reconstitute", "a", "mypanel", "object", "and", "invoke", "callfilling()", "on", "it", "to", "set", "the", "values", "in", "the", "tablemodel", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> callfilling() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "callfilling()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "callfilling()", "label": "API", "asoc": []}]}
{"text": "you compose a mypanel object and invoke callfilling() on it to set the values in the tablemodel", "tokens": ["you", "compose", "a", "mypanel", "object", "and", "invoke", "callfilling()", "on", "it", "to", "set", "the", "values", "in", "the", "tablemodel", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> callfilling() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "callfilling()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "callfilling()", "label": "API", "asoc": []}]}
{"text": "you instantiate a mypanel object and invoke callfilling() on it to set the values in the tablemodel", "tokens": ["you", "instantiate", "a", "mypanel", "object", "and", "invoke", "callfilling()", "on", "it", "to", "set", "the", "values", "in", "the", "tablemodel", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> callfilling() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "callfilling()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "callfilling()", "label": "API", "asoc": []}]}
{"text": "you implement a mypanel object and invoke callfilling() on it to set the values in the tablemodel", "tokens": ["you", "implement", "a", "mypanel", "object", "and", "invoke", "callfilling()", "on", "it", "to", "set", "the", "values", "in", "the", "tablemodel", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> callfilling() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "callfilling()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "callfilling()", "label": "API", "asoc": []}]}
{"text": "you get a mypanel object and invoke callfilling() on it to set the values in the tablemodel", "tokens": ["you", "get", "a", "mypanel", "object", "and", "invoke", "callfilling()", "on", "it", "to", "set", "the", "values", "in", "the", "tablemodel", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> callfilling() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "callfilling()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "callfilling()", "label": "API", "asoc": []}]}
{"text": "you retrieve a mypanel object and invoke callfilling() on it to set the values in the tablemodel", "tokens": ["you", "retrieve", "a", "mypanel", "object", "and", "invoke", "callfilling()", "on", "it", "to", "set", "the", "values", "in", "the", "tablemodel", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> callfilling() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "callfilling()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "callfilling()", "label": "API", "asoc": []}]}
{"text": "you return a mypanel object and invoke callfilling() on it to set the values in the tablemodel", "tokens": ["you", "return", "a", "mypanel", "object", "and", "invoke", "callfilling()", "on", "it", "to", "set", "the", "values", "in", "the", "tablemodel", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> callfilling() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "callfilling()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "callfilling()", "label": "API", "asoc": []}]}
{"text": "you install a mypanel object and invoke callfilling() on it to set the values in the tablemodel", "tokens": ["you", "install", "a", "mypanel", "object", "and", "invoke", "callfilling()", "on", "it", "to", "set", "the", "values", "in", "the", "tablemodel", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> callfilling() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "callfilling()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "callfilling()", "label": "API", "asoc": []}]}
{"text": "you set up a mypanel object and invoke callfilling() on it to set the values in the tablemodel", "tokens": ["you", "set", "up", "a", "mypanel", "object", "and", "invoke", "callfilling()", "on", "it", "to", "set", "the", "values", "in", "the", "tablemodel", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> callfilling() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [8], "text": "callfilling()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "callfilling()", "label": "API", "asoc": []}]}
{"text": "to return the values of strings ,  use the string.equals method", "tokens": ["to", "return", "the", "values", "of", "strings", ",", "", "use", "the", "string.equals", "method", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> string.equals <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [10], "text": "string.equals"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "string.equals", "label": "API", "asoc": []}]}
{"text": "every time you can to change the appearance of your jpanel ,  you must invoke repaint()", "tokens": ["every", "time", "you", "can", "to", "change", "the", "appearance", "of", "your", "jpanel", ",", "", "you", "must", "invoke", "repaint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "every time you can to change the appearance of your jpanel ,  you must tell repaint()", "tokens": ["every", "time", "you", "can", "to", "change", "the", "appearance", "of", "your", "jpanel", ",", "", "you", "must", "tell", "repaint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "every time you can to change the appearance of your jpanel ,  you must indicate repaint()", "tokens": ["every", "time", "you", "can", "to", "change", "the", "appearance", "of", "your", "jpanel", ",", "", "you", "must", "indicate", "repaint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "every time you can to change the appearance of your jpanel ,  you must occur repaint()", "tokens": ["every", "time", "you", "can", "to", "change", "the", "appearance", "of", "your", "jpanel", ",", "", "you", "must", "occur", "repaint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "every time you can to change the appearance of your jpanel ,  you must perform repaint()", "tokens": ["every", "time", "you", "can", "to", "change", "the", "appearance", "of", "your", "jpanel", ",", "", "you", "must", "perform", "repaint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "every time you can to change the appearance of your jpanel ,  you must prompt repaint()", "tokens": ["every", "time", "you", "can", "to", "change", "the", "appearance", "of", "your", "jpanel", ",", "", "you", "must", "prompt", "repaint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "every time you can to change the appearance of your jpanel ,  you must notify repaint()", "tokens": ["every", "time", "you", "can", "to", "change", "the", "appearance", "of", "your", "jpanel", ",", "", "you", "must", "notify", "repaint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "every time you can to change the appearance of your jpanel ,  you must execute repaint()", "tokens": ["every", "time", "you", "can", "to", "change", "the", "appearance", "of", "your", "jpanel", ",", "", "you", "must", "execute", "repaint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "every time you can to change the appearance of your jpanel ,  you must run repaint()", "tokens": ["every", "time", "you", "can", "to", "change", "the", "appearance", "of", "your", "jpanel", ",", "", "you", "must", "run", "repaint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "every time you can to change the appearance of your jpanel ,  you must enforce repaint()", "tokens": ["every", "time", "you", "can", "to", "change", "the", "appearance", "of", "your", "jpanel", ",", "", "you", "must", "enforce", "repaint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "every time you can to change the appearance of your jpanel ,  you must fire repaint()", "tokens": ["every", "time", "you", "can", "to", "change", "the", "appearance", "of", "your", "jpanel", ",", "", "you", "must", "fire", "repaint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "every time you can to change the appearance of your jpanel ,  you must trigger repaint()", "tokens": ["every", "time", "you", "can", "to", "change", "the", "appearance", "of", "your", "jpanel", ",", "", "you", "must", "trigger", "repaint()", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> repaint() <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [16], "text": "repaint()"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "repaint()", "label": "API", "asoc": []}]}
{"text": "to this ,  just invoke new oracle.sql.raw(byte[]) .", "tokens": ["to", "this", ",", "", "just", "invoke", "new", "oracle.sql.raw(byte[])", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> oracle.sql.raw(byte[]) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "oracle.sql.raw(byte[])"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "oracle.sql.raw(byte[])", "label": "API", "asoc": []}]}
{"text": "to this ,  just tell new oracle.sql.raw(byte[]) .", "tokens": ["to", "this", ",", "", "just", "tell", "new", "oracle.sql.raw(byte[])", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> oracle.sql.raw(byte[]) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "oracle.sql.raw(byte[])"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "oracle.sql.raw(byte[])", "label": "API", "asoc": []}]}
{"text": "to this ,  just indicate new oracle.sql.raw(byte[]) .", "tokens": ["to", "this", ",", "", "just", "indicate", "new", "oracle.sql.raw(byte[])", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> oracle.sql.raw(byte[]) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "oracle.sql.raw(byte[])"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "oracle.sql.raw(byte[])", "label": "API", "asoc": []}]}
{"text": "to this ,  just occur new oracle.sql.raw(byte[]) .", "tokens": ["to", "this", ",", "", "just", "occur", "new", "oracle.sql.raw(byte[])", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> oracle.sql.raw(byte[]) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "oracle.sql.raw(byte[])"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "oracle.sql.raw(byte[])", "label": "API", "asoc": []}]}
{"text": "to this ,  just perform new oracle.sql.raw(byte[]) .", "tokens": ["to", "this", ",", "", "just", "perform", "new", "oracle.sql.raw(byte[])", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> oracle.sql.raw(byte[]) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "oracle.sql.raw(byte[])"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "oracle.sql.raw(byte[])", "label": "API", "asoc": []}]}
{"text": "to this ,  just prompt new oracle.sql.raw(byte[]) .", "tokens": ["to", "this", ",", "", "just", "prompt", "new", "oracle.sql.raw(byte[])", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> oracle.sql.raw(byte[]) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "oracle.sql.raw(byte[])"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "oracle.sql.raw(byte[])", "label": "API", "asoc": []}]}
{"text": "to this ,  just notify new oracle.sql.raw(byte[]) .", "tokens": ["to", "this", ",", "", "just", "notify", "new", "oracle.sql.raw(byte[])", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> oracle.sql.raw(byte[]) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "oracle.sql.raw(byte[])"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "oracle.sql.raw(byte[])", "label": "API", "asoc": []}]}
{"text": "to this ,  just execute new oracle.sql.raw(byte[]) .", "tokens": ["to", "this", ",", "", "just", "execute", "new", "oracle.sql.raw(byte[])", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> oracle.sql.raw(byte[]) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "oracle.sql.raw(byte[])"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "oracle.sql.raw(byte[])", "label": "API", "asoc": []}]}
{"text": "to this ,  just run new oracle.sql.raw(byte[]) .", "tokens": ["to", "this", ",", "", "just", "run", "new", "oracle.sql.raw(byte[])", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> oracle.sql.raw(byte[]) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "oracle.sql.raw(byte[])"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "oracle.sql.raw(byte[])", "label": "API", "asoc": []}]}
{"text": "to this ,  just enforce new oracle.sql.raw(byte[]) .", "tokens": ["to", "this", ",", "", "just", "enforce", "new", "oracle.sql.raw(byte[])", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> oracle.sql.raw(byte[]) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "oracle.sql.raw(byte[])"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "oracle.sql.raw(byte[])", "label": "API", "asoc": []}]}
{"text": "to this ,  just fire new oracle.sql.raw(byte[]) .", "tokens": ["to", "this", ",", "", "just", "fire", "new", "oracle.sql.raw(byte[])", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> oracle.sql.raw(byte[]) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "oracle.sql.raw(byte[])"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "oracle.sql.raw(byte[])", "label": "API", "asoc": []}]}
{"text": "to this ,  just trigger new oracle.sql.raw(byte[]) .", "tokens": ["to", "this", ",", "", "just", "trigger", "new", "oracle.sql.raw(byte[])", ".", ""], "record": "<extra_id_0> <extra_id_0> API <extra_id_5> oracle.sql.raw(byte[]) <extra_id_1> <extra_id_1>", "entity": [{"type": "API", "offset": [7], "text": "oracle.sql.raw(byte[])"}], "relation": [], "event": [], "spot": ["API"], "asoc": [], "spot_asoc": [{"span": "oracle.sql.raw(byte[])", "label": "API", "asoc": []}]}
